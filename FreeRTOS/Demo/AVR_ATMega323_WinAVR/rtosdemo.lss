
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000050  00800200  00002e66  00002efa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e66  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068e  00800250  00800250  00002f4a  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002f4a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002fa8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000210  00000000  00000000  00002fe8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000063da  00000000  00000000  000031f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002050  00000000  00000000  000095d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000036ff  00000000  00000000  0000b622  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000eb0  00000000  00000000  0000ed24  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c91  00000000  00000000  0000fbd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004db9  00000000  00000000  00011865  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000148  00000000  00000000  0001661e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 db 01 	jmp	0x3b6	; 0x3b6 <__ctors_end>
       4:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
       8:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
       c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      10:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      14:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      18:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      1c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      20:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      24:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      28:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      2c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      30:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      34:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      38:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      3c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      40:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      44:	0c 94 90 16 	jmp	0x2d20	; 0x2d20 <__vector_17>
      48:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      4c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      50:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      54:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      58:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      5c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      60:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      64:	0c 94 0b 03 	jmp	0x616	; 0x616 <__vector_25>
      68:	0c 94 50 03 	jmp	0x6a0	; 0x6a0 <__vector_26>
      6c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      70:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      74:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      78:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      7c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      80:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      84:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      88:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      8c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      90:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      94:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      98:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      9c:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      a0:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      a4:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      a8:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      ac:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      b0:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      b4:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      b8:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      bc:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      c0:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      c4:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      c8:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      cc:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      d0:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      d4:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      d8:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      dc:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>
      e0:	0c 94 fc 01 	jmp	0x3f8	; 0x3f8 <__bad_interrupt>

000000e4 <__trampolines_start>:
      e4:	0c 94 3c 01 	jmp	0x278	; 0x278 <vPolledQueueConsumer>
      e8:	0c 94 76 01 	jmp	0x2ec	; 0x2ec <vComRxTask>
      ec:	0c 94 88 00 	jmp	0x110	; 0x110 <prvIdleTask>
      f0:	0c 94 01 14 	jmp	0x2802	; 0x2802 <prvFlashCoRoutine>
      f4:	0c 94 39 04 	jmp	0x872	; 0x872 <prvRegisterCheck2>
      f8:	0c 94 b6 00 	jmp	0x16c	; 0x16c <vCompeteingIntMathTask>
      fc:	0c 94 97 03 	jmp	0x72e	; 0x72e <prvRegisterCheck1>
     100:	0c 94 fe 01 	jmp	0x3fc	; 0x3fc <vErrorChecks>
     104:	0c 94 48 14 	jmp	0x2890	; 0x2890 <prvFixedDelayCoRoutine>
     108:	0c 94 0a 01 	jmp	0x214	; 0x214 <vPolledQueueProducer>
     10c:	0c 94 b5 01 	jmp	0x36a	; 0x36a <vComTxTask>

00000110 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     110:	80 91 66 02 	lds	r24, 0x0266	; 0x800266 <uxDeletedTasksWaitingCleanUp>
     114:	88 23       	and	r24, r24
     116:	09 f1       	breq	.+66     	; 0x15a <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     118:	0f b6       	in	r0, 0x3f	; 63
     11a:	f8 94       	cli
     11c:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     11e:	e0 91 6c 02 	lds	r30, 0x026C	; 0x80026c <xTasksWaitingTermination+0x5>
     122:	f0 91 6d 02 	lds	r31, 0x026D	; 0x80026d <xTasksWaitingTermination+0x6>
     126:	c6 81       	ldd	r28, Z+6	; 0x06
     128:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     12a:	ce 01       	movw	r24, r28
     12c:	02 96       	adiw	r24, 0x02	; 2
     12e:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
				--uxCurrentNumberOfTasks;
     132:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <uxCurrentNumberOfTasks>
     136:	81 50       	subi	r24, 0x01	; 1
     138:	80 93 65 02 	sts	0x0265, r24	; 0x800265 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     13c:	80 91 66 02 	lds	r24, 0x0266	; 0x800266 <uxDeletedTasksWaitingCleanUp>
     140:	81 50       	subi	r24, 0x01	; 1
     142:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     146:	0f 90       	pop	r0
     148:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     14a:	8f 89       	ldd	r24, Y+23	; 0x17
     14c:	98 8d       	ldd	r25, Y+24	; 0x18
     14e:	0e 94 32 13 	call	0x2664	; 0x2664 <vPortFree>
			vPortFree( pxTCB );
     152:	ce 01       	movw	r24, r28
     154:	0e 94 32 13 	call	0x2664	; 0x2664 <vPortFree>
     158:	db cf       	rjmp	.-74     	; 0x110 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     15a:	80 91 8f 02 	lds	r24, 0x028F	; 0x80028f <pxReadyTasksLists>
     15e:	82 30       	cpi	r24, 0x02	; 2
     160:	10 f0       	brcs	.+4      	; 0x166 <prvIdleTask+0x56>
			{
				taskYIELD();
     162:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     166:	0e 94 37 02 	call	0x46e	; 0x46e <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     16a:	d2 cf       	rjmp	.-92     	; 0x110 <prvIdleTask>

0000016c <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
     16c:	cf 93       	push	r28
     16e:	df 93       	push	r29
     170:	00 d0       	rcall	.+0      	; 0x172 <vCompeteingIntMathTask+0x6>
     172:	1f 92       	push	r1
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
     178:	7c 01       	movw	r14, r24
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
     17a:	00 e0       	ldi	r16, 0x00	; 0
     17c:	10 e0       	ldi	r17, 0x00	; 0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
     17e:	8b e7       	ldi	r24, 0x7B	; 123
     180:	88 2e       	mov	r8, r24
     182:	91 2c       	mov	r9, r1
     184:	a1 2c       	mov	r10, r1
     186:	b1 2c       	mov	r11, r1
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
     188:	97 e0       	ldi	r25, 0x07	; 7
     18a:	49 2e       	mov	r4, r25
     18c:	51 2c       	mov	r5, r1
     18e:	61 2c       	mov	r6, r1
     190:	71 2c       	mov	r7, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
     192:	dd 24       	eor	r13, r13
     194:	d3 94       	inc	r13
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
     196:	89 82       	std	Y+1, r8	; 0x01
     198:	9a 82       	std	Y+2, r9	; 0x02
     19a:	ab 82       	std	Y+3, r10	; 0x03
     19c:	bc 82       	std	Y+4, r11	; 0x04
		lValue += intgCONST2;
     19e:	89 81       	ldd	r24, Y+1	; 0x01
     1a0:	9a 81       	ldd	r25, Y+2	; 0x02
     1a2:	ab 81       	ldd	r26, Y+3	; 0x03
     1a4:	bc 81       	ldd	r27, Y+4	; 0x04
     1a6:	89 5b       	subi	r24, 0xB9	; 185
     1a8:	9b 46       	sbci	r25, 0x6B	; 107
     1aa:	ac 4f       	sbci	r26, 0xFC	; 252
     1ac:	bf 4f       	sbci	r27, 0xFF	; 255
     1ae:	89 83       	std	Y+1, r24	; 0x01
     1b0:	9a 83       	std	Y+2, r25	; 0x02
     1b2:	ab 83       	std	Y+3, r26	; 0x03
     1b4:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
     1b6:	29 81       	ldd	r18, Y+1	; 0x01
     1b8:	3a 81       	ldd	r19, Y+2	; 0x02
     1ba:	4b 81       	ldd	r20, Y+3	; 0x03
     1bc:	5c 81       	ldd	r21, Y+4	; 0x04
     1be:	ad ef       	ldi	r26, 0xFD	; 253
     1c0:	bf ef       	ldi	r27, 0xFF	; 255
     1c2:	0e 94 f6 16 	call	0x2dec	; 0x2dec <__mulohisi3>
     1c6:	69 83       	std	Y+1, r22	; 0x01
     1c8:	7a 83       	std	Y+2, r23	; 0x02
     1ca:	8b 83       	std	Y+3, r24	; 0x03
     1cc:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
     1ce:	69 81       	ldd	r22, Y+1	; 0x01
     1d0:	7a 81       	ldd	r23, Y+2	; 0x02
     1d2:	8b 81       	ldd	r24, Y+3	; 0x03
     1d4:	9c 81       	ldd	r25, Y+4	; 0x04
     1d6:	a3 01       	movw	r20, r6
     1d8:	92 01       	movw	r18, r4
     1da:	0e 94 c9 16 	call	0x2d92	; 0x2d92 <__divmodsi4>
     1de:	29 83       	std	Y+1, r18	; 0x01
     1e0:	3a 83       	std	Y+2, r19	; 0x02
     1e2:	4b 83       	std	Y+3, r20	; 0x03
     1e4:	5c 83       	std	Y+4, r21	; 0x04

		/* If the calculation is found to be incorrect we stop setting the
		TaskHasExecuted variable so the check task can see an error has
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
     1e6:	89 81       	ldd	r24, Y+1	; 0x01
     1e8:	9a 81       	ldd	r25, Y+2	; 0x02
     1ea:	ab 81       	ldd	r26, Y+3	; 0x03
     1ec:	bc 81       	ldd	r27, Y+4	; 0x04
     1ee:	8b 31       	cpi	r24, 0x1B	; 27
     1f0:	97 47       	sbci	r25, 0x77	; 119
     1f2:	ae 4f       	sbci	r26, 0xFE	; 254
     1f4:	bf 4f       	sbci	r27, 0xFF	; 255
     1f6:	19 f0       	breq	.+6      	; 0x1fe <vCompeteingIntMathTask+0x92>
     1f8:	01 e0       	ldi	r16, 0x01	; 1
     1fa:	10 e0       	ldi	r17, 0x00	; 0
     1fc:	cc cf       	rjmp	.-104    	; 0x196 <vCompeteingIntMathTask+0x2a>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
     1fe:	01 15       	cp	r16, r1
     200:	11 05       	cpc	r17, r1
     202:	d1 f7       	brne	.-12     	; 0x1f8 <vCompeteingIntMathTask+0x8c>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
     204:	0f b6       	in	r0, 0x3f	; 63
     206:	f8 94       	cli
     208:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
     20a:	f7 01       	movw	r30, r14
     20c:	d0 82       	st	Z, r13
			portEXIT_CRITICAL();
     20e:	0f 90       	pop	r0
     210:	0f be       	out	0x3f, r0	; 63
     212:	c1 cf       	rjmp	.-126    	; 0x196 <vCompeteingIntMathTask+0x2a>

00000214 <vPolledQueueProducer>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     214:	cf 93       	push	r28
     216:	df 93       	push	r29
     218:	1f 92       	push	r1
     21a:	1f 92       	push	r1
     21c:	cd b7       	in	r28, 0x3d	; 61
     21e:	de b7       	in	r29, 0x3e	; 62
     220:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
     222:	1a 82       	std	Y+2, r1	; 0x02
     224:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xError = pdFALSE, xLoop;
     226:	00 e0       	ldi	r16, 0x00	; 0
     228:	13 e0       	ldi	r17, 0x03	; 3
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     22a:	20 e0       	ldi	r18, 0x00	; 0
     22c:	40 e0       	ldi	r20, 0x00	; 0
     22e:	50 e0       	ldi	r21, 0x00	; 0
     230:	be 01       	movw	r22, r28
     232:	6f 5f       	subi	r22, 0xFF	; 255
     234:	7f 4f       	sbci	r23, 0xFF	; 255
     236:	f7 01       	movw	r30, r14
     238:	80 81       	ld	r24, Z
     23a:	91 81       	ldd	r25, Z+1	; 0x01
     23c:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <xQueueGenericSend>
     240:	81 30       	cpi	r24, 0x01	; 1
     242:	91 f4       	brne	.+36     	; 0x268 <vPolledQueueProducer+0x54>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
     244:	01 11       	cpse	r16, r1
     246:	0a c0       	rjmp	.+20     	; 0x25c <vPolledQueueProducer+0x48>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     248:	0f b6       	in	r0, 0x3f	; 63
     24a:	f8 94       	cli
     24c:	0f 92       	push	r0
						xPollingProducerCount++;
     24e:	80 91 d2 08 	lds	r24, 0x08D2	; 0x8008d2 <xPollingProducerCount>
     252:	8f 5f       	subi	r24, 0xFF	; 255
     254:	80 93 d2 08 	sts	0x08D2, r24	; 0x8008d2 <xPollingProducerCount>
					portEXIT_CRITICAL();
     258:	0f 90       	pop	r0
     25a:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     25c:	89 81       	ldd	r24, Y+1	; 0x01
     25e:	9a 81       	ldd	r25, Y+2	; 0x02
     260:	01 96       	adiw	r24, 0x01	; 1
     262:	9a 83       	std	Y+2, r25	; 0x02
     264:	89 83       	std	Y+1, r24	; 0x01
     266:	01 c0       	rjmp	.+2      	; 0x26a <vPolledQueueProducer+0x56>
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     268:	01 e0       	ldi	r16, 0x01	; 1
     26a:	11 50       	subi	r17, 0x01	; 1
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     26c:	f1 f6       	brne	.-68     	; 0x22a <vPolledQueueProducer+0x16>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     26e:	83 e0       	ldi	r24, 0x03	; 3
     270:	90 e0       	ldi	r25, 0x00	; 0
     272:	0e 94 4f 08 	call	0x109e	; 0x109e <vTaskDelay>
	}
     276:	d8 cf       	rjmp	.-80     	; 0x228 <vPolledQueueProducer+0x14>

00000278 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     278:	cf 93       	push	r28
     27a:	df 93       	push	r29
     27c:	1f 92       	push	r1
     27e:	1f 92       	push	r1
     280:	cd b7       	in	r28, 0x3d	; 61
     282:	de b7       	in	r29, 0x3e	; 62
     284:	6c 01       	movw	r12, r24
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE;
     286:	f1 2c       	mov	r15, r1
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     288:	00 e0       	ldi	r16, 0x00	; 0
     28a:	10 e0       	ldi	r17, 0x00	; 0
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     28c:	f6 01       	movw	r30, r12
     28e:	80 81       	ld	r24, Z
     290:	91 81       	ldd	r25, Z+1	; 0x01
     292:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <uxQueueMessagesWaiting>
     296:	88 23       	and	r24, r24
     298:	21 f1       	breq	.+72     	; 0x2e2 <vPolledQueueConsumer+0x6a>
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     29a:	40 e0       	ldi	r20, 0x00	; 0
     29c:	50 e0       	ldi	r21, 0x00	; 0
     29e:	be 01       	movw	r22, r28
     2a0:	6f 5f       	subi	r22, 0xFF	; 255
     2a2:	7f 4f       	sbci	r23, 0xFF	; 255
     2a4:	f6 01       	movw	r30, r12
     2a6:	80 81       	ld	r24, Z
     2a8:	91 81       	ldd	r25, Z+1	; 0x01
     2aa:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <xQueueReceive>
     2ae:	81 30       	cpi	r24, 0x01	; 1
     2b0:	69 f7       	brne	.-38     	; 0x28c <vPolledQueueConsumer+0x14>
			{
				if( usData != usExpectedValue )
     2b2:	89 81       	ldd	r24, Y+1	; 0x01
     2b4:	9a 81       	ldd	r25, Y+2	; 0x02
     2b6:	08 17       	cp	r16, r24
     2b8:	19 07       	cpc	r17, r25
     2ba:	69 f4       	brne	.+26     	; 0x2d6 <vPolledQueueConsumer+0x5e>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
     2bc:	f1 10       	cpse	r15, r1
     2be:	0e c0       	rjmp	.+28     	; 0x2dc <vPolledQueueConsumer+0x64>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     2c0:	0f b6       	in	r0, 0x3f	; 63
     2c2:	f8 94       	cli
     2c4:	0f 92       	push	r0
							xPollingConsumerCount++;
     2c6:	80 91 d3 08 	lds	r24, 0x08D3	; 0x8008d3 <xPollingConsumerCount>
     2ca:	8f 5f       	subi	r24, 0xFF	; 255
     2cc:	80 93 d3 08 	sts	0x08D3, r24	; 0x8008d3 <xPollingConsumerCount>
						portEXIT_CRITICAL();
     2d0:	0f 90       	pop	r0
     2d2:	0f be       	out	0x3f, r0	; 63
     2d4:	03 c0       	rjmp	.+6      	; 0x2dc <vPolledQueueConsumer+0x64>
     2d6:	8c 01       	movw	r16, r24
			{
				if( usData != usExpectedValue )
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     2d8:	ff 24       	eor	r15, r15
     2da:	f3 94       	inc	r15
						portEXIT_CRITICAL();
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     2dc:	0f 5f       	subi	r16, 0xFF	; 255
     2de:	1f 4f       	sbci	r17, 0xFF	; 255
     2e0:	d5 cf       	rjmp	.-86     	; 0x28c <vPolledQueueConsumer+0x14>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     2e2:	8f ee       	ldi	r24, 0xEF	; 239
     2e4:	9f ef       	ldi	r25, 0xFF	; 255
     2e6:	0e 94 4f 08 	call	0x109e	; 0x109e <vTaskDelay>
	}
     2ea:	d0 cf       	rjmp	.-96     	; 0x28c <vPolledQueueConsumer+0x14>

000002ec <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	1f 92       	push	r1
     2f2:	cd b7       	in	r28, 0x3d	; 61
     2f4:	de b7       	in	r29, 0x3e	; 62
signed char cExpectedByte, cByteRxed;
BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
     2f6:	00 e0       	ldi	r16, 0x00	; 0

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
     2f8:	11 e4       	ldi	r17, 0x41	; 65
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
     2fa:	4f ef       	ldi	r20, 0xFF	; 255
     2fc:	5f ef       	ldi	r21, 0xFF	; 255
     2fe:	be 01       	movw	r22, r28
     300:	6f 5f       	subi	r22, 0xFF	; 255
     302:	7f 4f       	sbci	r23, 0xFF	; 255
     304:	80 e0       	ldi	r24, 0x00	; 0
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <xSerialGetChar>
     30c:	88 23       	and	r24, r24
     30e:	41 f0       	breq	.+16     	; 0x320 <vComRxTask+0x34>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	81 13       	cpse	r24, r17
     314:	0a c0       	rjmp	.+20     	; 0x32a <vComRxTask+0x3e>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
     316:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <uxBaseLED>
     31a:	8f 5f       	subi	r24, 0xFF	; 255
     31c:	0e 94 66 02 	call	0x4cc	; 0x4cc <vParTestToggleLED>
     320:	1f 5f       	subi	r17, 0xFF	; 255

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
     322:	19 35       	cpi	r17, 0x59	; 89
     324:	51 f7       	brne	.-44     	; 0x2fa <vComRxTask+0xe>
     326:	10 e0       	ldi	r17, 0x00	; 0
     328:	01 c0       	rjmp	.+2      	; 0x32c <vComRxTask+0x40>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
				}
				else
				{
					xResyncRequired = pdTRUE;
     32a:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
     32c:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <uxBaseLED>
     330:	60 e0       	ldi	r22, 0x00	; 0
     332:	8f 5f       	subi	r24, 0xFF	; 255
     334:	0e 94 42 02 	call	0x484	; 0x484 <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
     338:	11 30       	cpi	r17, 0x01	; 1
     33a:	79 f4       	brne	.+30     	; 0x35a <vComRxTask+0x6e>
		{
			while( cByteRxed != comLAST_BYTE )
     33c:	89 81       	ldd	r24, Y+1	; 0x01
     33e:	88 35       	cpi	r24, 0x58	; 88
     340:	51 f0       	breq	.+20     	; 0x356 <vComRxTask+0x6a>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
     342:	4f ef       	ldi	r20, 0xFF	; 255
     344:	5f ef       	ldi	r21, 0xFF	; 255
     346:	be 01       	movw	r22, r28
     348:	6f 5f       	subi	r22, 0xFF	; 255
     34a:	7f 4f       	sbci	r23, 0xFF	; 255
     34c:	80 e0       	ldi	r24, 0x00	; 0
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <xSerialGetChar>
     354:	f3 cf       	rjmp	.-26     	; 0x33c <vComRxTask+0x50>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
     356:	0f 5f       	subi	r16, 0xFF	; 255
     358:	cf cf       	rjmp	.-98     	; 0x2f8 <vComRxTask+0xc>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
     35a:	02 30       	cpi	r16, 0x02	; 2
     35c:	6c f6       	brge	.-102    	; 0x2f8 <vComRxTask+0xc>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
     35e:	80 91 d4 08 	lds	r24, 0x08D4	; 0x8008d4 <uxRxLoops>
     362:	8f 5f       	subi	r24, 0xFF	; 255
     364:	80 93 d4 08 	sts	0x08D4, r24	; 0x8008d4 <uxRxLoops>
     368:	c7 cf       	rjmp	.-114    	; 0x2f8 <vComRxTask+0xc>

0000036a <vComTxTask>:
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
     36a:	06 e9       	ldi	r16, 0x96	; 150
     36c:	10 e0       	ldi	r17, 0x00	; 0

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
     36e:	c1 e4       	ldi	r28, 0x41	; 65
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
     370:	40 e0       	ldi	r20, 0x00	; 0
     372:	50 e0       	ldi	r21, 0x00	; 0
     374:	6c 2f       	mov	r22, r28
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	0e 94 df 02 	call	0x5be	; 0x5be <xSerialPutChar>
     37e:	81 30       	cpi	r24, 0x01	; 1
     380:	21 f4       	brne	.+8      	; 0x38a <vComTxTask+0x20>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
     382:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <uxBaseLED>
     386:	0e 94 66 02 	call	0x4cc	; 0x4cc <vParTestToggleLED>
     38a:	cf 5f       	subi	r28, 0xFF	; 255

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
     38c:	c9 35       	cpi	r28, 0x59	; 89
     38e:	81 f7       	brne	.-32     	; 0x370 <vComTxTask+0x6>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
     390:	60 e0       	ldi	r22, 0x00	; 0
     392:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <uxBaseLED>
     396:	0e 94 42 02 	call	0x484	; 0x484 <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
     39a:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <xTaskGetTickCount>
     39e:	03 96       	adiw	r24, 0x03	; 3

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
     3a0:	b8 01       	movw	r22, r16
     3a2:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__udivmodhi4>

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
     3a6:	82 33       	cpi	r24, 0x32	; 50
     3a8:	91 05       	cpc	r25, r1
     3aa:	10 f4       	brcc	.+4      	; 0x3b0 <vComTxTask+0x46>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
     3ac:	82 e3       	ldi	r24, 0x32	; 50
     3ae:	90 e0       	ldi	r25, 0x00	; 0
		}

		vTaskDelay( xTimeToWait );
     3b0:	0e 94 4f 08 	call	0x109e	; 0x109e <vTaskDelay>
	}
     3b4:	dc cf       	rjmp	.-72     	; 0x36e <vComTxTask+0x4>

000003b6 <__ctors_end>:
     3b6:	11 24       	eor	r1, r1
     3b8:	1f be       	out	0x3f, r1	; 63
     3ba:	cf ef       	ldi	r28, 0xFF	; 255
     3bc:	d1 e2       	ldi	r29, 0x21	; 33
     3be:	de bf       	out	0x3e, r29	; 62
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	00 e0       	ldi	r16, 0x00	; 0
     3c4:	0c bf       	out	0x3c, r16	; 60

000003c6 <__do_copy_data>:
     3c6:	12 e0       	ldi	r17, 0x02	; 2
     3c8:	a0 e0       	ldi	r26, 0x00	; 0
     3ca:	b2 e0       	ldi	r27, 0x02	; 2
     3cc:	e6 e6       	ldi	r30, 0x66	; 102
     3ce:	fe e2       	ldi	r31, 0x2E	; 46
     3d0:	00 e0       	ldi	r16, 0x00	; 0
     3d2:	0b bf       	out	0x3b, r16	; 59
     3d4:	02 c0       	rjmp	.+4      	; 0x3da <__do_copy_data+0x14>
     3d6:	07 90       	elpm	r0, Z+
     3d8:	0d 92       	st	X+, r0
     3da:	a0 35       	cpi	r26, 0x50	; 80
     3dc:	b1 07       	cpc	r27, r17
     3de:	d9 f7       	brne	.-10     	; 0x3d6 <__do_copy_data+0x10>

000003e0 <__do_clear_bss>:
     3e0:	28 e0       	ldi	r18, 0x08	; 8
     3e2:	a0 e5       	ldi	r26, 0x50	; 80
     3e4:	b2 e0       	ldi	r27, 0x02	; 2
     3e6:	01 c0       	rjmp	.+2      	; 0x3ea <.do_clear_bss_start>

000003e8 <.do_clear_bss_loop>:
     3e8:	1d 92       	st	X+, r1

000003ea <.do_clear_bss_start>:
     3ea:	ae 3d       	cpi	r26, 0xDE	; 222
     3ec:	b2 07       	cpc	r27, r18
     3ee:	e1 f7       	brne	.-8      	; 0x3e8 <.do_clear_bss_loop>
     3f0:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <main>
     3f4:	0c 94 31 17 	jmp	0x2e62	; 0x2e62 <_exit>

000003f8 <__bad_interrupt>:
     3f8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003fc <vErrorChecks>:
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
     3fc:	c1 e0       	ldi	r28, 0x01	; 1

	/* Cycle for ever, delaying then checking all the other tasks are still
	operating without error. */
	for( ;; )
	{
		vTaskDelay( mainCHECK_PERIOD );
     3fe:	88 eb       	ldi	r24, 0xB8	; 184
     400:	9b e0       	ldi	r25, 0x0B	; 11
     402:	0e 94 4f 08 	call	0x109e	; 0x109e <vTaskDelay>

		/* Perform a bit of 32bit maths to ensure the registers used by the
		integer tasks get some exercise. The result here is not important -
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;
     406:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
     40a:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
     40e:	40 91 02 02 	lds	r20, 0x0202	; 0x800202 <__data_start+0x2>
     412:	50 91 03 02 	lds	r21, 0x0203	; 0x800203 <__data_start+0x3>
     416:	a3 e0       	ldi	r26, 0x03	; 3
     418:	b0 e0       	ldi	r27, 0x00	; 0
     41a:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__muluhisi3>
     41e:	60 93 00 02 	sts	0x0200, r22	; 0x800200 <__data_start>
     422:	70 93 01 02 	sts	0x0201, r23	; 0x800201 <__data_start+0x1>
     426:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <__data_start+0x2>
     42a:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <__data_start+0x3>

static void prvCheckOtherTasksAreStillRunning( void )
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
     42e:	0e 94 de 14 	call	0x29bc	; 0x29bc <xAreIntegerMathsTaskStillRunning>
     432:	81 30       	cpi	r24, 0x01	; 1
     434:	11 f0       	breq	.+4      	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
	{
		xErrorHasOccurred = pdTRUE;
     436:	c0 93 50 02 	sts	0x0250, r28	; 0x800250 <__data_end>
	}

	if( xAreComTestTasksStillRunning() != pdTRUE )
     43a:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <xAreComTestTasksStillRunning>
     43e:	81 30       	cpi	r24, 0x01	; 1
     440:	11 f0       	breq	.+4      	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
	{
		xErrorHasOccurred = pdTRUE;
     442:	c0 93 50 02 	sts	0x0250, r28	; 0x800250 <__data_end>
	}

	if( xArePollingQueuesStillRunning() != pdTRUE )
     446:	0e 94 13 15 	call	0x2a26	; 0x2a26 <xArePollingQueuesStillRunning>
     44a:	81 30       	cpi	r24, 0x01	; 1
     44c:	11 f0       	breq	.+4      	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
	{
		xErrorHasOccurred = pdTRUE;
     44e:	c0 93 50 02 	sts	0x0250, r28	; 0x800250 <__data_end>
	}

	if( xAreRegTestTasksStillRunning() != pdTRUE )
     452:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xAreRegTestTasksStillRunning>
     456:	81 30       	cpi	r24, 0x01	; 1
     458:	11 f0       	breq	.+4      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
	{
		xErrorHasOccurred = pdTRUE;
     45a:	c0 93 50 02 	sts	0x0250, r28	; 0x800250 <__data_end>
	}

	if( xErrorHasOccurred == pdFALSE )
     45e:	80 91 50 02 	lds	r24, 0x0250	; 0x800250 <__data_end>
     462:	81 11       	cpse	r24, r1
     464:	cc cf       	rjmp	.-104    	; 0x3fe <vErrorChecks+0x2>
	{
		/* Toggle the LED if everything is okay so we know if an error occurs even if not
		using console IO. */
		vParTestToggleLED( mainCHECK_TASK_LED );
     466:	87 e0       	ldi	r24, 0x07	; 7
     468:	0e 94 66 02 	call	0x4cc	; 0x4cc <vParTestToggleLED>
     46c:	c8 cf       	rjmp	.-112    	; 0x3fe <vErrorChecks+0x2>

0000046e <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	vCoRoutineSchedule();
     46e:	0c 94 ee 11 	jmp	0x23dc	; 0x23dc <vCoRoutineSchedule>

00000472 <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     472:	8f ef       	ldi	r24, 0xFF	; 255
     474:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <ucCurrentOutputValue>

	/* Set port L direction to outputs.  Start with all output off. */
	DDRL = partstALL_BITS_OUTPUT;
     478:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__TEXT_REGION_LENGTH__+0x70010a>
	PORTL = 0x5a; //ucCurrentOutputValue;
     47c:	8a e5       	ldi	r24, 0x5A	; 90
     47e:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <__TEXT_REGION_LENGTH__+0x70010b>
     482:	08 95       	ret

00000484 <vParTestSetLED>:
}
/*-----------------------------------------------------------*/

void vParTestSetLED(portBASE_TYPE uxLED, portBASE_TYPE xValue )
{
     484:	1f 93       	push	r17
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     48a:	88 30       	cpi	r24, 0x08	; 8
     48c:	d8 f4       	brcc	.+54     	; 0x4c4 <vParTestSetLED+0x40>
     48e:	16 2f       	mov	r17, r22
	{
		ucBit <<= uxLED;	
     490:	c1 e0       	ldi	r28, 0x01	; 1
     492:	d0 e0       	ldi	r29, 0x00	; 0
     494:	01 c0       	rjmp	.+2      	; 0x498 <vParTestSetLED+0x14>
     496:	cc 0f       	add	r28, r28
     498:	8a 95       	dec	r24
     49a:	ea f7       	brpl	.-6      	; 0x496 <vParTestSetLED+0x12>

		vTaskSuspendAll();
     49c:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     4a0:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <ucCurrentOutputValue>
	{
		ucBit <<= uxLED;	

		vTaskSuspendAll();
		{
			if( xValue == pdTRUE )
     4a4:	11 30       	cpi	r17, 0x01	; 1
     4a6:	19 f4       	brne	.+6      	; 0x4ae <vParTestSetLED+0x2a>
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     4a8:	c0 95       	com	r28
     4aa:	c8 23       	and	r28, r24
     4ac:	01 c0       	rjmp	.+2      	; 0x4b0 <vParTestSetLED+0x2c>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     4ae:	c8 2b       	or	r28, r24
     4b0:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <ucCurrentOutputValue>
			}

			PORTB = ucCurrentOutputValue;
     4b4:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <ucCurrentOutputValue>
     4b8:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();
	}
}
     4ba:	df 91       	pop	r29
     4bc:	cf 91       	pop	r28
     4be:	1f 91       	pop	r17
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();
     4c0:	0c 94 a9 07 	jmp	0xf52	; 0xf52 <xTaskResumeAll>
	}
}
     4c4:	df 91       	pop	r29
     4c6:	cf 91       	pop	r28
     4c8:	1f 91       	pop	r17
     4ca:	08 95       	ret

000004cc <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( portBASE_TYPE uxLED )
{
     4cc:	cf 93       	push	r28
     4ce:	df 93       	push	r29
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     4d0:	88 30       	cpi	r24, 0x08	; 8
     4d2:	e8 f4       	brcc	.+58     	; 0x50e <vParTestToggleLED+0x42>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     4d4:	c1 e0       	ldi	r28, 0x01	; 1
     4d6:	d0 e0       	ldi	r29, 0x00	; 0
     4d8:	01 c0       	rjmp	.+2      	; 0x4dc <vParTestToggleLED+0x10>
     4da:	cc 0f       	add	r28, r28
     4dc:	8a 95       	dec	r24
     4de:	ea f7       	brpl	.-6      	; 0x4da <vParTestToggleLED+0xe>

		vTaskSuspendAll();
     4e0:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     4e4:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <ucCurrentOutputValue>
     4e8:	8c 23       	and	r24, r28
     4ea:	29 f0       	breq	.+10     	; 0x4f6 <vParTestToggleLED+0x2a>
			{
				ucCurrentOutputValue &= ~ucBit;
     4ec:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <ucCurrentOutputValue>
     4f0:	c0 95       	com	r28
     4f2:	c8 23       	and	r28, r24
     4f4:	03 c0       	rjmp	.+6      	; 0x4fc <vParTestToggleLED+0x30>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     4f6:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <ucCurrentOutputValue>
     4fa:	c8 2b       	or	r28, r24
     4fc:	c0 93 04 02 	sts	0x0204, r28	; 0x800204 <ucCurrentOutputValue>
			}

			PORTB = ucCurrentOutputValue;
     500:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <ucCurrentOutputValue>
     504:	85 b9       	out	0x05, r24	; 5
		}
		xTaskResumeAll();			
	}
}
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
				ucCurrentOutputValue |= ucBit;
			}

			PORTB = ucCurrentOutputValue;
		}
		xTaskResumeAll();			
     50a:	0c 94 a9 07 	jmp	0xf52	; 0xf52 <xTaskResumeAll>
	}
}
     50e:	df 91       	pop	r29
     510:	cf 91       	pop	r28
     512:	08 95       	ret

00000514 <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, portBASE_TYPE uxQueueLength )
{
     514:	cf 92       	push	r12
     516:	df 92       	push	r13
     518:	ef 92       	push	r14
     51a:	ff 92       	push	r15
     51c:	cf 93       	push	r28
     51e:	6b 01       	movw	r12, r22
     520:	7c 01       	movw	r14, r24
     522:	c4 2f       	mov	r28, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     524:	0f b6       	in	r0, 0x3f	; 63
     526:	f8 94       	cli
     528:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( portBASE_TYPE ) sizeof( signed char ) );
     52a:	40 e0       	ldi	r20, 0x00	; 0
     52c:	61 e0       	ldi	r22, 0x01	; 1
     52e:	8c 2f       	mov	r24, r28
     530:	0e 94 a9 0c 	call	0x1952	; 0x1952 <xQueueGenericCreate>
     534:	90 93 54 02 	sts	0x0254, r25	; 0x800254 <xRxedChars+0x1>
     538:	80 93 53 02 	sts	0x0253, r24	; 0x800253 <xRxedChars>
		xCharsForTx = xQueueCreate( uxQueueLength, ( portBASE_TYPE ) sizeof( signed char ) );
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	61 e0       	ldi	r22, 0x01	; 1
     540:	8c 2f       	mov	r24, r28
     542:	0e 94 a9 0c 	call	0x1952	; 0x1952 <xQueueGenericCreate>
     546:	90 93 52 02 	sts	0x0252, r25	; 0x800252 <xCharsForTx+0x1>
     54a:	80 93 51 02 	sts	0x0251, r24	; 0x800251 <xCharsForTx>

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     54e:	a7 01       	movw	r20, r14
     550:	96 01       	movw	r18, r12
     552:	84 e0       	ldi	r24, 0x04	; 4
     554:	22 0f       	add	r18, r18
     556:	33 1f       	adc	r19, r19
     558:	44 1f       	adc	r20, r20
     55a:	55 1f       	adc	r21, r21
     55c:	8a 95       	dec	r24
     55e:	d1 f7       	brne	.-12     	; 0x554 <xSerialPortInitMinimal+0x40>
     560:	60 e0       	ldi	r22, 0x00	; 0
     562:	74 e2       	ldi	r23, 0x24	; 36
     564:	84 ef       	ldi	r24, 0xF4	; 244
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	0e 94 a7 16 	call	0x2d4e	; 0x2d4e <__udivmodsi4>
     56c:	da 01       	movw	r26, r20
     56e:	c9 01       	movw	r24, r18
     570:	01 97       	sbiw	r24, 0x01	; 1
     572:	a1 09       	sbc	r26, r1
     574:	b1 09       	sbc	r27, r1

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
     576:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>

		ulBaudRateCounter >>= ( unsigned long ) 8;
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     57a:	89 2f       	mov	r24, r25
     57c:	9a 2f       	mov	r25, r26
     57e:	ab 2f       	mov	r26, r27
     580:	bb 27       	eor	r27, r27
		UBRR0H = ucByte;
     582:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     586:	88 e9       	ldi	r24, 0x98	; 152
     588:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
     58c:	86 e8       	ldi	r24, 0x86	; 134
     58e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	}
	portEXIT_CRITICAL();
     592:	0f 90       	pop	r0
     594:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     596:	80 e0       	ldi	r24, 0x00	; 0
     598:	90 e0       	ldi	r25, 0x00	; 0
     59a:	cf 91       	pop	r28
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	08 95       	ret

000005a6 <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     5a6:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <xRxedChars>
     5aa:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <xRxedChars+0x1>
     5ae:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <xQueueReceive>
     5b2:	91 e0       	ldi	r25, 0x01	; 1
     5b4:	81 11       	cpse	r24, r1
     5b6:	01 c0       	rjmp	.+2      	; 0x5ba <xSerialGetChar+0x14>
     5b8:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return pdFALSE;
	}
}
     5ba:	89 2f       	mov	r24, r25
     5bc:	08 95       	ret

000005be <xSerialPutChar>:
/*-----------------------------------------------------------*/

portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	1f 92       	push	r1
     5c4:	cd b7       	in	r28, 0x3d	; 61
     5c6:	de b7       	in	r29, 0x3e	; 62
     5c8:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     5ca:	20 e0       	ldi	r18, 0x00	; 0
     5cc:	be 01       	movw	r22, r28
     5ce:	6f 5f       	subi	r22, 0xFF	; 255
     5d0:	7f 4f       	sbci	r23, 0xFF	; 255
     5d2:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <xCharsForTx>
     5d6:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <xCharsForTx+0x1>
     5da:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <xQueueGenericSend>
     5de:	81 30       	cpi	r24, 0x01	; 1
     5e0:	39 f4       	brne	.+14     	; 0x5f0 <xSerialPutChar+0x32>
	{
		return pdFAIL;
	}

	vInterruptOn();
     5e2:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     5e6:	80 62       	ori	r24, 0x20	; 32
     5e8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>

	return pdPASS;
     5ec:	81 e0       	ldi	r24, 0x01	; 1
     5ee:	01 c0       	rjmp	.+2      	; 0x5f2 <xSerialPutChar+0x34>
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
	{
		return pdFAIL;
     5f0:	80 e0       	ldi	r24, 0x00	; 0
	}

	vInterruptOn();

	return pdPASS;
}
     5f2:	0f 90       	pop	r0
     5f4:	df 91       	pop	r29
     5f6:	cf 91       	pop	r28
     5f8:	08 95       	ret

000005fa <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     5fa:	0f b6       	in	r0, 0x3f	; 63
     5fc:	f8 94       	cli
     5fe:	0f 92       	push	r0
	{
		vInterruptOff();
     600:	e1 ec       	ldi	r30, 0xC1	; 193
     602:	f0 e0       	ldi	r31, 0x00	; 0
     604:	80 81       	ld	r24, Z
     606:	8f 7d       	andi	r24, 0xDF	; 223
     608:	80 83       	st	Z, r24
		ucByte = UCSR0B;
     60a:	80 81       	ld	r24, Z
		ucByte &= ~serRX_INT_ENABLE;
     60c:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
     60e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     610:	0f 90       	pop	r0
     612:	0f be       	out	0x3f, r0	; 63
     614:	08 95       	ret

00000616 <__vector_25>:
}
/*-----------------------------------------------------------*/

SIGNAL( USART0_RX_vect )
{
     616:	1f 92       	push	r1
     618:	0f 92       	push	r0
     61a:	0f b6       	in	r0, 0x3f	; 63
     61c:	0f 92       	push	r0
     61e:	11 24       	eor	r1, r1
     620:	0b b6       	in	r0, 0x3b	; 59
     622:	0f 92       	push	r0
     624:	2f 93       	push	r18
     626:	3f 93       	push	r19
     628:	4f 93       	push	r20
     62a:	5f 93       	push	r21
     62c:	6f 93       	push	r22
     62e:	7f 93       	push	r23
     630:	8f 93       	push	r24
     632:	9f 93       	push	r25
     634:	af 93       	push	r26
     636:	bf 93       	push	r27
     638:	ef 93       	push	r30
     63a:	ff 93       	push	r31
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
     640:	1f 92       	push	r1
     642:	1f 92       	push	r1
     644:	cd b7       	in	r28, 0x3d	; 61
     646:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     648:	19 82       	std	Y+1, r1	; 0x01

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     64a:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     64e:	8a 83       	std	Y+2, r24	; 0x02

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     650:	20 e0       	ldi	r18, 0x00	; 0
     652:	ae 01       	movw	r20, r28
     654:	4f 5f       	subi	r20, 0xFF	; 255
     656:	5f 4f       	sbci	r21, 0xFF	; 255
     658:	be 01       	movw	r22, r28
     65a:	6e 5f       	subi	r22, 0xFE	; 254
     65c:	7f 4f       	sbci	r23, 0xFF	; 255
     65e:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <xRxedChars>
     662:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <xRxedChars+0x1>
     666:	0e 94 67 0d 	call	0x1ace	; 0x1ace <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     66a:	89 81       	ldd	r24, Y+1	; 0x01
     66c:	81 11       	cpse	r24, r1
	{
		taskYIELD();
     66e:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
	}
}
     672:	0f 90       	pop	r0
     674:	0f 90       	pop	r0
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	ff 91       	pop	r31
     67c:	ef 91       	pop	r30
     67e:	bf 91       	pop	r27
     680:	af 91       	pop	r26
     682:	9f 91       	pop	r25
     684:	8f 91       	pop	r24
     686:	7f 91       	pop	r23
     688:	6f 91       	pop	r22
     68a:	5f 91       	pop	r21
     68c:	4f 91       	pop	r20
     68e:	3f 91       	pop	r19
     690:	2f 91       	pop	r18
     692:	0f 90       	pop	r0
     694:	0b be       	out	0x3b, r0	; 59
     696:	0f 90       	pop	r0
     698:	0f be       	out	0x3f, r0	; 63
     69a:	0f 90       	pop	r0
     69c:	1f 90       	pop	r1
     69e:	18 95       	reti

000006a0 <__vector_26>:
/*-----------------------------------------------------------*/

SIGNAL( USART0_UDRE_vect )
{
     6a0:	1f 92       	push	r1
     6a2:	0f 92       	push	r0
     6a4:	0f b6       	in	r0, 0x3f	; 63
     6a6:	0f 92       	push	r0
     6a8:	11 24       	eor	r1, r1
     6aa:	0b b6       	in	r0, 0x3b	; 59
     6ac:	0f 92       	push	r0
     6ae:	2f 93       	push	r18
     6b0:	3f 93       	push	r19
     6b2:	4f 93       	push	r20
     6b4:	5f 93       	push	r21
     6b6:	6f 93       	push	r22
     6b8:	7f 93       	push	r23
     6ba:	8f 93       	push	r24
     6bc:	9f 93       	push	r25
     6be:	af 93       	push	r26
     6c0:	bf 93       	push	r27
     6c2:	ef 93       	push	r30
     6c4:	ff 93       	push	r31
     6c6:	cf 93       	push	r28
     6c8:	df 93       	push	r29
     6ca:	1f 92       	push	r1
     6cc:	1f 92       	push	r1
     6ce:	cd b7       	in	r28, 0x3d	; 61
     6d0:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     6d2:	ae 01       	movw	r20, r28
     6d4:	4f 5f       	subi	r20, 0xFF	; 255
     6d6:	5f 4f       	sbci	r21, 0xFF	; 255
     6d8:	be 01       	movw	r22, r28
     6da:	6e 5f       	subi	r22, 0xFE	; 254
     6dc:	7f 4f       	sbci	r23, 0xFF	; 255
     6de:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <xCharsForTx>
     6e2:	90 91 52 02 	lds	r25, 0x0252	; 0x800252 <xCharsForTx+0x1>
     6e6:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <xQueueReceiveFromISR>
     6ea:	81 30       	cpi	r24, 0x01	; 1
     6ec:	21 f4       	brne	.+8      	; 0x6f6 <__vector_26+0x56>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     6ee:	8a 81       	ldd	r24, Y+2	; 0x02
     6f0:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     6f4:	05 c0       	rjmp	.+10     	; 0x700 <__vector_26+0x60>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     6f6:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     6fa:	8f 7d       	andi	r24, 0xDF	; 223
     6fc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	}
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	df 91       	pop	r29
     706:	cf 91       	pop	r28
     708:	ff 91       	pop	r31
     70a:	ef 91       	pop	r30
     70c:	bf 91       	pop	r27
     70e:	af 91       	pop	r26
     710:	9f 91       	pop	r25
     712:	8f 91       	pop	r24
     714:	7f 91       	pop	r23
     716:	6f 91       	pop	r22
     718:	5f 91       	pop	r21
     71a:	4f 91       	pop	r20
     71c:	3f 91       	pop	r19
     71e:	2f 91       	pop	r18
     720:	0f 90       	pop	r0
     722:	0b be       	out	0x3b, r0	; 59
     724:	0f 90       	pop	r0
     726:	0f be       	out	0x3f, r0	; 63
     728:	0f 90       	pop	r0
     72a:	1f 90       	pop	r1
     72c:	18 95       	reti

0000072e <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     72e:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     730:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     732:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     734:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     736:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     738:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     73a:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     73c:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     73e:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     740:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     742:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     744:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     746:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     748:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     74a:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     74c:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     74e:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     750:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     752:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     754:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     756:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     758:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     75a:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     75c:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     75e:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     760:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     762:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     764:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     766:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     768:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     76a:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     76c:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     76e:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     770:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     772:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     774:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     776:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     778:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     77a:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     77c:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     77e:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     780:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     782:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     784:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     786:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     788:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     78a:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     78c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	6"			);
     790:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     792:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     794:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	7"			);
     798:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     79a:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     79c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	8"			);
     7a0:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     7a2:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     7a4:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	9"			);
     7a8:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     7aa:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     7ac:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	10"			);
     7b0:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     7b2:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     7b4:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	11"			);
     7b8:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     7ba:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     7bc:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	12"			);
     7c0:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     7c2:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     7c4:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	13"			);
     7c8:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     7ca:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     7cc:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	14"			);
     7d0:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     7d2:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     7d4:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	15"			);
     7d8:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     7da:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     7dc:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	16"			);
     7e0:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     7e2:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     7e4:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	17"			);
     7e8:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     7ea:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     7ec:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	18"			);
     7f0:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     7f2:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     7f4:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	19"			);
     7f8:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     7fa:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     7fc:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	20"			);
     800:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     802:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     804:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	21"			);
     808:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     80a:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     80c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	22"			);
     810:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     812:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     814:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	23"			);
     818:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     81a:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     81c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	24"			);
     820:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     822:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     824:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	25"			);
     828:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     82a:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     82c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	26"			);
     830:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     832:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     834:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	27"			);
     838:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     83a:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     83c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	28"			);
     840:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     842:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     844:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	29"			);
     848:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     84a:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     84c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	30"			);
     850:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     852:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     854:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	31"			);
     858:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     85a:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     85c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	32"			);
     860:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     862:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     864:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	33"			);
     868:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     86a:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     86c:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
     870:	5e cf       	rjmp	.-324    	; 0x72e <prvRegisterCheck1>

00000872 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     872:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     874:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     876:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     878:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     87a:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     87c:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     87e:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     880:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     882:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     884:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     886:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     888:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     88a:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     88c:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     88e:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     890:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     892:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     894:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     896:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     898:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     89a:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     89c:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     89e:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     8a0:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     8a2:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     8a4:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     8a6:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     8a8:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     8aa:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     8ac:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     8ae:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     8b0:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     8b2:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     8b4:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     8b6:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     8b8:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     8ba:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     8bc:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     8be:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     8c0:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     8c2:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     8c4:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     8c6:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     8c8:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     8ca:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     8cc:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     8ce:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     8d0:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	2"			);
     8d4:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     8d6:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     8d8:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	3"			);
     8dc:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     8de:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     8e0:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	4"			);
     8e4:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     8e6:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     8e8:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	5"			);
     8ec:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     8ee:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     8f0:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	6"			);
     8f4:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     8f6:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     8f8:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	7"			);
     8fc:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     8fe:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     900:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	8"			);
     904:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     906:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     908:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	9"			);
     90c:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     90e:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     910:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	10"			);
     914:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     916:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     918:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	11"			);
     91c:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     91e:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     920:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	12"			);
     924:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     926:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     928:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	13"			);
     92c:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     92e:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     930:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	14"			);
     934:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     936:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     938:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	15"			);
     93c:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     93e:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     940:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	16"			);
     944:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     946:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     948:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	17"			);
     94c:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     94e:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     950:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	18"			);
     954:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     956:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     958:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	19"			);
     95c:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     95e:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     960:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	20"			);
     964:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     966:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     968:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	21"			);
     96c:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     96e:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     970:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	22"			);
     974:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     976:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     978:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	23"			);
     97c:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     97e:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     980:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	24"			);
     984:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     986:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     988:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	25"			);
     98c:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     98e:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     990:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	26"			);
     994:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     996:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     998:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	27"			);
     99c:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     99e:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     9a0:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	28"			);
     9a4:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     9a6:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     9a8:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
		asm(	"LDI	r31,	29"			);
     9ac:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     9ae:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     9b0:	00 92 55 02 	sts	0x0255, r0	; 0x800255 <xRegTestError>
     9b4:	5e cf       	rjmp	.-324    	; 0x872 <prvRegisterCheck2>

000009b6 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     9b6:	ef 92       	push	r14
     9b8:	ff 92       	push	r15
     9ba:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     9bc:	e1 2c       	mov	r14, r1
     9be:	f1 2c       	mov	r15, r1
     9c0:	00 e0       	ldi	r16, 0x00	; 0
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	45 e5       	ldi	r20, 0x55	; 85
     9c8:	50 e0       	ldi	r21, 0x00	; 0
     9ca:	6c e1       	ldi	r22, 0x1C	; 28
     9cc:	72 e0       	ldi	r23, 0x02	; 2
     9ce:	87 e9       	ldi	r24, 0x97	; 151
     9d0:	93 e0       	ldi	r25, 0x03	; 3
     9d2:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     9d6:	20 e0       	ldi	r18, 0x00	; 0
     9d8:	30 e0       	ldi	r19, 0x00	; 0
     9da:	45 e5       	ldi	r20, 0x55	; 85
     9dc:	50 e0       	ldi	r21, 0x00	; 0
     9de:	61 e2       	ldi	r22, 0x21	; 33
     9e0:	72 e0       	ldi	r23, 0x02	; 2
     9e2:	89 e3       	ldi	r24, 0x39	; 57
     9e4:	94 e0       	ldi	r25, 0x04	; 4
     9e6:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>
}
     9ea:	0f 91       	pop	r16
     9ec:	ff 90       	pop	r15
     9ee:	ef 90       	pop	r14
     9f0:	08 95       	ret

000009f2 <xAreRegTestTasksStillRunning>:
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
     9f2:	81 e0       	ldi	r24, 0x01	; 1
     9f4:	90 91 55 02 	lds	r25, 0x0255	; 0x800255 <xRegTestError>
     9f8:	91 11       	cpse	r25, r1
     9fa:	80 e0       	ldi	r24, 0x00	; 0
}
     9fc:	08 95       	ret

000009fe <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     9fe:	e0 91 7b 02 	lds	r30, 0x027B	; 0x80027b <pxDelayedTaskList>
     a02:	f0 91 7c 02 	lds	r31, 0x027C	; 0x80027c <pxDelayedTaskList+0x1>
     a06:	80 81       	ld	r24, Z
     a08:	81 11       	cpse	r24, r1
     a0a:	03 c0       	rjmp	.+6      	; 0xa12 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     a0c:	8f ef       	ldi	r24, 0xFF	; 255
     a0e:	9f ef       	ldi	r25, 0xFF	; 255
     a10:	0c c0       	rjmp	.+24     	; 0xa2a <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a12:	e0 91 7b 02 	lds	r30, 0x027B	; 0x80027b <pxDelayedTaskList>
     a16:	f0 91 7c 02 	lds	r31, 0x027C	; 0x80027c <pxDelayedTaskList+0x1>
     a1a:	05 80       	ldd	r0, Z+5	; 0x05
     a1c:	f6 81       	ldd	r31, Z+6	; 0x06
     a1e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     a20:	06 80       	ldd	r0, Z+6	; 0x06
     a22:	f7 81       	ldd	r31, Z+7	; 0x07
     a24:	e0 2d       	mov	r30, r0
     a26:	82 81       	ldd	r24, Z+2	; 0x02
     a28:	93 81       	ldd	r25, Z+3	; 0x03
     a2a:	90 93 5c 02 	sts	0x025C, r25	; 0x80025c <xNextTaskUnblockTime+0x1>
     a2e:	80 93 5b 02 	sts	0x025B, r24	; 0x80025b <xNextTaskUnblockTime>
     a32:	08 95       	ret

00000a34 <prvAddCurrentTaskToDelayedList.isra.2>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
     a34:	0f 93       	push	r16
     a36:	1f 93       	push	r17
     a38:	cf 93       	push	r28
     a3a:	df 93       	push	r29
     a3c:	ec 01       	movw	r28, r24
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     a3e:	00 91 63 02 	lds	r16, 0x0263	; 0x800263 <xTickCount>
     a42:	10 91 64 02 	lds	r17, 0x0264	; 0x800264 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     a46:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTCB>
     a4a:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     a4e:	02 96       	adiw	r24, 0x02	; 2
     a50:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
     a54:	c0 0f       	add	r28, r16
     a56:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     a58:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
     a5c:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     a60:	d3 83       	std	Z+3, r29	; 0x03
     a62:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     a64:	60 91 56 02 	lds	r22, 0x0256	; 0x800256 <pxCurrentTCB>
     a68:	70 91 57 02 	lds	r23, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
		xTimeToWake = xConstTickCount + xTicksToWait;

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
     a6c:	c0 17       	cp	r28, r16
     a6e:	d1 07       	cpc	r29, r17
     a70:	60 f4       	brcc	.+24     	; 0xa8a <prvAddCurrentTaskToDelayedList.isra.2+0x56>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     a72:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <pxOverflowDelayedTaskList>
     a76:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <pxOverflowDelayedTaskList+0x1>
     a7a:	6e 5f       	subi	r22, 0xFE	; 254
     a7c:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     a7e:	df 91       	pop	r29
     a80:	cf 91       	pop	r28
     a82:	1f 91       	pop	r17
     a84:	0f 91       	pop	r16
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

		if( xTimeToWake < xConstTickCount )
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     a86:	0c 94 de 10 	jmp	0x21bc	; 0x21bc <vListInsert>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     a8a:	80 91 7b 02 	lds	r24, 0x027B	; 0x80027b <pxDelayedTaskList>
     a8e:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <pxDelayedTaskList+0x1>
     a92:	6e 5f       	subi	r22, 0xFE	; 254
     a94:	7f 4f       	sbci	r23, 0xFF	; 255
     a96:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
     a9a:	80 91 5b 02 	lds	r24, 0x025B	; 0x80025b <xNextTaskUnblockTime>
     a9e:	90 91 5c 02 	lds	r25, 0x025C	; 0x80025c <xNextTaskUnblockTime+0x1>
     aa2:	c8 17       	cp	r28, r24
     aa4:	d9 07       	cpc	r29, r25
     aa6:	20 f4       	brcc	.+8      	; 0xab0 <prvAddCurrentTaskToDelayedList.isra.2+0x7c>
			{
				xNextTaskUnblockTime = xTimeToWake;
     aa8:	d0 93 5c 02 	sts	0x025C, r29	; 0x80025c <xNextTaskUnblockTime+0x1>
     aac:	c0 93 5b 02 	sts	0x025B, r28	; 0x80025b <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     ab0:	df 91       	pop	r29
     ab2:	cf 91       	pop	r28
     ab4:	1f 91       	pop	r17
     ab6:	0f 91       	pop	r16
     ab8:	08 95       	ret

00000aba <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     aba:	3f 92       	push	r3
     abc:	4f 92       	push	r4
     abe:	5f 92       	push	r5
     ac0:	6f 92       	push	r6
     ac2:	7f 92       	push	r7
     ac4:	8f 92       	push	r8
     ac6:	9f 92       	push	r9
     ac8:	af 92       	push	r10
     aca:	bf 92       	push	r11
     acc:	cf 92       	push	r12
     ace:	df 92       	push	r13
     ad0:	ef 92       	push	r14
     ad2:	ff 92       	push	r15
     ad4:	0f 93       	push	r16
     ad6:	1f 93       	push	r17
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
     adc:	4c 01       	movw	r8, r24
     ade:	16 2f       	mov	r17, r22
     ae0:	37 2e       	mov	r3, r23
     ae2:	6a 01       	movw	r12, r20
     ae4:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     ae6:	ca 01       	movw	r24, r20
     ae8:	0e 94 00 13 	call	0x2600	; 0x2600 <pvPortMalloc>
     aec:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     aee:	89 2b       	or	r24, r25
     af0:	09 f4       	brne	.+2      	; 0xaf4 <xTaskCreate+0x3a>
     af2:	cc c0       	rjmp	.+408    	; 0xc8c <xTaskCreate+0x1d2>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     af4:	86 e2       	ldi	r24, 0x26	; 38
     af6:	90 e0       	ldi	r25, 0x00	; 0
     af8:	0e 94 00 13 	call	0x2600	; 0x2600 <pvPortMalloc>
     afc:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     afe:	89 2b       	or	r24, r25
     b00:	79 f0       	breq	.+30     	; 0xb20 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     b02:	58 8e       	std	Y+24, r5	; 0x18
     b04:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     b06:	c6 01       	movw	r24, r12
     b08:	01 97       	sbiw	r24, 0x01	; 1
     b0a:	32 01       	movw	r6, r4
     b0c:	68 0e       	add	r6, r24
     b0e:	79 1e       	adc	r7, r25
     b10:	be 01       	movw	r22, r28
     b12:	67 5e       	subi	r22, 0xE7	; 231
     b14:	7f 4f       	sbci	r23, 0xFF	; 255
     b16:	e1 2f       	mov	r30, r17
     b18:	f3 2d       	mov	r31, r3
     b1a:	cf 01       	movw	r24, r30
     b1c:	08 96       	adiw	r24, 0x08	; 8
     b1e:	07 c0       	rjmp	.+14     	; 0xb2e <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     b20:	c2 01       	movw	r24, r4
     b22:	0e 94 32 13 	call	0x2664	; 0x2664 <vPortFree>
     b26:	b2 c0       	rjmp	.+356    	; 0xc8c <xTaskCreate+0x1d2>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     b28:	e8 17       	cp	r30, r24
     b2a:	f9 07       	cpc	r31, r25
     b2c:	49 f0       	breq	.+18     	; 0xb40 <xTaskCreate+0x86>
     b2e:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     b30:	41 91       	ld	r20, Z+
     b32:	db 01       	movw	r26, r22
     b34:	4d 93       	st	X+, r20
     b36:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     b38:	d9 01       	movw	r26, r18
     b3a:	2c 91       	ld	r18, X
     b3c:	21 11       	cpse	r18, r1
     b3e:	f4 cf       	rjmp	.-24     	; 0xb28 <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     b40:	18 a2       	std	Y+32, r1	; 0x20
     b42:	04 30       	cpi	r16, 0x04	; 4
     b44:	08 f0       	brcs	.+2      	; 0xb48 <xTaskCreate+0x8e>
     b46:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     b48:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     b4a:	6e 01       	movw	r12, r28
     b4c:	b2 e0       	ldi	r27, 0x02	; 2
     b4e:	cb 0e       	add	r12, r27
     b50:	d1 1c       	adc	r13, r1
     b52:	c6 01       	movw	r24, r12
     b54:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     b58:	ce 01       	movw	r24, r28
     b5a:	0c 96       	adiw	r24, 0x0c	; 12
     b5c:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     b60:	d9 87       	std	Y+9, r29	; 0x09
     b62:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b64:	84 e0       	ldi	r24, 0x04	; 4
     b66:	90 e0       	ldi	r25, 0x00	; 0
     b68:	80 1b       	sub	r24, r16
     b6a:	91 09       	sbc	r25, r1
     b6c:	9d 87       	std	Y+13, r25	; 0x0d
     b6e:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     b70:	db 8b       	std	Y+19, r29	; 0x13
     b72:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     b74:	19 a2       	std	Y+33, r1	; 0x21
     b76:	1a a2       	std	Y+34, r1	; 0x22
     b78:	1b a2       	std	Y+35, r1	; 0x23
     b7a:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     b7c:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     b7e:	a5 01       	movw	r20, r10
     b80:	b4 01       	movw	r22, r8
     b82:	c3 01       	movw	r24, r6
     b84:	0e 94 41 13 	call	0x2682	; 0x2682 <pxPortInitialiseStack>
     b88:	99 83       	std	Y+1, r25	; 0x01
     b8a:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     b8c:	e1 14       	cp	r14, r1
     b8e:	f1 04       	cpc	r15, r1
     b90:	19 f0       	breq	.+6      	; 0xb98 <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     b92:	f7 01       	movw	r30, r14
     b94:	d1 83       	std	Z+1, r29	; 0x01
     b96:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     b98:	0f b6       	in	r0, 0x3f	; 63
     b9a:	f8 94       	cli
     b9c:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     b9e:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <uxCurrentNumberOfTasks>
     ba2:	8f 5f       	subi	r24, 0xFF	; 255
     ba4:	80 93 65 02 	sts	0x0265, r24	; 0x800265 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     ba8:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTCB>
     bac:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     bb0:	89 2b       	or	r24, r25
     bb2:	a9 f5       	brne	.+106    	; 0xc1e <xTaskCreate+0x164>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     bb4:	d0 93 57 02 	sts	0x0257, r29	; 0x800257 <pxCurrentTCB+0x1>
     bb8:	c0 93 56 02 	sts	0x0256, r28	; 0x800256 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     bbc:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <uxCurrentNumberOfTasks>
     bc0:	81 30       	cpi	r24, 0x01	; 1
     bc2:	e9 f5       	brne	.+122    	; 0xc3e <xTaskCreate+0x184>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     bc4:	8f e8       	ldi	r24, 0x8F	; 143
     bc6:	92 e0       	ldi	r25, 0x02	; 2
     bc8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
     bcc:	88 e9       	ldi	r24, 0x98	; 152
     bce:	92 e0       	ldi	r25, 0x02	; 2
     bd0:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
     bd4:	81 ea       	ldi	r24, 0xA1	; 161
     bd6:	92 e0       	ldi	r25, 0x02	; 2
     bd8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
     bdc:	8a ea       	ldi	r24, 0xAA	; 170
     bde:	92 e0       	ldi	r25, 0x02	; 2
     be0:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     be4:	86 e8       	ldi	r24, 0x86	; 134
     be6:	92 e0       	ldi	r25, 0x02	; 2
     be8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     bec:	8d e7       	ldi	r24, 0x7D	; 125
     bee:	92 e0       	ldi	r25, 0x02	; 2
     bf0:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     bf4:	80 e7       	ldi	r24, 0x70	; 112
     bf6:	92 e0       	ldi	r25, 0x02	; 2
     bf8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     bfc:	87 e6       	ldi	r24, 0x67	; 103
     bfe:	92 e0       	ldi	r25, 0x02	; 2
     c00:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     c04:	86 e8       	ldi	r24, 0x86	; 134
     c06:	92 e0       	ldi	r25, 0x02	; 2
     c08:	90 93 7c 02 	sts	0x027C, r25	; 0x80027c <pxDelayedTaskList+0x1>
     c0c:	80 93 7b 02 	sts	0x027B, r24	; 0x80027b <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     c10:	8d e7       	ldi	r24, 0x7D	; 125
     c12:	92 e0       	ldi	r25, 0x02	; 2
     c14:	90 93 7a 02 	sts	0x027A, r25	; 0x80027a <pxOverflowDelayedTaskList+0x1>
     c18:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <pxOverflowDelayedTaskList>
     c1c:	10 c0       	rjmp	.+32     	; 0xc3e <xTaskCreate+0x184>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     c1e:	80 91 61 02 	lds	r24, 0x0261	; 0x800261 <xSchedulerRunning>
     c22:	81 11       	cpse	r24, r1
     c24:	0c c0       	rjmp	.+24     	; 0xc3e <xTaskCreate+0x184>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     c26:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
     c2a:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     c2e:	96 89       	ldd	r25, Z+22	; 0x16
     c30:	8e 89       	ldd	r24, Y+22	; 0x16
     c32:	89 17       	cp	r24, r25
     c34:	20 f0       	brcs	.+8      	; 0xc3e <xTaskCreate+0x184>
				{
					pxCurrentTCB = pxNewTCB;
     c36:	d0 93 57 02 	sts	0x0257, r29	; 0x800257 <pxCurrentTCB+0x1>
     c3a:	c0 93 56 02 	sts	0x0256, r28	; 0x800256 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     c3e:	80 91 5d 02 	lds	r24, 0x025D	; 0x80025d <uxTaskNumber>
     c42:	8f 5f       	subi	r24, 0xFF	; 255
     c44:	80 93 5d 02 	sts	0x025D, r24	; 0x80025d <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     c48:	8e 89       	ldd	r24, Y+22	; 0x16
     c4a:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <uxTopReadyPriority>
     c4e:	98 17       	cp	r25, r24
     c50:	10 f4       	brcc	.+4      	; 0xc56 <xTaskCreate+0x19c>
     c52:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
     c56:	f9 e0       	ldi	r31, 0x09	; 9
     c58:	8f 9f       	mul	r24, r31
     c5a:	c0 01       	movw	r24, r0
     c5c:	11 24       	eor	r1, r1
     c5e:	b6 01       	movw	r22, r12
     c60:	81 57       	subi	r24, 0x71	; 113
     c62:	9d 4f       	sbci	r25, 0xFD	; 253
     c64:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     c68:	0f 90       	pop	r0
     c6a:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     c6c:	80 91 61 02 	lds	r24, 0x0261	; 0x800261 <xSchedulerRunning>
     c70:	88 23       	and	r24, r24
     c72:	51 f0       	breq	.+20     	; 0xc88 <xTaskCreate+0x1ce>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     c74:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
     c78:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     c7c:	96 89       	ldd	r25, Z+22	; 0x16
     c7e:	8e 89       	ldd	r24, Y+22	; 0x16
     c80:	98 17       	cp	r25, r24
     c82:	10 f4       	brcc	.+4      	; 0xc88 <xTaskCreate+0x1ce>
		{
			taskYIELD_IF_USING_PREEMPTION();
     c84:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	01 c0       	rjmp	.+2      	; 0xc8e <xTaskCreate+0x1d4>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     c8c:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	ff 90       	pop	r15
     c98:	ef 90       	pop	r14
     c9a:	df 90       	pop	r13
     c9c:	cf 90       	pop	r12
     c9e:	bf 90       	pop	r11
     ca0:	af 90       	pop	r10
     ca2:	9f 90       	pop	r9
     ca4:	8f 90       	pop	r8
     ca6:	7f 90       	pop	r7
     ca8:	6f 90       	pop	r6
     caa:	5f 90       	pop	r5
     cac:	4f 90       	pop	r4
     cae:	3f 90       	pop	r3
     cb0:	08 95       	ret

00000cb2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
     cba:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     cbc:	0f b6       	in	r0, 0x3f	; 63
     cbe:	f8 94       	cli
     cc0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     cc2:	89 2b       	or	r24, r25
     cc4:	21 f4       	brne	.+8      	; 0xcce <vTaskDelete+0x1c>
     cc6:	c0 91 56 02 	lds	r28, 0x0256	; 0x800256 <pxCurrentTCB>
     cca:	d0 91 57 02 	lds	r29, 0x0257	; 0x800257 <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     cce:	8e 01       	movw	r16, r28
     cd0:	0e 5f       	subi	r16, 0xFE	; 254
     cd2:	1f 4f       	sbci	r17, 0xFF	; 255
     cd4:	c8 01       	movw	r24, r16
     cd6:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     cda:	8c 89       	ldd	r24, Y+20	; 0x14
     cdc:	9d 89       	ldd	r25, Y+21	; 0x15
     cde:	89 2b       	or	r24, r25
     ce0:	21 f0       	breq	.+8      	; 0xcea <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     ce2:	ce 01       	movw	r24, r28
     ce4:	0c 96       	adiw	r24, 0x0c	; 12
     ce6:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     cea:	80 91 5d 02 	lds	r24, 0x025D	; 0x80025d <uxTaskNumber>
     cee:	8f 5f       	subi	r24, 0xFF	; 255
     cf0:	80 93 5d 02 	sts	0x025D, r24	; 0x80025d <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     cf4:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTCB>
     cf8:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     cfc:	c8 17       	cp	r28, r24
     cfe:	d9 07       	cpc	r29, r25
     d00:	59 f4       	brne	.+22     	; 0xd18 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     d02:	b8 01       	movw	r22, r16
     d04:	87 e6       	ldi	r24, 0x67	; 103
     d06:	92 e0       	ldi	r25, 0x02	; 2
     d08:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     d0c:	80 91 66 02 	lds	r24, 0x0266	; 0x800266 <uxDeletedTasksWaitingCleanUp>
     d10:	8f 5f       	subi	r24, 0xFF	; 255
     d12:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <uxDeletedTasksWaitingCleanUp>
     d16:	0e c0       	rjmp	.+28     	; 0xd34 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     d18:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <uxCurrentNumberOfTasks>
     d1c:	81 50       	subi	r24, 0x01	; 1
     d1e:	80 93 65 02 	sts	0x0265, r24	; 0x800265 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     d22:	8f 89       	ldd	r24, Y+23	; 0x17
     d24:	98 8d       	ldd	r25, Y+24	; 0x18
     d26:	0e 94 32 13 	call	0x2664	; 0x2664 <vPortFree>
			vPortFree( pxTCB );
     d2a:	ce 01       	movw	r24, r28
     d2c:	0e 94 32 13 	call	0x2664	; 0x2664 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     d30:	0e 94 ff 04 	call	0x9fe	; 0x9fe <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     d34:	0f 90       	pop	r0
     d36:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     d38:	80 91 61 02 	lds	r24, 0x0261	; 0x800261 <xSchedulerRunning>
     d3c:	88 23       	and	r24, r24
     d3e:	49 f0       	breq	.+18     	; 0xd52 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     d40:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTCB>
     d44:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     d48:	c8 17       	cp	r28, r24
     d4a:	d9 07       	cpc	r29, r25
     d4c:	11 f4       	brne	.+4      	; 0xd52 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     d4e:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     d52:	df 91       	pop	r29
     d54:	cf 91       	pop	r28
     d56:	1f 91       	pop	r17
     d58:	0f 91       	pop	r16
     d5a:	08 95       	ret

00000d5c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     d5c:	ef 92       	push	r14
     d5e:	ff 92       	push	r15
     d60:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     d62:	89 e5       	ldi	r24, 0x59	; 89
     d64:	e8 2e       	mov	r14, r24
     d66:	82 e0       	ldi	r24, 0x02	; 2
     d68:	f8 2e       	mov	r15, r24
     d6a:	00 e0       	ldi	r16, 0x00	; 0
     d6c:	20 e0       	ldi	r18, 0x00	; 0
     d6e:	30 e0       	ldi	r19, 0x00	; 0
     d70:	45 e5       	ldi	r20, 0x55	; 85
     d72:	50 e0       	ldi	r21, 0x00	; 0
     d74:	66 e2       	ldi	r22, 0x26	; 38
     d76:	72 e0       	ldi	r23, 0x02	; 2
     d78:	88 e8       	ldi	r24, 0x88	; 136
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     d80:	81 30       	cpi	r24, 0x01	; 1
     d82:	91 f4       	brne	.+36     	; 0xda8 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     d84:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     d86:	2f ef       	ldi	r18, 0xFF	; 255
     d88:	3f ef       	ldi	r19, 0xFF	; 255
     d8a:	30 93 5c 02 	sts	0x025C, r19	; 0x80025c <xNextTaskUnblockTime+0x1>
     d8e:	20 93 5b 02 	sts	0x025B, r18	; 0x80025b <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     d92:	80 93 61 02 	sts	0x0261, r24	; 0x800261 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     d96:	10 92 64 02 	sts	0x0264, r1	; 0x800264 <xTickCount+0x1>
     d9a:	10 92 63 02 	sts	0x0263, r1	; 0x800263 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     d9e:	0f 91       	pop	r16
     da0:	ff 90       	pop	r15
     da2:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     da4:	0c 94 b3 13 	jmp	0x2766	; 0x2766 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     da8:	0f 91       	pop	r16
     daa:	ff 90       	pop	r15
     dac:	ef 90       	pop	r14
     dae:	08 95       	ret

00000db0 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     db0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     db2:	10 92 61 02 	sts	0x0261, r1	; 0x800261 <xSchedulerRunning>
	vPortEndScheduler();
     db6:	0c 94 fb 13 	jmp	0x27f6	; 0x27f6 <vPortEndScheduler>

00000dba <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     dba:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <uxSchedulerSuspended>
     dbe:	8f 5f       	subi	r24, 0xFF	; 255
     dc0:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <uxSchedulerSuspended>
     dc4:	08 95       	ret

00000dc6 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     dc6:	0f b6       	in	r0, 0x3f	; 63
     dc8:	f8 94       	cli
     dca:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     dcc:	80 91 63 02 	lds	r24, 0x0263	; 0x800263 <xTickCount>
     dd0:	90 91 64 02 	lds	r25, 0x0264	; 0x800264 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     dd4:	0f 90       	pop	r0
     dd6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     dd8:	08 95       	ret

00000dda <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     dda:	80 91 63 02 	lds	r24, 0x0263	; 0x800263 <xTickCount>
     dde:	90 91 64 02 	lds	r25, 0x0264	; 0x800264 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     de2:	08 95       	ret

00000de4 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     de4:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <uxCurrentNumberOfTasks>
}
     de8:	08 95       	ret

00000dea <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     dea:	00 97       	sbiw	r24, 0x00	; 0
     dec:	21 f4       	brne	.+8      	; 0xdf6 <pcTaskGetName+0xc>
     dee:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTCB>
     df2:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     df6:	49 96       	adiw	r24, 0x19	; 25
     df8:	08 95       	ret

00000dfa <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     dfa:	cf 92       	push	r12
     dfc:	df 92       	push	r13
     dfe:	ef 92       	push	r14
     e00:	ff 92       	push	r15
     e02:	0f 93       	push	r16
     e04:	1f 93       	push	r17
     e06:	cf 93       	push	r28
     e08:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     e0a:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <uxSchedulerSuspended>
     e0e:	81 11       	cpse	r24, r1
     e10:	8c c0       	rjmp	.+280    	; 0xf2a <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     e12:	00 91 63 02 	lds	r16, 0x0263	; 0x800263 <xTickCount>
     e16:	10 91 64 02 	lds	r17, 0x0264	; 0x800264 <xTickCount+0x1>
     e1a:	0f 5f       	subi	r16, 0xFF	; 255
     e1c:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     e1e:	10 93 64 02 	sts	0x0264, r17	; 0x800264 <xTickCount+0x1>
     e22:	00 93 63 02 	sts	0x0263, r16	; 0x800263 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     e26:	01 15       	cp	r16, r1
     e28:	11 05       	cpc	r17, r1
     e2a:	b9 f4       	brne	.+46     	; 0xe5a <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     e2c:	80 91 7b 02 	lds	r24, 0x027B	; 0x80027b <pxDelayedTaskList>
     e30:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <pxDelayedTaskList+0x1>
     e34:	20 91 79 02 	lds	r18, 0x0279	; 0x800279 <pxOverflowDelayedTaskList>
     e38:	30 91 7a 02 	lds	r19, 0x027A	; 0x80027a <pxOverflowDelayedTaskList+0x1>
     e3c:	30 93 7c 02 	sts	0x027C, r19	; 0x80027c <pxDelayedTaskList+0x1>
     e40:	20 93 7b 02 	sts	0x027B, r18	; 0x80027b <pxDelayedTaskList>
     e44:	90 93 7a 02 	sts	0x027A, r25	; 0x80027a <pxOverflowDelayedTaskList+0x1>
     e48:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <pxOverflowDelayedTaskList>
     e4c:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <xNumOfOverflows>
     e50:	8f 5f       	subi	r24, 0xFF	; 255
     e52:	80 93 5e 02 	sts	0x025E, r24	; 0x80025e <xNumOfOverflows>
     e56:	0e 94 ff 04 	call	0x9fe	; 0x9fe <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     e5a:	80 91 5b 02 	lds	r24, 0x025B	; 0x80025b <xNextTaskUnblockTime>
     e5e:	90 91 5c 02 	lds	r25, 0x025C	; 0x80025c <xNextTaskUnblockTime+0x1>
     e62:	c0 e0       	ldi	r28, 0x00	; 0
     e64:	08 17       	cp	r16, r24
     e66:	19 07       	cpc	r17, r25
     e68:	08 f4       	brcc	.+2      	; 0xe6c <xTaskIncrementTick+0x72>
     e6a:	4f c0       	rjmp	.+158    	; 0xf0a <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     e6c:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     e6e:	e0 91 7b 02 	lds	r30, 0x027B	; 0x80027b <pxDelayedTaskList>
     e72:	f0 91 7c 02 	lds	r31, 0x027C	; 0x80027c <pxDelayedTaskList+0x1>
     e76:	80 81       	ld	r24, Z
     e78:	81 11       	cpse	r24, r1
     e7a:	03 c0       	rjmp	.+6      	; 0xe82 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e7c:	8f ef       	ldi	r24, 0xFF	; 255
     e7e:	9f ef       	ldi	r25, 0xFF	; 255
     e80:	11 c0       	rjmp	.+34     	; 0xea4 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     e82:	e0 91 7b 02 	lds	r30, 0x027B	; 0x80027b <pxDelayedTaskList>
     e86:	f0 91 7c 02 	lds	r31, 0x027C	; 0x80027c <pxDelayedTaskList+0x1>
     e8a:	05 80       	ldd	r0, Z+5	; 0x05
     e8c:	f6 81       	ldd	r31, Z+6	; 0x06
     e8e:	e0 2d       	mov	r30, r0
     e90:	e6 80       	ldd	r14, Z+6	; 0x06
     e92:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     e94:	d7 01       	movw	r26, r14
     e96:	12 96       	adiw	r26, 0x02	; 2
     e98:	8d 91       	ld	r24, X+
     e9a:	9c 91       	ld	r25, X
     e9c:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     e9e:	08 17       	cp	r16, r24
     ea0:	19 07       	cpc	r17, r25
     ea2:	28 f4       	brcc	.+10     	; 0xeae <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     ea4:	90 93 5c 02 	sts	0x025C, r25	; 0x80025c <xNextTaskUnblockTime+0x1>
     ea8:	80 93 5b 02 	sts	0x025B, r24	; 0x80025b <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     eac:	2e c0       	rjmp	.+92     	; 0xf0a <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     eae:	67 01       	movw	r12, r14
     eb0:	b2 e0       	ldi	r27, 0x02	; 2
     eb2:	cb 0e       	add	r12, r27
     eb4:	d1 1c       	adc	r13, r1
     eb6:	c6 01       	movw	r24, r12
     eb8:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     ebc:	f7 01       	movw	r30, r14
     ebe:	84 89       	ldd	r24, Z+20	; 0x14
     ec0:	95 89       	ldd	r25, Z+21	; 0x15
     ec2:	89 2b       	or	r24, r25
     ec4:	21 f0       	breq	.+8      	; 0xece <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     ec6:	c7 01       	movw	r24, r14
     ec8:	0c 96       	adiw	r24, 0x0c	; 12
     eca:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     ece:	d7 01       	movw	r26, r14
     ed0:	56 96       	adiw	r26, 0x16	; 22
     ed2:	8c 91       	ld	r24, X
     ed4:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <uxTopReadyPriority>
     ed8:	98 17       	cp	r25, r24
     eda:	10 f4       	brcc	.+4      	; 0xee0 <xTaskIncrementTick+0xe6>
     edc:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
     ee0:	d8 9f       	mul	r29, r24
     ee2:	c0 01       	movw	r24, r0
     ee4:	11 24       	eor	r1, r1
     ee6:	b6 01       	movw	r22, r12
     ee8:	81 57       	subi	r24, 0x71	; 113
     eea:	9d 4f       	sbci	r25, 0xFD	; 253
     eec:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     ef0:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
     ef4:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     ef8:	d7 01       	movw	r26, r14
     efa:	56 96       	adiw	r26, 0x16	; 22
     efc:	9c 91       	ld	r25, X
     efe:	86 89       	ldd	r24, Z+22	; 0x16
     f00:	98 17       	cp	r25, r24
     f02:	08 f4       	brcc	.+2      	; 0xf06 <xTaskIncrementTick+0x10c>
     f04:	b4 cf       	rjmp	.-152    	; 0xe6e <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     f06:	c1 e0       	ldi	r28, 0x01	; 1
     f08:	b2 cf       	rjmp	.-156    	; 0xe6e <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     f0a:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
     f0e:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     f12:	e6 89       	ldd	r30, Z+22	; 0x16
     f14:	b9 e0       	ldi	r27, 0x09	; 9
     f16:	eb 9f       	mul	r30, r27
     f18:	f0 01       	movw	r30, r0
     f1a:	11 24       	eor	r1, r1
     f1c:	e1 57       	subi	r30, 0x71	; 113
     f1e:	fd 4f       	sbci	r31, 0xFD	; 253
     f20:	80 81       	ld	r24, Z
     f22:	82 30       	cpi	r24, 0x02	; 2
     f24:	40 f0       	brcs	.+16     	; 0xf36 <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     f26:	c1 e0       	ldi	r28, 0x01	; 1
     f28:	06 c0       	rjmp	.+12     	; 0xf36 <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     f2a:	80 91 60 02 	lds	r24, 0x0260	; 0x800260 <uxPendedTicks>
     f2e:	8f 5f       	subi	r24, 0xFF	; 255
     f30:	80 93 60 02 	sts	0x0260, r24	; 0x800260 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     f34:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     f36:	80 91 5f 02 	lds	r24, 0x025F	; 0x80025f <xYieldPending>
     f3a:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     f3c:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     f3e:	8c 2f       	mov	r24, r28
     f40:	df 91       	pop	r29
     f42:	cf 91       	pop	r28
     f44:	1f 91       	pop	r17
     f46:	0f 91       	pop	r16
     f48:	ff 90       	pop	r15
     f4a:	ef 90       	pop	r14
     f4c:	df 90       	pop	r13
     f4e:	cf 90       	pop	r12
     f50:	08 95       	ret

00000f52 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     f52:	ef 92       	push	r14
     f54:	ff 92       	push	r15
     f56:	0f 93       	push	r16
     f58:	1f 93       	push	r17
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     f5e:	0f b6       	in	r0, 0x3f	; 63
     f60:	f8 94       	cli
     f62:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     f64:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <uxSchedulerSuspended>
     f68:	81 50       	subi	r24, 0x01	; 1
     f6a:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     f6e:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <uxSchedulerSuspended>
     f72:	88 23       	and	r24, r24
     f74:	11 f0       	breq	.+4      	; 0xf7a <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     f76:	80 e0       	ldi	r24, 0x00	; 0
     f78:	52 c0       	rjmp	.+164    	; 0x101e <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     f7a:	80 91 65 02 	lds	r24, 0x0265	; 0x800265 <uxCurrentNumberOfTasks>
     f7e:	88 23       	and	r24, r24
     f80:	d1 f3       	breq	.-12     	; 0xf76 <xTaskResumeAll+0x24>
     f82:	c0 e0       	ldi	r28, 0x00	; 0
     f84:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     f86:	89 e0       	ldi	r24, 0x09	; 9
     f88:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     f8a:	ee 24       	eor	r14, r14
     f8c:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     f8e:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <xPendingReadyList>
     f92:	88 23       	and	r24, r24
     f94:	51 f1       	breq	.+84     	; 0xfea <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     f96:	e0 91 75 02 	lds	r30, 0x0275	; 0x800275 <xPendingReadyList+0x5>
     f9a:	f0 91 76 02 	lds	r31, 0x0276	; 0x800276 <xPendingReadyList+0x6>
     f9e:	c6 81       	ldd	r28, Z+6	; 0x06
     fa0:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     fa2:	ce 01       	movw	r24, r28
     fa4:	0c 96       	adiw	r24, 0x0c	; 12
     fa6:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     faa:	8e 01       	movw	r16, r28
     fac:	0e 5f       	subi	r16, 0xFE	; 254
     fae:	1f 4f       	sbci	r17, 0xFF	; 255
     fb0:	c8 01       	movw	r24, r16
     fb2:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     fb6:	8e 89       	ldd	r24, Y+22	; 0x16
     fb8:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <uxTopReadyPriority>
     fbc:	98 17       	cp	r25, r24
     fbe:	10 f4       	brcc	.+4      	; 0xfc4 <xTaskResumeAll+0x72>
     fc0:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
     fc4:	f8 9e       	mul	r15, r24
     fc6:	c0 01       	movw	r24, r0
     fc8:	11 24       	eor	r1, r1
     fca:	b8 01       	movw	r22, r16
     fcc:	81 57       	subi	r24, 0x71	; 113
     fce:	9d 4f       	sbci	r25, 0xFD	; 253
     fd0:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     fd4:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
     fd8:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
     fdc:	9e 89       	ldd	r25, Y+22	; 0x16
     fde:	86 89       	ldd	r24, Z+22	; 0x16
     fe0:	98 17       	cp	r25, r24
     fe2:	a8 f2       	brcs	.-86     	; 0xf8e <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     fe4:	e0 92 5f 02 	sts	0x025F, r14	; 0x80025f <xYieldPending>
     fe8:	d2 cf       	rjmp	.-92     	; 0xf8e <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     fea:	cd 2b       	or	r28, r29
     fec:	11 f0       	breq	.+4      	; 0xff2 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     fee:	0e 94 ff 04 	call	0x9fe	; 0x9fe <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     ff2:	c0 91 60 02 	lds	r28, 0x0260	; 0x800260 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     ff6:	cc 23       	and	r28, r28
     ff8:	51 f0       	breq	.+20     	; 0x100e <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     ffa:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     ffc:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskIncrementTick>
    1000:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
    1002:	d0 93 5f 02 	sts	0x025F, r29	; 0x80025f <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1006:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1008:	c9 f7       	brne	.-14     	; 0xffc <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
    100a:	10 92 60 02 	sts	0x0260, r1	; 0x800260 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    100e:	80 91 5f 02 	lds	r24, 0x025F	; 0x80025f <xYieldPending>
    1012:	88 23       	and	r24, r24
    1014:	09 f4       	brne	.+2      	; 0x1018 <xTaskResumeAll+0xc6>
    1016:	af cf       	rjmp	.-162    	; 0xf76 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1018:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    101c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    101e:	0f 90       	pop	r0
    1020:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	ff 90       	pop	r15
    102c:	ef 90       	pop	r14
    102e:	08 95       	ret

00001030 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1030:	0f 93       	push	r16
    1032:	1f 93       	push	r17
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	8c 01       	movw	r16, r24
    103a:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    103c:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1040:	40 91 63 02 	lds	r20, 0x0263	; 0x800263 <xTickCount>
    1044:	50 91 64 02 	lds	r21, 0x0264	; 0x800264 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1048:	f8 01       	movw	r30, r16
    104a:	20 81       	ld	r18, Z
    104c:	31 81       	ldd	r19, Z+1	; 0x01
    104e:	c9 01       	movw	r24, r18
    1050:	8c 0f       	add	r24, r28
    1052:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
    1054:	42 17       	cp	r20, r18
    1056:	53 07       	cpc	r21, r19
    1058:	20 f4       	brcc	.+8      	; 0x1062 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    105a:	82 17       	cp	r24, r18
    105c:	93 07       	cpc	r25, r19
    105e:	40 f4       	brcc	.+16     	; 0x1070 <vTaskDelayUntil+0x40>
    1060:	03 c0       	rjmp	.+6      	; 0x1068 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1062:	82 17       	cp	r24, r18
    1064:	93 07       	cpc	r25, r19
    1066:	30 f0       	brcs	.+12     	; 0x1074 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1068:	21 e0       	ldi	r18, 0x01	; 1
    106a:	48 17       	cp	r20, r24
    106c:	59 07       	cpc	r21, r25
    106e:	18 f0       	brcs	.+6      	; 0x1076 <vTaskDelayUntil+0x46>
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	01 c0       	rjmp	.+2      	; 0x1076 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1074:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1076:	f8 01       	movw	r30, r16
    1078:	91 83       	std	Z+1, r25	; 0x01
    107a:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    107c:	22 23       	and	r18, r18
    107e:	21 f0       	breq	.+8      	; 0x1088 <vTaskDelayUntil+0x58>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1080:	84 1b       	sub	r24, r20
    1082:	95 0b       	sbc	r25, r21
    1084:	0e 94 1a 05 	call	0xa34	; 0xa34 <prvAddCurrentTaskToDelayedList.isra.2>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1088:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    108c:	81 11       	cpse	r24, r1
    108e:	02 c0       	rjmp	.+4      	; 0x1094 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
    1090:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1094:	df 91       	pop	r29
    1096:	cf 91       	pop	r28
    1098:	1f 91       	pop	r17
    109a:	0f 91       	pop	r16
    109c:	08 95       	ret

0000109e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    109e:	cf 93       	push	r28
    10a0:	df 93       	push	r29
    10a2:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    10a4:	89 2b       	or	r24, r25
    10a6:	19 f4       	brne	.+6      	; 0x10ae <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    10a8:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
    10ac:	09 c0       	rjmp	.+18     	; 0x10c0 <vTaskDelay+0x22>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    10ae:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    10b2:	ce 01       	movw	r24, r28
    10b4:	0e 94 1a 05 	call	0xa34	; 0xa34 <prvAddCurrentTaskToDelayedList.isra.2>
			}
			xAlreadyYielded = xTaskResumeAll();
    10b8:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    10bc:	88 23       	and	r24, r24
    10be:	a1 f3       	breq	.-24     	; 0x10a8 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	08 95       	ret

000010c6 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    10c6:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <uxSchedulerSuspended>
    10ca:	88 23       	and	r24, r24
    10cc:	21 f0       	breq	.+8      	; 0x10d6 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	80 93 5f 02 	sts	0x025F, r24	; 0x80025f <xYieldPending>
    10d4:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    10d6:	10 92 5f 02 	sts	0x025F, r1	; 0x80025f <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    10da:	80 91 62 02 	lds	r24, 0x0262	; 0x800262 <uxTopReadyPriority>
    10de:	69 e0       	ldi	r22, 0x09	; 9
    10e0:	48 2f       	mov	r20, r24
    10e2:	50 e0       	ldi	r21, 0x00	; 0
    10e4:	64 9f       	mul	r22, r20
    10e6:	90 01       	movw	r18, r0
    10e8:	65 9f       	mul	r22, r21
    10ea:	30 0d       	add	r19, r0
    10ec:	11 24       	eor	r1, r1
    10ee:	f9 01       	movw	r30, r18
    10f0:	e1 57       	subi	r30, 0x71	; 113
    10f2:	fd 4f       	sbci	r31, 0xFD	; 253
    10f4:	90 81       	ld	r25, Z
    10f6:	91 11       	cpse	r25, r1
    10f8:	02 c0       	rjmp	.+4      	; 0x10fe <vTaskSwitchContext+0x38>
    10fa:	81 50       	subi	r24, 0x01	; 1
    10fc:	f1 cf       	rjmp	.-30     	; 0x10e0 <vTaskSwitchContext+0x1a>
    10fe:	a1 81       	ldd	r26, Z+1	; 0x01
    1100:	b2 81       	ldd	r27, Z+2	; 0x02
    1102:	12 96       	adiw	r26, 0x02	; 2
    1104:	0d 90       	ld	r0, X+
    1106:	bc 91       	ld	r27, X
    1108:	a0 2d       	mov	r26, r0
    110a:	b2 83       	std	Z+2, r27	; 0x02
    110c:	a1 83       	std	Z+1, r26	; 0x01
    110e:	2e 56       	subi	r18, 0x6E	; 110
    1110:	3d 4f       	sbci	r19, 0xFD	; 253
    1112:	a2 17       	cp	r26, r18
    1114:	b3 07       	cpc	r27, r19
    1116:	31 f4       	brne	.+12     	; 0x1124 <vTaskSwitchContext+0x5e>
    1118:	12 96       	adiw	r26, 0x02	; 2
    111a:	2d 91       	ld	r18, X+
    111c:	3c 91       	ld	r19, X
    111e:	13 97       	sbiw	r26, 0x03	; 3
    1120:	32 83       	std	Z+2, r19	; 0x02
    1122:	21 83       	std	Z+1, r18	; 0x01
    1124:	99 e0       	ldi	r25, 0x09	; 9
    1126:	94 9f       	mul	r25, r20
    1128:	f0 01       	movw	r30, r0
    112a:	95 9f       	mul	r25, r21
    112c:	f0 0d       	add	r31, r0
    112e:	11 24       	eor	r1, r1
    1130:	e1 57       	subi	r30, 0x71	; 113
    1132:	fd 4f       	sbci	r31, 0xFD	; 253
    1134:	01 80       	ldd	r0, Z+1	; 0x01
    1136:	f2 81       	ldd	r31, Z+2	; 0x02
    1138:	e0 2d       	mov	r30, r0
    113a:	26 81       	ldd	r18, Z+6	; 0x06
    113c:	37 81       	ldd	r19, Z+7	; 0x07
    113e:	30 93 57 02 	sts	0x0257, r19	; 0x800257 <pxCurrentTCB+0x1>
    1142:	20 93 56 02 	sts	0x0256, r18	; 0x800256 <pxCurrentTCB>
    1146:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
    114a:	08 95       	ret

0000114c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    114c:	cf 93       	push	r28
    114e:	df 93       	push	r29
    1150:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1152:	60 91 56 02 	lds	r22, 0x0256	; 0x800256 <pxCurrentTCB>
    1156:	70 91 57 02 	lds	r23, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    115a:	64 5f       	subi	r22, 0xF4	; 244
    115c:	7f 4f       	sbci	r23, 0xFF	; 255
    115e:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1162:	ce 01       	movw	r24, r28
}
    1164:	df 91       	pop	r29
    1166:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1168:	0c 94 1a 05 	jmp	0xa34	; 0xa34 <prvAddCurrentTaskToDelayedList.isra.2>

0000116c <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1172:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1176:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    117a:	70 68       	ori	r23, 0x80	; 128
    117c:	75 87       	std	Z+13, r23	; 0x0d
    117e:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1180:	60 91 56 02 	lds	r22, 0x0256	; 0x800256 <pxCurrentTCB>
    1184:	70 91 57 02 	lds	r23, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1188:	64 5f       	subi	r22, 0xF4	; 244
    118a:	7f 4f       	sbci	r23, 0xFF	; 255
    118c:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1190:	ce 01       	movw	r24, r28
}
    1192:	df 91       	pop	r29
    1194:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1196:	0c 94 1a 05 	jmp	0xa34	; 0xa34 <prvAddCurrentTaskToDelayedList.isra.2>

0000119a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    119a:	0f 93       	push	r16
    119c:	1f 93       	push	r17
    119e:	cf 93       	push	r28
    11a0:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    11a2:	dc 01       	movw	r26, r24
    11a4:	15 96       	adiw	r26, 0x05	; 5
    11a6:	ed 91       	ld	r30, X+
    11a8:	fc 91       	ld	r31, X
    11aa:	16 97       	sbiw	r26, 0x06	; 6
    11ac:	c6 81       	ldd	r28, Z+6	; 0x06
    11ae:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    11b0:	8e 01       	movw	r16, r28
    11b2:	04 5f       	subi	r16, 0xF4	; 244
    11b4:	1f 4f       	sbci	r17, 0xFF	; 255
    11b6:	c8 01       	movw	r24, r16
    11b8:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    11bc:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <uxSchedulerSuspended>
    11c0:	81 11       	cpse	r24, r1
    11c2:	14 c0       	rjmp	.+40     	; 0x11ec <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    11c4:	0a 50       	subi	r16, 0x0A	; 10
    11c6:	11 09       	sbc	r17, r1
    11c8:	c8 01       	movw	r24, r16
    11ca:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    11ce:	8e 89       	ldd	r24, Y+22	; 0x16
    11d0:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <uxTopReadyPriority>
    11d4:	98 17       	cp	r25, r24
    11d6:	10 f4       	brcc	.+4      	; 0x11dc <xTaskRemoveFromEventList+0x42>
    11d8:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
    11dc:	b9 e0       	ldi	r27, 0x09	; 9
    11de:	8b 9f       	mul	r24, r27
    11e0:	c0 01       	movw	r24, r0
    11e2:	11 24       	eor	r1, r1
    11e4:	b8 01       	movw	r22, r16
    11e6:	81 57       	subi	r24, 0x71	; 113
    11e8:	9d 4f       	sbci	r25, 0xFD	; 253
    11ea:	03 c0       	rjmp	.+6      	; 0x11f2 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    11ec:	b8 01       	movw	r22, r16
    11ee:	80 e7       	ldi	r24, 0x70	; 112
    11f0:	92 e0       	ldi	r25, 0x02	; 2
    11f2:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    11f6:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    11fa:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    11fe:	9e 89       	ldd	r25, Y+22	; 0x16
    1200:	86 89       	ldd	r24, Z+22	; 0x16
    1202:	89 17       	cp	r24, r25
    1204:	20 f4       	brcc	.+8      	; 0x120e <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1206:	81 e0       	ldi	r24, 0x01	; 1
    1208:	80 93 5f 02 	sts	0x025F, r24	; 0x80025f <xYieldPending>
    120c:	01 c0       	rjmp	.+2      	; 0x1210 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
    120e:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1210:	df 91       	pop	r29
    1212:	cf 91       	pop	r28
    1214:	1f 91       	pop	r17
    1216:	0f 91       	pop	r16
    1218:	08 95       	ret

0000121a <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    121a:	0f 93       	push	r16
    121c:	1f 93       	push	r17
    121e:	cf 93       	push	r28
    1220:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1222:	70 68       	ori	r23, 0x80	; 128
    1224:	fc 01       	movw	r30, r24
    1226:	71 83       	std	Z+1, r23	; 0x01
    1228:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    122a:	c6 81       	ldd	r28, Z+6	; 0x06
    122c:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    122e:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1232:	8e 01       	movw	r16, r28
    1234:	0e 5f       	subi	r16, 0xFE	; 254
    1236:	1f 4f       	sbci	r17, 0xFF	; 255
    1238:	c8 01       	movw	r24, r16
    123a:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    123e:	8e 89       	ldd	r24, Y+22	; 0x16
    1240:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <uxTopReadyPriority>
    1244:	98 17       	cp	r25, r24
    1246:	10 f4       	brcc	.+4      	; 0x124c <vTaskRemoveFromUnorderedEventList+0x32>
    1248:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
    124c:	f9 e0       	ldi	r31, 0x09	; 9
    124e:	8f 9f       	mul	r24, r31
    1250:	c0 01       	movw	r24, r0
    1252:	11 24       	eor	r1, r1
    1254:	b8 01       	movw	r22, r16
    1256:	81 57       	subi	r24, 0x71	; 113
    1258:	9d 4f       	sbci	r25, 0xFD	; 253
    125a:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    125e:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1262:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1266:	9e 89       	ldd	r25, Y+22	; 0x16
    1268:	86 89       	ldd	r24, Z+22	; 0x16
    126a:	89 17       	cp	r24, r25
    126c:	18 f4       	brcc	.+6      	; 0x1274 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	80 93 5f 02 	sts	0x025F, r24	; 0x80025f <xYieldPending>
	}
}
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	1f 91       	pop	r17
    127a:	0f 91       	pop	r16
    127c:	08 95       	ret

0000127e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    127e:	0f b6       	in	r0, 0x3f	; 63
    1280:	f8 94       	cli
    1282:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    1284:	20 91 5e 02 	lds	r18, 0x025E	; 0x80025e <xNumOfOverflows>
    1288:	fc 01       	movw	r30, r24
    128a:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    128c:	20 91 63 02 	lds	r18, 0x0263	; 0x800263 <xTickCount>
    1290:	30 91 64 02 	lds	r19, 0x0264	; 0x800264 <xTickCount+0x1>
    1294:	32 83       	std	Z+2, r19	; 0x02
    1296:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    1298:	0f 90       	pop	r0
    129a:	0f be       	out	0x3f, r0	; 63
    129c:	08 95       	ret

0000129e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    129e:	20 91 5e 02 	lds	r18, 0x025E	; 0x80025e <xNumOfOverflows>
    12a2:	fc 01       	movw	r30, r24
    12a4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    12a6:	20 91 63 02 	lds	r18, 0x0263	; 0x800263 <xTickCount>
    12aa:	30 91 64 02 	lds	r19, 0x0264	; 0x800264 <xTickCount+0x1>
    12ae:	32 83       	std	Z+2, r19	; 0x02
    12b0:	21 83       	std	Z+1, r18	; 0x01
    12b2:	08 95       	ret

000012b4 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    12b4:	0f b6       	in	r0, 0x3f	; 63
    12b6:	f8 94       	cli
    12b8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    12ba:	20 91 63 02 	lds	r18, 0x0263	; 0x800263 <xTickCount>
    12be:	30 91 64 02 	lds	r19, 0x0264	; 0x800264 <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    12c2:	dc 01       	movw	r26, r24
    12c4:	11 96       	adiw	r26, 0x01	; 1
    12c6:	4d 91       	ld	r20, X+
    12c8:	5c 91       	ld	r21, X
    12ca:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    12cc:	e0 91 5e 02 	lds	r30, 0x025E	; 0x80025e <xNumOfOverflows>
    12d0:	fc 91       	ld	r31, X
    12d2:	fe 17       	cp	r31, r30
    12d4:	19 f0       	breq	.+6      	; 0x12dc <xTaskCheckForTimeOut+0x28>
    12d6:	24 17       	cp	r18, r20
    12d8:	35 07       	cpc	r19, r21
    12da:	90 f4       	brcc	.+36     	; 0x1300 <xTaskCheckForTimeOut+0x4c>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    12dc:	24 1b       	sub	r18, r20
    12de:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    12e0:	fb 01       	movw	r30, r22
    12e2:	40 81       	ld	r20, Z
    12e4:	51 81       	ldd	r21, Z+1	; 0x01
    12e6:	24 17       	cp	r18, r20
    12e8:	35 07       	cpc	r19, r21
    12ea:	40 f4       	brcc	.+16     	; 0x12fc <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    12ec:	42 1b       	sub	r20, r18
    12ee:	53 0b       	sbc	r21, r19
    12f0:	51 83       	std	Z+1, r21	; 0x01
    12f2:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    12f4:	0e 94 4f 09 	call	0x129e	; 0x129e <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    12f8:	80 e0       	ldi	r24, 0x00	; 0
    12fa:	03 c0       	rjmp	.+6      	; 0x1302 <xTaskCheckForTimeOut+0x4e>
		}
		else
		{
			*pxTicksToWait = 0;
    12fc:	11 82       	std	Z+1, r1	; 0x01
    12fe:	10 82       	st	Z, r1
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1300:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1302:	0f 90       	pop	r0
    1304:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1306:	08 95       	ret

00001308 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1308:	81 e0       	ldi	r24, 0x01	; 1
    130a:	80 93 5f 02 	sts	0x025F, r24	; 0x80025f <xYieldPending>
    130e:	08 95       	ret

00001310 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1310:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1314:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1318:	84 85       	ldd	r24, Z+12	; 0x0c
    131a:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    131c:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1320:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1324:	a0 91 56 02 	lds	r26, 0x0256	; 0x800256 <pxCurrentTCB>
    1328:	b0 91 57 02 	lds	r27, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    132c:	56 96       	adiw	r26, 0x16	; 22
    132e:	4c 91       	ld	r20, X
    1330:	24 e0       	ldi	r18, 0x04	; 4
    1332:	30 e0       	ldi	r19, 0x00	; 0
    1334:	24 1b       	sub	r18, r20
    1336:	31 09       	sbc	r19, r1
    1338:	35 87       	std	Z+13, r19	; 0x0d
    133a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    133c:	08 95       	ret

0000133e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    133e:	0f 93       	push	r16
    1340:	1f 93       	push	r17
    1342:	18 2f       	mov	r17, r24
    1344:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1346:	0f b6       	in	r0, 0x3f	; 63
    1348:	f8 94       	cli
    134a:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    134c:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1350:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1354:	41 a1       	ldd	r20, Z+33	; 0x21
    1356:	52 a1       	ldd	r21, Z+34	; 0x22
    1358:	63 a1       	ldd	r22, Z+35	; 0x23
    135a:	74 a1       	ldd	r23, Z+36	; 0x24
    135c:	45 2b       	or	r20, r21
    135e:	46 2b       	or	r20, r22
    1360:	47 2b       	or	r20, r23
    1362:	61 f4       	brne	.+24     	; 0x137c <ulTaskNotifyTake+0x3e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1364:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1368:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    136c:	21 e0       	ldi	r18, 0x01	; 1
    136e:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1370:	00 97       	sbiw	r24, 0x00	; 0
    1372:	21 f0       	breq	.+8      	; 0x137c <ulTaskNotifyTake+0x3e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1374:	0e 94 1a 05 	call	0xa34	; 0xa34 <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1378:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    137c:	0f 90       	pop	r0
    137e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1380:	0f b6       	in	r0, 0x3f	; 63
    1382:	f8 94       	cli
    1384:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1386:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    138a:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    138e:	61 a1       	ldd	r22, Z+33	; 0x21
    1390:	72 a1       	ldd	r23, Z+34	; 0x22
    1392:	83 a1       	ldd	r24, Z+35	; 0x23
    1394:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    1396:	61 15       	cp	r22, r1
    1398:	71 05       	cpc	r23, r1
    139a:	81 05       	cpc	r24, r1
    139c:	91 05       	cpc	r25, r1
    139e:	a9 f0       	breq	.+42     	; 0x13ca <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    13a0:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    13a4:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    13a8:	11 23       	and	r17, r17
    13aa:	29 f0       	breq	.+10     	; 0x13b6 <ulTaskNotifyTake+0x78>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    13ac:	11 a2       	std	Z+33, r1	; 0x21
    13ae:	12 a2       	std	Z+34, r1	; 0x22
    13b0:	13 a2       	std	Z+35, r1	; 0x23
    13b2:	14 a2       	std	Z+36, r1	; 0x24
    13b4:	0a c0       	rjmp	.+20     	; 0x13ca <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    13b6:	8b 01       	movw	r16, r22
    13b8:	9c 01       	movw	r18, r24
    13ba:	01 50       	subi	r16, 0x01	; 1
    13bc:	11 09       	sbc	r17, r1
    13be:	21 09       	sbc	r18, r1
    13c0:	31 09       	sbc	r19, r1
    13c2:	01 a3       	std	Z+33, r16	; 0x21
    13c4:	12 a3       	std	Z+34, r17	; 0x22
    13c6:	23 a3       	std	Z+35, r18	; 0x23
    13c8:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    13ca:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    13ce:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    13d2:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    13d4:	0f 90       	pop	r0
    13d6:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    13d8:	1f 91       	pop	r17
    13da:	0f 91       	pop	r16
    13dc:	08 95       	ret

000013de <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    13de:	4f 92       	push	r4
    13e0:	5f 92       	push	r5
    13e2:	6f 92       	push	r6
    13e4:	7f 92       	push	r7
    13e6:	8f 92       	push	r8
    13e8:	9f 92       	push	r9
    13ea:	af 92       	push	r10
    13ec:	bf 92       	push	r11
    13ee:	ef 92       	push	r14
    13f0:	ff 92       	push	r15
    13f2:	0f 93       	push	r16
    13f4:	1f 93       	push	r17
    13f6:	49 01       	movw	r8, r18
    13f8:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    13fa:	0f b6       	in	r0, 0x3f	; 63
    13fc:	f8 94       	cli
    13fe:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1400:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1404:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1408:	25 a1       	ldd	r18, Z+37	; 0x25
    140a:	22 30       	cpi	r18, 0x02	; 2
    140c:	31 f1       	breq	.+76     	; 0x145a <xTaskNotifyWait+0x7c>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    140e:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1412:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1416:	21 a1       	ldd	r18, Z+33	; 0x21
    1418:	32 a1       	ldd	r19, Z+34	; 0x22
    141a:	43 a1       	ldd	r20, Z+35	; 0x23
    141c:	54 a1       	ldd	r21, Z+36	; 0x24
    141e:	2b 01       	movw	r4, r22
    1420:	3c 01       	movw	r6, r24
    1422:	40 94       	com	r4
    1424:	50 94       	com	r5
    1426:	60 94       	com	r6
    1428:	70 94       	com	r7
    142a:	d3 01       	movw	r26, r6
    142c:	c2 01       	movw	r24, r4
    142e:	82 23       	and	r24, r18
    1430:	93 23       	and	r25, r19
    1432:	a4 23       	and	r26, r20
    1434:	b5 23       	and	r27, r21
    1436:	81 a3       	std	Z+33, r24	; 0x21
    1438:	92 a3       	std	Z+34, r25	; 0x22
    143a:	a3 a3       	std	Z+35, r26	; 0x23
    143c:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    143e:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1442:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    144a:	e1 14       	cp	r14, r1
    144c:	f1 04       	cpc	r15, r1
    144e:	29 f0       	breq	.+10     	; 0x145a <xTaskNotifyWait+0x7c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1450:	c7 01       	movw	r24, r14
    1452:	0e 94 1a 05 	call	0xa34	; 0xa34 <prvAddCurrentTaskToDelayedList.isra.2>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1456:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    145a:	0f 90       	pop	r0
    145c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    145e:	0f b6       	in	r0, 0x3f	; 63
    1460:	f8 94       	cli
    1462:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1464:	01 15       	cp	r16, r1
    1466:	11 05       	cpc	r17, r1
    1468:	69 f0       	breq	.+26     	; 0x1484 <xTaskNotifyWait+0xa6>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    146a:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    146e:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1472:	81 a1       	ldd	r24, Z+33	; 0x21
    1474:	92 a1       	ldd	r25, Z+34	; 0x22
    1476:	a3 a1       	ldd	r26, Z+35	; 0x23
    1478:	b4 a1       	ldd	r27, Z+36	; 0x24
    147a:	f8 01       	movw	r30, r16
    147c:	80 83       	st	Z, r24
    147e:	91 83       	std	Z+1, r25	; 0x01
    1480:	a2 83       	std	Z+2, r26	; 0x02
    1482:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1484:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1488:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    148c:	85 a1       	ldd	r24, Z+37	; 0x25
    148e:	82 30       	cpi	r24, 0x02	; 2
    1490:	c1 f4       	brne	.+48     	; 0x14c2 <xTaskNotifyWait+0xe4>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1492:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1496:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    149a:	41 a1       	ldd	r20, Z+33	; 0x21
    149c:	52 a1       	ldd	r21, Z+34	; 0x22
    149e:	63 a1       	ldd	r22, Z+35	; 0x23
    14a0:	74 a1       	ldd	r23, Z+36	; 0x24
    14a2:	d5 01       	movw	r26, r10
    14a4:	c4 01       	movw	r24, r8
    14a6:	80 95       	com	r24
    14a8:	90 95       	com	r25
    14aa:	a0 95       	com	r26
    14ac:	b0 95       	com	r27
    14ae:	84 23       	and	r24, r20
    14b0:	95 23       	and	r25, r21
    14b2:	a6 23       	and	r26, r22
    14b4:	b7 23       	and	r27, r23
    14b6:	81 a3       	std	Z+33, r24	; 0x21
    14b8:	92 a3       	std	Z+34, r25	; 0x22
    14ba:	a3 a3       	std	Z+35, r26	; 0x23
    14bc:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	01 c0       	rjmp	.+2      	; 0x14c4 <xTaskNotifyWait+0xe6>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    14c2:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    14c4:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    14c8:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    14cc:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    14ce:	0f 90       	pop	r0
    14d0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    14d2:	1f 91       	pop	r17
    14d4:	0f 91       	pop	r16
    14d6:	ff 90       	pop	r15
    14d8:	ef 90       	pop	r14
    14da:	bf 90       	pop	r11
    14dc:	af 90       	pop	r10
    14de:	9f 90       	pop	r9
    14e0:	8f 90       	pop	r8
    14e2:	7f 90       	pop	r7
    14e4:	6f 90       	pop	r6
    14e6:	5f 90       	pop	r5
    14e8:	4f 90       	pop	r4
    14ea:	08 95       	ret

000014ec <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    14ec:	0f 93       	push	r16
    14ee:	1f 93       	push	r17
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    14f6:	0f b6       	in	r0, 0x3f	; 63
    14f8:	f8 94       	cli
    14fa:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    14fc:	01 15       	cp	r16, r1
    14fe:	11 05       	cpc	r17, r1
    1500:	49 f0       	breq	.+18     	; 0x1514 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1502:	81 a1       	ldd	r24, Z+33	; 0x21
    1504:	92 a1       	ldd	r25, Z+34	; 0x22
    1506:	a3 a1       	ldd	r26, Z+35	; 0x23
    1508:	b4 a1       	ldd	r27, Z+36	; 0x24
    150a:	e8 01       	movw	r28, r16
    150c:	88 83       	st	Y, r24
    150e:	99 83       	std	Y+1, r25	; 0x01
    1510:	aa 83       	std	Y+2, r26	; 0x02
    1512:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1514:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1516:	82 e0       	ldi	r24, 0x02	; 2
    1518:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    151a:	22 30       	cpi	r18, 0x02	; 2
    151c:	89 f0       	breq	.+34     	; 0x1540 <xTaskGenericNotify+0x54>
    151e:	58 f4       	brcc	.+22     	; 0x1536 <xTaskGenericNotify+0x4a>
    1520:	21 30       	cpi	r18, 0x01	; 1
    1522:	01 f5       	brne	.+64     	; 0x1564 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1524:	81 a1       	ldd	r24, Z+33	; 0x21
    1526:	92 a1       	ldd	r25, Z+34	; 0x22
    1528:	a3 a1       	ldd	r26, Z+35	; 0x23
    152a:	b4 a1       	ldd	r27, Z+36	; 0x24
    152c:	48 2b       	or	r20, r24
    152e:	59 2b       	or	r21, r25
    1530:	6a 2b       	or	r22, r26
    1532:	7b 2b       	or	r23, r27
    1534:	13 c0       	rjmp	.+38     	; 0x155c <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1536:	23 30       	cpi	r18, 0x03	; 3
    1538:	89 f0       	breq	.+34     	; 0x155c <xTaskGenericNotify+0x70>
    153a:	24 30       	cpi	r18, 0x04	; 4
    153c:	69 f0       	breq	.+26     	; 0x1558 <xTaskGenericNotify+0x6c>
    153e:	12 c0       	rjmp	.+36     	; 0x1564 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1540:	81 a1       	ldd	r24, Z+33	; 0x21
    1542:	92 a1       	ldd	r25, Z+34	; 0x22
    1544:	a3 a1       	ldd	r26, Z+35	; 0x23
    1546:	b4 a1       	ldd	r27, Z+36	; 0x24
    1548:	01 96       	adiw	r24, 0x01	; 1
    154a:	a1 1d       	adc	r26, r1
    154c:	b1 1d       	adc	r27, r1
    154e:	81 a3       	std	Z+33, r24	; 0x21
    1550:	92 a3       	std	Z+34, r25	; 0x22
    1552:	a3 a3       	std	Z+35, r26	; 0x23
    1554:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1556:	06 c0       	rjmp	.+12     	; 0x1564 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1558:	32 30       	cpi	r19, 0x02	; 2
    155a:	49 f1       	breq	.+82     	; 0x15ae <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    155c:	41 a3       	std	Z+33, r20	; 0x21
    155e:	52 a3       	std	Z+34, r21	; 0x22
    1560:	63 a3       	std	Z+35, r22	; 0x23
    1562:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1564:	31 30       	cpi	r19, 0x01	; 1
    1566:	09 f5       	brne	.+66     	; 0x15aa <xTaskGenericNotify+0xbe>
    1568:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    156a:	8f 01       	movw	r16, r30
    156c:	0e 5f       	subi	r16, 0xFE	; 254
    156e:	1f 4f       	sbci	r17, 0xFF	; 255
    1570:	c8 01       	movw	r24, r16
    1572:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1576:	8e 89       	ldd	r24, Y+22	; 0x16
    1578:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <uxTopReadyPriority>
    157c:	98 17       	cp	r25, r24
    157e:	10 f4       	brcc	.+4      	; 0x1584 <xTaskGenericNotify+0x98>
    1580:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
    1584:	29 e0       	ldi	r18, 0x09	; 9
    1586:	82 9f       	mul	r24, r18
    1588:	c0 01       	movw	r24, r0
    158a:	11 24       	eor	r1, r1
    158c:	b8 01       	movw	r22, r16
    158e:	81 57       	subi	r24, 0x71	; 113
    1590:	9d 4f       	sbci	r25, 0xFD	; 253
    1592:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1596:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    159a:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    159e:	9e 89       	ldd	r25, Y+22	; 0x16
    15a0:	86 89       	ldd	r24, Z+22	; 0x16
    15a2:	89 17       	cp	r24, r25
    15a4:	10 f4       	brcc	.+4      	; 0x15aa <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    15a6:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	01 c0       	rjmp	.+2      	; 0x15b0 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    15ae:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    15b0:	0f 90       	pop	r0
    15b2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    15b4:	df 91       	pop	r29
    15b6:	cf 91       	pop	r28
    15b8:	1f 91       	pop	r17
    15ba:	0f 91       	pop	r16
    15bc:	08 95       	ret

000015be <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    15be:	ef 92       	push	r14
    15c0:	ff 92       	push	r15
    15c2:	0f 93       	push	r16
    15c4:	1f 93       	push	r17
    15c6:	cf 93       	push	r28
    15c8:	df 93       	push	r29
    15ca:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    15cc:	01 15       	cp	r16, r1
    15ce:	11 05       	cpc	r17, r1
    15d0:	49 f0       	breq	.+18     	; 0x15e4 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    15d2:	81 a1       	ldd	r24, Z+33	; 0x21
    15d4:	92 a1       	ldd	r25, Z+34	; 0x22
    15d6:	a3 a1       	ldd	r26, Z+35	; 0x23
    15d8:	b4 a1       	ldd	r27, Z+36	; 0x24
    15da:	e8 01       	movw	r28, r16
    15dc:	88 83       	st	Y, r24
    15de:	99 83       	std	Y+1, r25	; 0x01
    15e0:	aa 83       	std	Y+2, r26	; 0x02
    15e2:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    15e4:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    15e6:	82 e0       	ldi	r24, 0x02	; 2
    15e8:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    15ea:	22 30       	cpi	r18, 0x02	; 2
    15ec:	89 f0       	breq	.+34     	; 0x1610 <xTaskGenericNotifyFromISR+0x52>
    15ee:	58 f4       	brcc	.+22     	; 0x1606 <xTaskGenericNotifyFromISR+0x48>
    15f0:	21 30       	cpi	r18, 0x01	; 1
    15f2:	01 f5       	brne	.+64     	; 0x1634 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    15f4:	81 a1       	ldd	r24, Z+33	; 0x21
    15f6:	92 a1       	ldd	r25, Z+34	; 0x22
    15f8:	a3 a1       	ldd	r26, Z+35	; 0x23
    15fa:	b4 a1       	ldd	r27, Z+36	; 0x24
    15fc:	48 2b       	or	r20, r24
    15fe:	59 2b       	or	r21, r25
    1600:	6a 2b       	or	r22, r26
    1602:	7b 2b       	or	r23, r27
    1604:	13 c0       	rjmp	.+38     	; 0x162c <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1606:	23 30       	cpi	r18, 0x03	; 3
    1608:	89 f0       	breq	.+34     	; 0x162c <xTaskGenericNotifyFromISR+0x6e>
    160a:	24 30       	cpi	r18, 0x04	; 4
    160c:	69 f0       	breq	.+26     	; 0x1628 <xTaskGenericNotifyFromISR+0x6a>
    160e:	12 c0       	rjmp	.+36     	; 0x1634 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1610:	81 a1       	ldd	r24, Z+33	; 0x21
    1612:	92 a1       	ldd	r25, Z+34	; 0x22
    1614:	a3 a1       	ldd	r26, Z+35	; 0x23
    1616:	b4 a1       	ldd	r27, Z+36	; 0x24
    1618:	01 96       	adiw	r24, 0x01	; 1
    161a:	a1 1d       	adc	r26, r1
    161c:	b1 1d       	adc	r27, r1
    161e:	81 a3       	std	Z+33, r24	; 0x21
    1620:	92 a3       	std	Z+34, r25	; 0x22
    1622:	a3 a3       	std	Z+35, r26	; 0x23
    1624:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1626:	06 c0       	rjmp	.+12     	; 0x1634 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1628:	32 30       	cpi	r19, 0x02	; 2
    162a:	d9 f1       	breq	.+118    	; 0x16a2 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    162c:	41 a3       	std	Z+33, r20	; 0x21
    162e:	52 a3       	std	Z+34, r21	; 0x22
    1630:	63 a3       	std	Z+35, r22	; 0x23
    1632:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1634:	31 30       	cpi	r19, 0x01	; 1
    1636:	11 f0       	breq	.+4      	; 0x163c <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1638:	81 e0       	ldi	r24, 0x01	; 1
    163a:	34 c0       	rjmp	.+104    	; 0x16a4 <xTaskGenericNotifyFromISR+0xe6>
    163c:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    163e:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <uxSchedulerSuspended>
    1642:	81 11       	cpse	r24, r1
    1644:	15 c0       	rjmp	.+42     	; 0x1670 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1646:	8f 01       	movw	r16, r30
    1648:	0e 5f       	subi	r16, 0xFE	; 254
    164a:	1f 4f       	sbci	r17, 0xFF	; 255
    164c:	c8 01       	movw	r24, r16
    164e:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1652:	8e 89       	ldd	r24, Y+22	; 0x16
    1654:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <uxTopReadyPriority>
    1658:	98 17       	cp	r25, r24
    165a:	10 f4       	brcc	.+4      	; 0x1660 <xTaskGenericNotifyFromISR+0xa2>
    165c:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
    1660:	e9 e0       	ldi	r30, 0x09	; 9
    1662:	8e 9f       	mul	r24, r30
    1664:	c0 01       	movw	r24, r0
    1666:	11 24       	eor	r1, r1
    1668:	b8 01       	movw	r22, r16
    166a:	81 57       	subi	r24, 0x71	; 113
    166c:	9d 4f       	sbci	r25, 0xFD	; 253
    166e:	05 c0       	rjmp	.+10     	; 0x167a <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1670:	bf 01       	movw	r22, r30
    1672:	64 5f       	subi	r22, 0xF4	; 244
    1674:	7f 4f       	sbci	r23, 0xFF	; 255
    1676:	80 e7       	ldi	r24, 0x70	; 112
    1678:	92 e0       	ldi	r25, 0x02	; 2
    167a:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    167e:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    1682:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    1686:	9e 89       	ldd	r25, Y+22	; 0x16
    1688:	86 89       	ldd	r24, Z+22	; 0x16
    168a:	89 17       	cp	r24, r25
    168c:	a8 f6       	brcc	.-86     	; 0x1638 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    168e:	e1 14       	cp	r14, r1
    1690:	f1 04       	cpc	r15, r1
    1692:	19 f0       	breq	.+6      	; 0x169a <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1694:	81 e0       	ldi	r24, 0x01	; 1
    1696:	e7 01       	movw	r28, r14
    1698:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	80 93 5f 02 	sts	0x025F, r24	; 0x80025f <xYieldPending>
    16a0:	01 c0       	rjmp	.+2      	; 0x16a4 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    16a2:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    16a4:	df 91       	pop	r29
    16a6:	cf 91       	pop	r28
    16a8:	1f 91       	pop	r17
    16aa:	0f 91       	pop	r16
    16ac:	ff 90       	pop	r15
    16ae:	ef 90       	pop	r14
    16b0:	08 95       	ret

000016b2 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    16b2:	ef 92       	push	r14
    16b4:	ff 92       	push	r15
    16b6:	0f 93       	push	r16
    16b8:	1f 93       	push	r17
    16ba:	cf 93       	push	r28
    16bc:	df 93       	push	r29
    16be:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    16c0:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    16c2:	82 e0       	ldi	r24, 0x02	; 2
    16c4:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    16c6:	81 a1       	ldd	r24, Z+33	; 0x21
    16c8:	92 a1       	ldd	r25, Z+34	; 0x22
    16ca:	a3 a1       	ldd	r26, Z+35	; 0x23
    16cc:	b4 a1       	ldd	r27, Z+36	; 0x24
    16ce:	01 96       	adiw	r24, 0x01	; 1
    16d0:	a1 1d       	adc	r26, r1
    16d2:	b1 1d       	adc	r27, r1
    16d4:	81 a3       	std	Z+33, r24	; 0x21
    16d6:	92 a3       	std	Z+34, r25	; 0x22
    16d8:	a3 a3       	std	Z+35, r26	; 0x23
    16da:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    16dc:	21 30       	cpi	r18, 0x01	; 1
    16de:	a1 f5       	brne	.+104    	; 0x1748 <vTaskNotifyGiveFromISR+0x96>
    16e0:	8b 01       	movw	r16, r22
    16e2:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    16e4:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <uxSchedulerSuspended>
    16e8:	81 11       	cpse	r24, r1
    16ea:	16 c0       	rjmp	.+44     	; 0x1718 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    16ec:	7f 01       	movw	r14, r30
    16ee:	22 e0       	ldi	r18, 0x02	; 2
    16f0:	e2 0e       	add	r14, r18
    16f2:	f1 1c       	adc	r15, r1
    16f4:	c7 01       	movw	r24, r14
    16f6:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    16fa:	8e 89       	ldd	r24, Y+22	; 0x16
    16fc:	90 91 62 02 	lds	r25, 0x0262	; 0x800262 <uxTopReadyPriority>
    1700:	98 17       	cp	r25, r24
    1702:	10 f4       	brcc	.+4      	; 0x1708 <vTaskNotifyGiveFromISR+0x56>
    1704:	80 93 62 02 	sts	0x0262, r24	; 0x800262 <uxTopReadyPriority>
    1708:	e9 e0       	ldi	r30, 0x09	; 9
    170a:	8e 9f       	mul	r24, r30
    170c:	c0 01       	movw	r24, r0
    170e:	11 24       	eor	r1, r1
    1710:	b7 01       	movw	r22, r14
    1712:	81 57       	subi	r24, 0x71	; 113
    1714:	9d 4f       	sbci	r25, 0xFD	; 253
    1716:	05 c0       	rjmp	.+10     	; 0x1722 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1718:	bf 01       	movw	r22, r30
    171a:	64 5f       	subi	r22, 0xF4	; 244
    171c:	7f 4f       	sbci	r23, 0xFF	; 255
    171e:	80 e7       	ldi	r24, 0x70	; 112
    1720:	92 e0       	ldi	r25, 0x02	; 2
    1722:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1726:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <pxCurrentTCB>
    172a:	f0 91 57 02 	lds	r31, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    172e:	9e 89       	ldd	r25, Y+22	; 0x16
    1730:	86 89       	ldd	r24, Z+22	; 0x16
    1732:	89 17       	cp	r24, r25
    1734:	48 f4       	brcc	.+18     	; 0x1748 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1736:	01 15       	cp	r16, r1
    1738:	11 05       	cpc	r17, r1
    173a:	19 f0       	breq	.+6      	; 0x1742 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    173c:	81 e0       	ldi	r24, 0x01	; 1
    173e:	f8 01       	movw	r30, r16
    1740:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1742:	81 e0       	ldi	r24, 0x01	; 1
    1744:	80 93 5f 02 	sts	0x025F, r24	; 0x80025f <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1748:	df 91       	pop	r29
    174a:	cf 91       	pop	r28
    174c:	1f 91       	pop	r17
    174e:	0f 91       	pop	r16
    1750:	ff 90       	pop	r15
    1752:	ef 90       	pop	r14
    1754:	08 95       	ret

00001756 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1756:	00 97       	sbiw	r24, 0x00	; 0
    1758:	21 f4       	brne	.+8      	; 0x1762 <xTaskNotifyStateClear+0xc>
    175a:	80 91 56 02 	lds	r24, 0x0256	; 0x800256 <pxCurrentTCB>
    175e:	90 91 57 02 	lds	r25, 0x0257	; 0x800257 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    1762:	0f b6       	in	r0, 0x3f	; 63
    1764:	f8 94       	cli
    1766:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1768:	fc 01       	movw	r30, r24
    176a:	25 a1       	ldd	r18, Z+37	; 0x25
    176c:	22 30       	cpi	r18, 0x02	; 2
    176e:	19 f4       	brne	.+6      	; 0x1776 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1770:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	01 c0       	rjmp	.+2      	; 0x1778 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1776:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1778:	0f 90       	pop	r0
    177a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    177c:	08 95       	ret

0000177e <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    177e:	0f b6       	in	r0, 0x3f	; 63
    1780:	f8 94       	cli
    1782:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1784:	fc 01       	movw	r30, r24
    1786:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1788:	0f 90       	pop	r0
    178a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    178c:	81 e0       	ldi	r24, 0x01	; 1
    178e:	91 11       	cpse	r25, r1
    1790:	80 e0       	ldi	r24, 0x00	; 0
}
    1792:	08 95       	ret

00001794 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1794:	0f 93       	push	r16
    1796:	1f 93       	push	r17
    1798:	cf 93       	push	r28
    179a:	df 93       	push	r29
    179c:	ec 01       	movw	r28, r24
    179e:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    17a0:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    17a2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    17a4:	44 23       	and	r20, r20
    17a6:	b1 f1       	breq	.+108    	; 0x1814 <prvCopyDataToQueue+0x80>
    17a8:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    17aa:	01 11       	cpse	r16, r1
    17ac:	15 c0       	rjmp	.+42     	; 0x17d8 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    17ae:	8a 81       	ldd	r24, Y+2	; 0x02
    17b0:	9b 81       	ldd	r25, Y+3	; 0x03
    17b2:	0e 94 0a 17 	call	0x2e14	; 0x2e14 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    17b6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    17b8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ba:	9b 81       	ldd	r25, Y+3	; 0x03
    17bc:	82 0f       	add	r24, r18
    17be:	91 1d       	adc	r25, r1
    17c0:	9b 83       	std	Y+3, r25	; 0x03
    17c2:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    17c4:	2c 81       	ldd	r18, Y+4	; 0x04
    17c6:	3d 81       	ldd	r19, Y+5	; 0x05
    17c8:	82 17       	cp	r24, r18
    17ca:	93 07       	cpc	r25, r19
    17cc:	18 f1       	brcs	.+70     	; 0x1814 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    17ce:	88 81       	ld	r24, Y
    17d0:	99 81       	ldd	r25, Y+1	; 0x01
    17d2:	9b 83       	std	Y+3, r25	; 0x03
    17d4:	8a 83       	std	Y+2, r24	; 0x02
    17d6:	1e c0       	rjmp	.+60     	; 0x1814 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    17d8:	8e 81       	ldd	r24, Y+6	; 0x06
    17da:	9f 81       	ldd	r25, Y+7	; 0x07
    17dc:	0e 94 0a 17 	call	0x2e14	; 0x2e14 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    17e0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	91 95       	neg	r25
    17e6:	81 95       	neg	r24
    17e8:	91 09       	sbc	r25, r1
    17ea:	2e 81       	ldd	r18, Y+6	; 0x06
    17ec:	3f 81       	ldd	r19, Y+7	; 0x07
    17ee:	28 0f       	add	r18, r24
    17f0:	39 1f       	adc	r19, r25
    17f2:	3f 83       	std	Y+7, r19	; 0x07
    17f4:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    17f6:	48 81       	ld	r20, Y
    17f8:	59 81       	ldd	r21, Y+1	; 0x01
    17fa:	24 17       	cp	r18, r20
    17fc:	35 07       	cpc	r19, r21
    17fe:	30 f4       	brcc	.+12     	; 0x180c <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1800:	2c 81       	ldd	r18, Y+4	; 0x04
    1802:	3d 81       	ldd	r19, Y+5	; 0x05
    1804:	82 0f       	add	r24, r18
    1806:	93 1f       	adc	r25, r19
    1808:	9f 83       	std	Y+7, r25	; 0x07
    180a:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    180c:	02 30       	cpi	r16, 0x02	; 2
    180e:	11 f4       	brne	.+4      	; 0x1814 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1810:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1812:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1814:	1f 5f       	subi	r17, 0xFF	; 255
    1816:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1818:	80 e0       	ldi	r24, 0x00	; 0
    181a:	df 91       	pop	r29
    181c:	cf 91       	pop	r28
    181e:	1f 91       	pop	r17
    1820:	0f 91       	pop	r16
    1822:	08 95       	ret

00001824 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1824:	fc 01       	movw	r30, r24
    1826:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1828:	44 8d       	ldd	r20, Z+28	; 0x1c
    182a:	44 23       	and	r20, r20
    182c:	a1 f0       	breq	.+40     	; 0x1856 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    182e:	50 e0       	ldi	r21, 0x00	; 0
    1830:	26 81       	ldd	r18, Z+6	; 0x06
    1832:	37 81       	ldd	r19, Z+7	; 0x07
    1834:	24 0f       	add	r18, r20
    1836:	35 1f       	adc	r19, r21
    1838:	37 83       	std	Z+7, r19	; 0x07
    183a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    183c:	64 81       	ldd	r22, Z+4	; 0x04
    183e:	75 81       	ldd	r23, Z+5	; 0x05
    1840:	26 17       	cp	r18, r22
    1842:	37 07       	cpc	r19, r23
    1844:	20 f0       	brcs	.+8      	; 0x184e <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1846:	20 81       	ld	r18, Z
    1848:	31 81       	ldd	r19, Z+1	; 0x01
    184a:	37 83       	std	Z+7, r19	; 0x07
    184c:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    184e:	66 81       	ldd	r22, Z+6	; 0x06
    1850:	77 81       	ldd	r23, Z+7	; 0x07
    1852:	0c 94 0a 17 	jmp	0x2e14	; 0x2e14 <memcpy>
    1856:	08 95       	ret

00001858 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1858:	ef 92       	push	r14
    185a:	ff 92       	push	r15
    185c:	1f 93       	push	r17
    185e:	cf 93       	push	r28
    1860:	df 93       	push	r29
    1862:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1864:	0f b6       	in	r0, 0x3f	; 63
    1866:	f8 94       	cli
    1868:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    186a:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    186c:	7c 01       	movw	r14, r24
    186e:	81 e1       	ldi	r24, 0x11	; 17
    1870:	e8 0e       	add	r14, r24
    1872:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1874:	11 16       	cp	r1, r17
    1876:	5c f4       	brge	.+22     	; 0x188e <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1878:	89 89       	ldd	r24, Y+17	; 0x11
    187a:	88 23       	and	r24, r24
    187c:	41 f0       	breq	.+16     	; 0x188e <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    187e:	c7 01       	movw	r24, r14
    1880:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    1884:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1886:	0e 94 84 09 	call	0x1308	; 0x1308 <vTaskMissedYield>
    188a:	11 50       	subi	r17, 0x01	; 1
    188c:	f3 cf       	rjmp	.-26     	; 0x1874 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    188e:	8f ef       	ldi	r24, 0xFF	; 255
    1890:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1892:	0f 90       	pop	r0
    1894:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	f8 94       	cli
    189a:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    189c:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    189e:	7e 01       	movw	r14, r28
    18a0:	88 e0       	ldi	r24, 0x08	; 8
    18a2:	e8 0e       	add	r14, r24
    18a4:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    18a6:	11 16       	cp	r1, r17
    18a8:	5c f4       	brge	.+22     	; 0x18c0 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18aa:	88 85       	ldd	r24, Y+8	; 0x08
    18ac:	88 23       	and	r24, r24
    18ae:	41 f0       	breq	.+16     	; 0x18c0 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18b0:	c7 01       	movw	r24, r14
    18b2:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    18b6:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    18b8:	0e 94 84 09 	call	0x1308	; 0x1308 <vTaskMissedYield>
    18bc:	11 50       	subi	r17, 0x01	; 1
    18be:	f3 cf       	rjmp	.-26     	; 0x18a6 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    18c0:	8f ef       	ldi	r24, 0xFF	; 255
    18c2:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    18c4:	0f 90       	pop	r0
    18c6:	0f be       	out	0x3f, r0	; 63
}
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	1f 91       	pop	r17
    18ce:	ff 90       	pop	r15
    18d0:	ef 90       	pop	r14
    18d2:	08 95       	ret

000018d4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    18d4:	cf 93       	push	r28
    18d6:	df 93       	push	r29
    18d8:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    18da:	0f b6       	in	r0, 0x3f	; 63
    18dc:	f8 94       	cli
    18de:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    18e0:	48 81       	ld	r20, Y
    18e2:	59 81       	ldd	r21, Y+1	; 0x01
    18e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18e6:	7c 8d       	ldd	r23, Y+28	; 0x1c
    18e8:	9a 01       	movw	r18, r20
    18ea:	87 9f       	mul	r24, r23
    18ec:	20 0d       	add	r18, r0
    18ee:	31 1d       	adc	r19, r1
    18f0:	11 24       	eor	r1, r1
    18f2:	3d 83       	std	Y+5, r19	; 0x05
    18f4:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    18f6:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    18f8:	5b 83       	std	Y+3, r21	; 0x03
    18fa:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	01 97       	sbiw	r24, 0x01	; 1
    1900:	78 9f       	mul	r23, r24
    1902:	90 01       	movw	r18, r0
    1904:	79 9f       	mul	r23, r25
    1906:	30 0d       	add	r19, r0
    1908:	11 24       	eor	r1, r1
    190a:	ca 01       	movw	r24, r20
    190c:	82 0f       	add	r24, r18
    190e:	93 1f       	adc	r25, r19
    1910:	9f 83       	std	Y+7, r25	; 0x07
    1912:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1914:	8f ef       	ldi	r24, 0xFF	; 255
    1916:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1918:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    191a:	61 11       	cpse	r22, r1
    191c:	0c c0       	rjmp	.+24     	; 0x1936 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    191e:	88 85       	ldd	r24, Y+8	; 0x08
    1920:	88 23       	and	r24, r24
    1922:	89 f0       	breq	.+34     	; 0x1946 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1924:	ce 01       	movw	r24, r28
    1926:	08 96       	adiw	r24, 0x08	; 8
    1928:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    192c:	88 23       	and	r24, r24
    192e:	59 f0       	breq	.+22     	; 0x1946 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1930:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
    1934:	08 c0       	rjmp	.+16     	; 0x1946 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1936:	ce 01       	movw	r24, r28
    1938:	08 96       	adiw	r24, 0x08	; 8
    193a:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    193e:	ce 01       	movw	r24, r28
    1940:	41 96       	adiw	r24, 0x11	; 17
    1942:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	df 91       	pop	r29
    194e:	cf 91       	pop	r28
    1950:	08 95       	ret

00001952 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1952:	0f 93       	push	r16
    1954:	1f 93       	push	r17
    1956:	cf 93       	push	r28
    1958:	df 93       	push	r29
    195a:	08 2f       	mov	r16, r24
    195c:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    195e:	66 23       	and	r22, r22
    1960:	21 f0       	breq	.+8      	; 0x196a <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1962:	86 9f       	mul	r24, r22
    1964:	c0 01       	movw	r24, r0
    1966:	11 24       	eor	r1, r1
    1968:	02 c0       	rjmp	.+4      	; 0x196e <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    196e:	4f 96       	adiw	r24, 0x1f	; 31
    1970:	0e 94 00 13 	call	0x2600	; 0x2600 <pvPortMalloc>
    1974:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1976:	00 97       	sbiw	r24, 0x00	; 0
    1978:	71 f0       	breq	.+28     	; 0x1996 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    197a:	11 11       	cpse	r17, r1
    197c:	03 c0       	rjmp	.+6      	; 0x1984 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    197e:	99 83       	std	Y+1, r25	; 0x01
    1980:	88 83       	st	Y, r24
    1982:	03 c0       	rjmp	.+6      	; 0x198a <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1984:	4f 96       	adiw	r24, 0x1f	; 31
    1986:	99 83       	std	Y+1, r25	; 0x01
    1988:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    198a:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    198c:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    198e:	61 e0       	ldi	r22, 0x01	; 1
    1990:	ce 01       	movw	r24, r28
    1992:	0e 94 6a 0c 	call	0x18d4	; 0x18d4 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    1996:	ce 01       	movw	r24, r28
    1998:	df 91       	pop	r29
    199a:	cf 91       	pop	r28
    199c:	1f 91       	pop	r17
    199e:	0f 91       	pop	r16
    19a0:	08 95       	ret

000019a2 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    19a2:	af 92       	push	r10
    19a4:	bf 92       	push	r11
    19a6:	cf 92       	push	r12
    19a8:	df 92       	push	r13
    19aa:	ff 92       	push	r15
    19ac:	0f 93       	push	r16
    19ae:	1f 93       	push	r17
    19b0:	cf 93       	push	r28
    19b2:	df 93       	push	r29
    19b4:	00 d0       	rcall	.+0      	; 0x19b6 <xQueueGenericSend+0x14>
    19b6:	1f 92       	push	r1
    19b8:	1f 92       	push	r1
    19ba:	cd b7       	in	r28, 0x3d	; 61
    19bc:	de b7       	in	r29, 0x3e	; 62
    19be:	8c 01       	movw	r16, r24
    19c0:	6b 01       	movw	r12, r22
    19c2:	5d 83       	std	Y+5, r21	; 0x05
    19c4:	4c 83       	std	Y+4, r20	; 0x04
    19c6:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    19c8:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    19ca:	58 01       	movw	r10, r16
    19cc:	98 e0       	ldi	r25, 0x08	; 8
    19ce:	a9 0e       	add	r10, r25
    19d0:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19d2:	0f b6       	in	r0, 0x3f	; 63
    19d4:	f8 94       	cli
    19d6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19d8:	f8 01       	movw	r30, r16
    19da:	22 8d       	ldd	r18, Z+26	; 0x1a
    19dc:	93 8d       	ldd	r25, Z+27	; 0x1b
    19de:	29 17       	cp	r18, r25
    19e0:	18 f0       	brcs	.+6      	; 0x19e8 <xQueueGenericSend+0x46>
    19e2:	f2 e0       	ldi	r31, 0x02	; 2
    19e4:	ff 12       	cpse	r15, r31
    19e6:	14 c0       	rjmp	.+40     	; 0x1a10 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19e8:	4f 2d       	mov	r20, r15
    19ea:	b6 01       	movw	r22, r12
    19ec:	c8 01       	movw	r24, r16
    19ee:	0e 94 ca 0b 	call	0x1794	; 0x1794 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19f2:	f8 01       	movw	r30, r16
    19f4:	91 89       	ldd	r25, Z+17	; 0x11
    19f6:	99 23       	and	r25, r25
    19f8:	21 f0       	breq	.+8      	; 0x1a02 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19fa:	c8 01       	movw	r24, r16
    19fc:	41 96       	adiw	r24, 0x11	; 17
    19fe:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    1a02:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1a04:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1a08:	0f 90       	pop	r0
    1a0a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	50 c0       	rjmp	.+160    	; 0x1ab0 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a10:	2c 81       	ldd	r18, Y+4	; 0x04
    1a12:	3d 81       	ldd	r19, Y+5	; 0x05
    1a14:	23 2b       	or	r18, r19
    1a16:	19 f4       	brne	.+6      	; 0x1a1e <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a18:	0f 90       	pop	r0
    1a1a:	0f be       	out	0x3f, r0	; 63
    1a1c:	48 c0       	rjmp	.+144    	; 0x1aae <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1a1e:	81 11       	cpse	r24, r1
    1a20:	04 c0       	rjmp	.+8      	; 0x1a2a <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a22:	ce 01       	movw	r24, r28
    1a24:	01 96       	adiw	r24, 0x01	; 1
    1a26:	0e 94 4f 09 	call	0x129e	; 0x129e <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a2a:	0f 90       	pop	r0
    1a2c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a2e:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a32:	0f b6       	in	r0, 0x3f	; 63
    1a34:	f8 94       	cli
    1a36:	0f 92       	push	r0
    1a38:	f8 01       	movw	r30, r16
    1a3a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a3e:	09 f4       	brne	.+2      	; 0x1a42 <xQueueGenericSend+0xa0>
    1a40:	15 8e       	std	Z+29, r1	; 0x1d
    1a42:	f8 01       	movw	r30, r16
    1a44:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a46:	8f 3f       	cpi	r24, 0xFF	; 255
    1a48:	09 f4       	brne	.+2      	; 0x1a4c <xQueueGenericSend+0xaa>
    1a4a:	16 8e       	std	Z+30, r1	; 0x1e
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a50:	be 01       	movw	r22, r28
    1a52:	6c 5f       	subi	r22, 0xFC	; 252
    1a54:	7f 4f       	sbci	r23, 0xFF	; 255
    1a56:	ce 01       	movw	r24, r28
    1a58:	01 96       	adiw	r24, 0x01	; 1
    1a5a:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xTaskCheckForTimeOut>
    1a5e:	81 11       	cpse	r24, r1
    1a60:	21 c0       	rjmp	.+66     	; 0x1aa4 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a62:	0f b6       	in	r0, 0x3f	; 63
    1a64:	f8 94       	cli
    1a66:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a68:	f8 01       	movw	r30, r16
    1a6a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a6c:	83 8d       	ldd	r24, Z+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a6e:	0f 90       	pop	r0
    1a70:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a72:	98 13       	cpse	r25, r24
    1a74:	11 c0       	rjmp	.+34     	; 0x1a98 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1a76:	6c 81       	ldd	r22, Y+4	; 0x04
    1a78:	7d 81       	ldd	r23, Y+5	; 0x05
    1a7a:	c5 01       	movw	r24, r10
    1a7c:	0e 94 a6 08 	call	0x114c	; 0x114c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1a80:	c8 01       	movw	r24, r16
    1a82:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1a86:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
    1a8a:	88 23       	and	r24, r24
    1a8c:	11 f0       	breq	.+4      	; 0x1a92 <xQueueGenericSend+0xf0>
    1a8e:	81 e0       	ldi	r24, 0x01	; 1
    1a90:	a0 cf       	rjmp	.-192    	; 0x19d2 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1a92:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
    1a96:	fb cf       	rjmp	.-10     	; 0x1a8e <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a98:	c8 01       	movw	r24, r16
    1a9a:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a9e:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
    1aa2:	f5 cf       	rjmp	.-22     	; 0x1a8e <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1aa4:	c8 01       	movw	r24, r16
    1aa6:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1aaa:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1aae:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    1ab0:	0f 90       	pop	r0
    1ab2:	0f 90       	pop	r0
    1ab4:	0f 90       	pop	r0
    1ab6:	0f 90       	pop	r0
    1ab8:	0f 90       	pop	r0
    1aba:	df 91       	pop	r29
    1abc:	cf 91       	pop	r28
    1abe:	1f 91       	pop	r17
    1ac0:	0f 91       	pop	r16
    1ac2:	ff 90       	pop	r15
    1ac4:	df 90       	pop	r13
    1ac6:	cf 90       	pop	r12
    1ac8:	bf 90       	pop	r11
    1aca:	af 90       	pop	r10
    1acc:	08 95       	ret

00001ace <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1ace:	ef 92       	push	r14
    1ad0:	ff 92       	push	r15
    1ad2:	1f 93       	push	r17
    1ad4:	cf 93       	push	r28
    1ad6:	df 93       	push	r29
    1ad8:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1ada:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1adc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ade:	98 17       	cp	r25, r24
    1ae0:	10 f0       	brcs	.+4      	; 0x1ae6 <xQueueGenericSendFromISR+0x18>
    1ae2:	22 30       	cpi	r18, 0x02	; 2
    1ae4:	e1 f4       	brne	.+56     	; 0x1b1e <xQueueGenericSendFromISR+0x50>
    1ae6:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1ae8:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1aea:	42 2f       	mov	r20, r18
    1aec:	ce 01       	movw	r24, r28
    1aee:	0e 94 ca 0b 	call	0x1794	; 0x1794 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1af2:	1f 3f       	cpi	r17, 0xFF	; 255
    1af4:	81 f4       	brne	.+32     	; 0x1b16 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1af6:	89 89       	ldd	r24, Y+17	; 0x11
    1af8:	88 23       	and	r24, r24
    1afa:	79 f0       	breq	.+30     	; 0x1b1a <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1afc:	ce 01       	movw	r24, r28
    1afe:	41 96       	adiw	r24, 0x11	; 17
    1b00:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    1b04:	88 23       	and	r24, r24
    1b06:	49 f0       	breq	.+18     	; 0x1b1a <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1b08:	e1 14       	cp	r14, r1
    1b0a:	f1 04       	cpc	r15, r1
    1b0c:	31 f0       	breq	.+12     	; 0x1b1a <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1b0e:	81 e0       	ldi	r24, 0x01	; 1
    1b10:	f7 01       	movw	r30, r14
    1b12:	80 83       	st	Z, r24
    1b14:	05 c0       	rjmp	.+10     	; 0x1b20 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b16:	1f 5f       	subi	r17, 0xFF	; 255
    1b18:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1b1a:	81 e0       	ldi	r24, 0x01	; 1
    1b1c:	01 c0       	rjmp	.+2      	; 0x1b20 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b1e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b20:	df 91       	pop	r29
    1b22:	cf 91       	pop	r28
    1b24:	1f 91       	pop	r17
    1b26:	ff 90       	pop	r15
    1b28:	ef 90       	pop	r14
    1b2a:	08 95       	ret

00001b2c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1b2c:	cf 93       	push	r28
    1b2e:	df 93       	push	r29
    1b30:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b32:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1b34:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b36:	98 17       	cp	r25, r24
    1b38:	c0 f4       	brcc	.+48     	; 0x1b6a <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1b3a:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1b3c:	9f 5f       	subi	r25, 0xFF	; 255
    1b3e:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1b40:	8f 3f       	cpi	r24, 0xFF	; 255
    1b42:	79 f4       	brne	.+30     	; 0x1b62 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b44:	81 89       	ldd	r24, Z+17	; 0x11
    1b46:	88 23       	and	r24, r24
    1b48:	71 f0       	breq	.+28     	; 0x1b66 <xQueueGiveFromISR+0x3a>
    1b4a:	eb 01       	movw	r28, r22
    1b4c:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b4e:	41 96       	adiw	r24, 0x11	; 17
    1b50:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    1b54:	88 23       	and	r24, r24
    1b56:	39 f0       	breq	.+14     	; 0x1b66 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1b58:	20 97       	sbiw	r28, 0x00	; 0
    1b5a:	29 f0       	breq	.+10     	; 0x1b66 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
    1b5e:	88 83       	st	Y, r24
    1b60:	05 c0       	rjmp	.+10     	; 0x1b6c <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b62:	8f 5f       	subi	r24, 0xFF	; 255
    1b64:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1b66:	81 e0       	ldi	r24, 0x01	; 1
    1b68:	01 c0       	rjmp	.+2      	; 0x1b6c <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b6a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b6c:	df 91       	pop	r29
    1b6e:	cf 91       	pop	r28
    1b70:	08 95       	ret

00001b72 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1b72:	af 92       	push	r10
    1b74:	bf 92       	push	r11
    1b76:	cf 92       	push	r12
    1b78:	df 92       	push	r13
    1b7a:	ff 92       	push	r15
    1b7c:	0f 93       	push	r16
    1b7e:	1f 93       	push	r17
    1b80:	cf 93       	push	r28
    1b82:	df 93       	push	r29
    1b84:	00 d0       	rcall	.+0      	; 0x1b86 <xQueueReceive+0x14>
    1b86:	1f 92       	push	r1
    1b88:	1f 92       	push	r1
    1b8a:	cd b7       	in	r28, 0x3d	; 61
    1b8c:	de b7       	in	r29, 0x3e	; 62
    1b8e:	8c 01       	movw	r16, r24
    1b90:	6b 01       	movw	r12, r22
    1b92:	5d 83       	std	Y+5, r21	; 0x05
    1b94:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1b96:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b98:	58 01       	movw	r10, r16
    1b9a:	91 e1       	ldi	r25, 0x11	; 17
    1b9c:	a9 0e       	add	r10, r25
    1b9e:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1ba0:	0f b6       	in	r0, 0x3f	; 63
    1ba2:	f8 94       	cli
    1ba4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1ba6:	f8 01       	movw	r30, r16
    1ba8:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1baa:	ff 20       	and	r15, r15
    1bac:	a9 f0       	breq	.+42     	; 0x1bd8 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1bae:	b6 01       	movw	r22, r12
    1bb0:	c8 01       	movw	r24, r16
    1bb2:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1bb6:	fa 94       	dec	r15
    1bb8:	f8 01       	movw	r30, r16
    1bba:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1bbc:	80 85       	ldd	r24, Z+8	; 0x08
    1bbe:	88 23       	and	r24, r24
    1bc0:	39 f0       	breq	.+14     	; 0x1bd0 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bc2:	c8 01       	movw	r24, r16
    1bc4:	08 96       	adiw	r24, 0x08	; 8
    1bc6:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    1bca:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1bcc:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1bd0:	0f 90       	pop	r0
    1bd2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1bd4:	81 e0       	ldi	r24, 0x01	; 1
    1bd6:	50 c0       	rjmp	.+160    	; 0x1c78 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1bd8:	2c 81       	ldd	r18, Y+4	; 0x04
    1bda:	3d 81       	ldd	r19, Y+5	; 0x05
    1bdc:	23 2b       	or	r18, r19
    1bde:	19 f4       	brne	.+6      	; 0x1be6 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	48 c0       	rjmp	.+144    	; 0x1c76 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1be6:	81 11       	cpse	r24, r1
    1be8:	04 c0       	rjmp	.+8      	; 0x1bf2 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1bea:	ce 01       	movw	r24, r28
    1bec:	01 96       	adiw	r24, 0x01	; 1
    1bee:	0e 94 4f 09 	call	0x129e	; 0x129e <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1bf2:	0f 90       	pop	r0
    1bf4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1bf6:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1bfa:	0f b6       	in	r0, 0x3f	; 63
    1bfc:	f8 94       	cli
    1bfe:	0f 92       	push	r0
    1c00:	f8 01       	movw	r30, r16
    1c02:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c04:	8f 3f       	cpi	r24, 0xFF	; 255
    1c06:	09 f4       	brne	.+2      	; 0x1c0a <xQueueReceive+0x98>
    1c08:	15 8e       	std	Z+29, r1	; 0x1d
    1c0a:	f8 01       	movw	r30, r16
    1c0c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c10:	09 f4       	brne	.+2      	; 0x1c14 <xQueueReceive+0xa2>
    1c12:	16 8e       	std	Z+30, r1	; 0x1e
    1c14:	0f 90       	pop	r0
    1c16:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c18:	be 01       	movw	r22, r28
    1c1a:	6c 5f       	subi	r22, 0xFC	; 252
    1c1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c1e:	ce 01       	movw	r24, r28
    1c20:	01 96       	adiw	r24, 0x01	; 1
    1c22:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xTaskCheckForTimeOut>
    1c26:	81 11       	cpse	r24, r1
    1c28:	1c c0       	rjmp	.+56     	; 0x1c62 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c2a:	c8 01       	movw	r24, r16
    1c2c:	0e 94 bf 0b 	call	0x177e	; 0x177e <prvIsQueueEmpty>
    1c30:	88 23       	and	r24, r24
    1c32:	89 f0       	breq	.+34     	; 0x1c56 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c34:	6c 81       	ldd	r22, Y+4	; 0x04
    1c36:	7d 81       	ldd	r23, Y+5	; 0x05
    1c38:	c5 01       	movw	r24, r10
    1c3a:	0e 94 a6 08 	call	0x114c	; 0x114c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c3e:	c8 01       	movw	r24, r16
    1c40:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c44:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
    1c48:	88 23       	and	r24, r24
    1c4a:	11 f0       	breq	.+4      	; 0x1c50 <xQueueReceive+0xde>
    1c4c:	81 e0       	ldi	r24, 0x01	; 1
    1c4e:	a8 cf       	rjmp	.-176    	; 0x1ba0 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    1c50:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
    1c54:	fb cf       	rjmp	.-10     	; 0x1c4c <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1c56:	c8 01       	movw	r24, r16
    1c58:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c5c:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
    1c60:	f5 cf       	rjmp	.-22     	; 0x1c4c <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1c62:	c8 01       	movw	r24, r16
    1c64:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c68:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c6c:	c8 01       	movw	r24, r16
    1c6e:	0e 94 bf 0b 	call	0x177e	; 0x177e <prvIsQueueEmpty>
    1c72:	88 23       	and	r24, r24
    1c74:	59 f3       	breq	.-42     	; 0x1c4c <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1c76:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1c78:	0f 90       	pop	r0
    1c7a:	0f 90       	pop	r0
    1c7c:	0f 90       	pop	r0
    1c7e:	0f 90       	pop	r0
    1c80:	0f 90       	pop	r0
    1c82:	df 91       	pop	r29
    1c84:	cf 91       	pop	r28
    1c86:	1f 91       	pop	r17
    1c88:	0f 91       	pop	r16
    1c8a:	ff 90       	pop	r15
    1c8c:	df 90       	pop	r13
    1c8e:	cf 90       	pop	r12
    1c90:	bf 90       	pop	r11
    1c92:	af 90       	pop	r10
    1c94:	08 95       	ret

00001c96 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1c96:	ef 92       	push	r14
    1c98:	ff 92       	push	r15
    1c9a:	0f 93       	push	r16
    1c9c:	1f 93       	push	r17
    1c9e:	cf 93       	push	r28
    1ca0:	df 93       	push	r29
    1ca2:	00 d0       	rcall	.+0      	; 0x1ca4 <xQueueSemaphoreTake+0xe>
    1ca4:	1f 92       	push	r1
    1ca6:	1f 92       	push	r1
    1ca8:	cd b7       	in	r28, 0x3d	; 61
    1caa:	de b7       	in	r29, 0x3e	; 62
    1cac:	8c 01       	movw	r16, r24
    1cae:	7d 83       	std	Y+5, r23	; 0x05
    1cb0:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1cb4:	78 01       	movw	r14, r16
    1cb6:	81 e1       	ldi	r24, 0x11	; 17
    1cb8:	e8 0e       	add	r14, r24
    1cba:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1cbc:	0f b6       	in	r0, 0x3f	; 63
    1cbe:	f8 94       	cli
    1cc0:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1cc2:	f8 01       	movw	r30, r16
    1cc4:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1cc6:	88 23       	and	r24, r24
    1cc8:	81 f0       	breq	.+32     	; 0x1cea <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1cca:	81 50       	subi	r24, 0x01	; 1
    1ccc:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1cce:	80 85       	ldd	r24, Z+8	; 0x08
    1cd0:	88 23       	and	r24, r24
    1cd2:	39 f0       	breq	.+14     	; 0x1ce2 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cd4:	c8 01       	movw	r24, r16
    1cd6:	08 96       	adiw	r24, 0x08	; 8
    1cd8:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    1cdc:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1cde:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1ce2:	0f 90       	pop	r0
    1ce4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1ce6:	81 e0       	ldi	r24, 0x01	; 1
    1ce8:	50 c0       	rjmp	.+160    	; 0x1d8a <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1cea:	2c 81       	ldd	r18, Y+4	; 0x04
    1cec:	3d 81       	ldd	r19, Y+5	; 0x05
    1cee:	23 2b       	or	r18, r19
    1cf0:	19 f4       	brne	.+6      	; 0x1cf8 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1cf2:	0f 90       	pop	r0
    1cf4:	0f be       	out	0x3f, r0	; 63
    1cf6:	48 c0       	rjmp	.+144    	; 0x1d88 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1cf8:	91 11       	cpse	r25, r1
    1cfa:	04 c0       	rjmp	.+8      	; 0x1d04 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1cfc:	ce 01       	movw	r24, r28
    1cfe:	01 96       	adiw	r24, 0x01	; 1
    1d00:	0e 94 4f 09 	call	0x129e	; 0x129e <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1d04:	0f 90       	pop	r0
    1d06:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d08:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d0c:	0f b6       	in	r0, 0x3f	; 63
    1d0e:	f8 94       	cli
    1d10:	0f 92       	push	r0
    1d12:	f8 01       	movw	r30, r16
    1d14:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d16:	8f 3f       	cpi	r24, 0xFF	; 255
    1d18:	09 f4       	brne	.+2      	; 0x1d1c <xQueueSemaphoreTake+0x86>
    1d1a:	15 8e       	std	Z+29, r1	; 0x1d
    1d1c:	f8 01       	movw	r30, r16
    1d1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d20:	8f 3f       	cpi	r24, 0xFF	; 255
    1d22:	09 f4       	brne	.+2      	; 0x1d26 <xQueueSemaphoreTake+0x90>
    1d24:	16 8e       	std	Z+30, r1	; 0x1e
    1d26:	0f 90       	pop	r0
    1d28:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d2a:	be 01       	movw	r22, r28
    1d2c:	6c 5f       	subi	r22, 0xFC	; 252
    1d2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d30:	ce 01       	movw	r24, r28
    1d32:	01 96       	adiw	r24, 0x01	; 1
    1d34:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xTaskCheckForTimeOut>
    1d38:	81 11       	cpse	r24, r1
    1d3a:	1c c0       	rjmp	.+56     	; 0x1d74 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d3c:	c8 01       	movw	r24, r16
    1d3e:	0e 94 bf 0b 	call	0x177e	; 0x177e <prvIsQueueEmpty>
    1d42:	88 23       	and	r24, r24
    1d44:	89 f0       	breq	.+34     	; 0x1d68 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d46:	6c 81       	ldd	r22, Y+4	; 0x04
    1d48:	7d 81       	ldd	r23, Y+5	; 0x05
    1d4a:	c7 01       	movw	r24, r14
    1d4c:	0e 94 a6 08 	call	0x114c	; 0x114c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1d50:	c8 01       	movw	r24, r16
    1d52:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d56:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
    1d5a:	88 23       	and	r24, r24
    1d5c:	11 f0       	breq	.+4      	; 0x1d62 <xQueueSemaphoreTake+0xcc>
    1d5e:	91 e0       	ldi	r25, 0x01	; 1
    1d60:	ad cf       	rjmp	.-166    	; 0x1cbc <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1d62:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
    1d66:	fb cf       	rjmp	.-10     	; 0x1d5e <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1d68:	c8 01       	movw	r24, r16
    1d6a:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d6e:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
    1d72:	f5 cf       	rjmp	.-22     	; 0x1d5e <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1d74:	c8 01       	movw	r24, r16
    1d76:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d7a:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d7e:	c8 01       	movw	r24, r16
    1d80:	0e 94 bf 0b 	call	0x177e	; 0x177e <prvIsQueueEmpty>
    1d84:	88 23       	and	r24, r24
    1d86:	59 f3       	breq	.-42     	; 0x1d5e <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1d88:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1d8a:	0f 90       	pop	r0
    1d8c:	0f 90       	pop	r0
    1d8e:	0f 90       	pop	r0
    1d90:	0f 90       	pop	r0
    1d92:	0f 90       	pop	r0
    1d94:	df 91       	pop	r29
    1d96:	cf 91       	pop	r28
    1d98:	1f 91       	pop	r17
    1d9a:	0f 91       	pop	r16
    1d9c:	ff 90       	pop	r15
    1d9e:	ef 90       	pop	r14
    1da0:	08 95       	ret

00001da2 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1da2:	cf 92       	push	r12
    1da4:	df 92       	push	r13
    1da6:	ef 92       	push	r14
    1da8:	ff 92       	push	r15
    1daa:	0f 93       	push	r16
    1dac:	1f 93       	push	r17
    1dae:	cf 93       	push	r28
    1db0:	df 93       	push	r29
    1db2:	00 d0       	rcall	.+0      	; 0x1db4 <xQueuePeek+0x12>
    1db4:	1f 92       	push	r1
    1db6:	1f 92       	push	r1
    1db8:	cd b7       	in	r28, 0x3d	; 61
    1dba:	de b7       	in	r29, 0x3e	; 62
    1dbc:	8c 01       	movw	r16, r24
    1dbe:	7b 01       	movw	r14, r22
    1dc0:	5d 83       	std	Y+5, r21	; 0x05
    1dc2:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1dc4:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1dc6:	68 01       	movw	r12, r16
    1dc8:	91 e1       	ldi	r25, 0x11	; 17
    1dca:	c9 0e       	add	r12, r25
    1dcc:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1dce:	0f b6       	in	r0, 0x3f	; 63
    1dd0:	f8 94       	cli
    1dd2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1dd4:	f8 01       	movw	r30, r16
    1dd6:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1dd8:	99 23       	and	r25, r25
    1dda:	b9 f0       	breq	.+46     	; 0x1e0a <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1ddc:	c6 80       	ldd	r12, Z+6	; 0x06
    1dde:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1de0:	b7 01       	movw	r22, r14
    1de2:	c8 01       	movw	r24, r16
    1de4:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1de8:	f8 01       	movw	r30, r16
    1dea:	d7 82       	std	Z+7, r13	; 0x07
    1dec:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1dee:	81 89       	ldd	r24, Z+17	; 0x11
    1df0:	88 23       	and	r24, r24
    1df2:	39 f0       	breq	.+14     	; 0x1e02 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1df4:	c8 01       	movw	r24, r16
    1df6:	41 96       	adiw	r24, 0x11	; 17
    1df8:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    1dfc:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1dfe:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1e02:	0f 90       	pop	r0
    1e04:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e06:	81 e0       	ldi	r24, 0x01	; 1
    1e08:	50 c0       	rjmp	.+160    	; 0x1eaa <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e0a:	2c 81       	ldd	r18, Y+4	; 0x04
    1e0c:	3d 81       	ldd	r19, Y+5	; 0x05
    1e0e:	23 2b       	or	r18, r19
    1e10:	19 f4       	brne	.+6      	; 0x1e18 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e12:	0f 90       	pop	r0
    1e14:	0f be       	out	0x3f, r0	; 63
    1e16:	48 c0       	rjmp	.+144    	; 0x1ea8 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1e18:	81 11       	cpse	r24, r1
    1e1a:	04 c0       	rjmp	.+8      	; 0x1e24 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1e1c:	ce 01       	movw	r24, r28
    1e1e:	01 96       	adiw	r24, 0x01	; 1
    1e20:	0e 94 4f 09 	call	0x129e	; 0x129e <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e24:	0f 90       	pop	r0
    1e26:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e28:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e2c:	0f b6       	in	r0, 0x3f	; 63
    1e2e:	f8 94       	cli
    1e30:	0f 92       	push	r0
    1e32:	f8 01       	movw	r30, r16
    1e34:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e36:	8f 3f       	cpi	r24, 0xFF	; 255
    1e38:	09 f4       	brne	.+2      	; 0x1e3c <xQueuePeek+0x9a>
    1e3a:	15 8e       	std	Z+29, r1	; 0x1d
    1e3c:	f8 01       	movw	r30, r16
    1e3e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e40:	8f 3f       	cpi	r24, 0xFF	; 255
    1e42:	09 f4       	brne	.+2      	; 0x1e46 <xQueuePeek+0xa4>
    1e44:	16 8e       	std	Z+30, r1	; 0x1e
    1e46:	0f 90       	pop	r0
    1e48:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e4a:	be 01       	movw	r22, r28
    1e4c:	6c 5f       	subi	r22, 0xFC	; 252
    1e4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e50:	ce 01       	movw	r24, r28
    1e52:	01 96       	adiw	r24, 0x01	; 1
    1e54:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xTaskCheckForTimeOut>
    1e58:	81 11       	cpse	r24, r1
    1e5a:	1c c0       	rjmp	.+56     	; 0x1e94 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e5c:	c8 01       	movw	r24, r16
    1e5e:	0e 94 bf 0b 	call	0x177e	; 0x177e <prvIsQueueEmpty>
    1e62:	88 23       	and	r24, r24
    1e64:	89 f0       	breq	.+34     	; 0x1e88 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e66:	6c 81       	ldd	r22, Y+4	; 0x04
    1e68:	7d 81       	ldd	r23, Y+5	; 0x05
    1e6a:	c6 01       	movw	r24, r12
    1e6c:	0e 94 a6 08 	call	0x114c	; 0x114c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1e70:	c8 01       	movw	r24, r16
    1e72:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1e76:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
    1e7a:	88 23       	and	r24, r24
    1e7c:	11 f0       	breq	.+4      	; 0x1e82 <xQueuePeek+0xe0>
    1e7e:	81 e0       	ldi	r24, 0x01	; 1
    1e80:	a6 cf       	rjmp	.-180    	; 0x1dce <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1e82:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <vPortYield>
    1e86:	fb cf       	rjmp	.-10     	; 0x1e7e <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1e88:	c8 01       	movw	r24, r16
    1e8a:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1e8e:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
    1e92:	f5 cf       	rjmp	.-22     	; 0x1e7e <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1e94:	c8 01       	movw	r24, r16
    1e96:	0e 94 2c 0c 	call	0x1858	; 0x1858 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1e9a:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e9e:	c8 01       	movw	r24, r16
    1ea0:	0e 94 bf 0b 	call	0x177e	; 0x177e <prvIsQueueEmpty>
    1ea4:	88 23       	and	r24, r24
    1ea6:	59 f3       	breq	.-42     	; 0x1e7e <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ea8:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1eaa:	0f 90       	pop	r0
    1eac:	0f 90       	pop	r0
    1eae:	0f 90       	pop	r0
    1eb0:	0f 90       	pop	r0
    1eb2:	0f 90       	pop	r0
    1eb4:	df 91       	pop	r29
    1eb6:	cf 91       	pop	r28
    1eb8:	1f 91       	pop	r17
    1eba:	0f 91       	pop	r16
    1ebc:	ff 90       	pop	r15
    1ebe:	ef 90       	pop	r14
    1ec0:	df 90       	pop	r13
    1ec2:	cf 90       	pop	r12
    1ec4:	08 95       	ret

00001ec6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1ec6:	ef 92       	push	r14
    1ec8:	ff 92       	push	r15
    1eca:	0f 93       	push	r16
    1ecc:	1f 93       	push	r17
    1ece:	cf 93       	push	r28
    1ed0:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1ed2:	fc 01       	movw	r30, r24
    1ed4:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ed6:	00 23       	and	r16, r16
    1ed8:	e9 f0       	breq	.+58     	; 0x1f14 <xQueueReceiveFromISR+0x4e>
    1eda:	7a 01       	movw	r14, r20
    1edc:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1ede:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ee0:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1ee4:	01 50       	subi	r16, 0x01	; 1
    1ee6:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1ee8:	1f 3f       	cpi	r17, 0xFF	; 255
    1eea:	81 f4       	brne	.+32     	; 0x1f0c <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1eec:	88 85       	ldd	r24, Y+8	; 0x08
    1eee:	88 23       	and	r24, r24
    1ef0:	79 f0       	breq	.+30     	; 0x1f10 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ef2:	ce 01       	movw	r24, r28
    1ef4:	08 96       	adiw	r24, 0x08	; 8
    1ef6:	0e 94 cd 08 	call	0x119a	; 0x119a <xTaskRemoveFromEventList>
    1efa:	88 23       	and	r24, r24
    1efc:	49 f0       	breq	.+18     	; 0x1f10 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1efe:	e1 14       	cp	r14, r1
    1f00:	f1 04       	cpc	r15, r1
    1f02:	31 f0       	breq	.+12     	; 0x1f10 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1f04:	81 e0       	ldi	r24, 0x01	; 1
    1f06:	f7 01       	movw	r30, r14
    1f08:	80 83       	st	Z, r24
    1f0a:	05 c0       	rjmp	.+10     	; 0x1f16 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1f0c:	1f 5f       	subi	r17, 0xFF	; 255
    1f0e:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1f10:	81 e0       	ldi	r24, 0x01	; 1
    1f12:	01 c0       	rjmp	.+2      	; 0x1f16 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1f14:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f16:	df 91       	pop	r29
    1f18:	cf 91       	pop	r28
    1f1a:	1f 91       	pop	r17
    1f1c:	0f 91       	pop	r16
    1f1e:	ff 90       	pop	r15
    1f20:	ef 90       	pop	r14
    1f22:	08 95       	ret

00001f24 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1f24:	0f 93       	push	r16
    1f26:	1f 93       	push	r17
    1f28:	cf 93       	push	r28
    1f2a:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f2c:	fc 01       	movw	r30, r24
    1f2e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1f30:	22 23       	and	r18, r18
    1f32:	49 f0       	breq	.+18     	; 0x1f46 <xQueuePeekFromISR+0x22>
    1f34:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1f36:	06 81       	ldd	r16, Z+6	; 0x06
    1f38:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f3a:	0e 94 12 0c 	call	0x1824	; 0x1824 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1f3e:	1f 83       	std	Y+7, r17	; 0x07
    1f40:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	01 c0       	rjmp	.+2      	; 0x1f48 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1f46:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f48:	df 91       	pop	r29
    1f4a:	cf 91       	pop	r28
    1f4c:	1f 91       	pop	r17
    1f4e:	0f 91       	pop	r16
    1f50:	08 95       	ret

00001f52 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1f52:	0f b6       	in	r0, 0x3f	; 63
    1f54:	f8 94       	cli
    1f56:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1f58:	fc 01       	movw	r30, r24
    1f5a:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1f5c:	0f 90       	pop	r0
    1f5e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1f60:	08 95       	ret

00001f62 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1f62:	0f b6       	in	r0, 0x3f	; 63
    1f64:	f8 94       	cli
    1f66:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1f68:	fc 01       	movw	r30, r24
    1f6a:	22 8d       	ldd	r18, Z+26	; 0x1a
    1f6c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f6e:	82 1b       	sub	r24, r18
	}
	taskEXIT_CRITICAL();
    1f70:	0f 90       	pop	r0
    1f72:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1f74:	08 95       	ret

00001f76 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1f76:	fc 01       	movw	r30, r24
    1f78:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1f7a:	08 95       	ret

00001f7c <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1f7c:	0c 94 32 13 	jmp	0x2664	; 0x2664 <vPortFree>

00001f80 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1f80:	fc 01       	movw	r30, r24
    1f82:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1f84:	81 e0       	ldi	r24, 0x01	; 1
    1f86:	91 11       	cpse	r25, r1
    1f88:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1f8a:	08 95       	ret

00001f8c <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1f8c:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f8e:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1f90:	81 e0       	ldi	r24, 0x01	; 1
    1f92:	23 8d       	ldd	r18, Z+27	; 0x1b
    1f94:	29 13       	cpse	r18, r25
    1f96:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1f98:	08 95       	ret

00001f9a <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1f9a:	cf 93       	push	r28
    1f9c:	df 93       	push	r29
    1f9e:	ec 01       	movw	r28, r24
    1fa0:	ca 01       	movw	r24, r20
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1fa2:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1fa4:	0f b6       	in	r0, 0x3f	; 63
    1fa6:	f8 94       	cli
    1fa8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1faa:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1fac:	2b 8d       	ldd	r18, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1fae:	0f 90       	pop	r0
    1fb0:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1fb2:	32 13       	cpse	r19, r18
    1fb4:	0d c0       	rjmp	.+26     	; 0x1fd0 <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1fb6:	00 97       	sbiw	r24, 0x00	; 0
    1fb8:	41 f0       	breq	.+16     	; 0x1fca <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1fba:	be 01       	movw	r22, r28
    1fbc:	68 5f       	subi	r22, 0xF8	; 248
    1fbe:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc0:	0e 94 ac 11 	call	0x2358	; 0x2358 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1fc4:	78 94       	sei
					return errQUEUE_BLOCKED;
    1fc6:	8c ef       	ldi	r24, 0xFC	; 252
    1fc8:	1c c0       	rjmp	.+56     	; 0x2002 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1fca:	78 94       	sei
					return errQUEUE_FULL;
    1fcc:	80 e0       	ldi	r24, 0x00	; 0
    1fce:	19 c0       	rjmp	.+50     	; 0x2002 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1fd0:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1fd2:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1fd4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1fd6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1fd8:	98 17       	cp	r25, r24
    1fda:	88 f4       	brcc	.+34     	; 0x1ffe <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1fdc:	40 e0       	ldi	r20, 0x00	; 0
    1fde:	ce 01       	movw	r24, r28
    1fe0:	0e 94 ca 0b 	call	0x1794	; 0x1794 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1fe4:	89 89       	ldd	r24, Y+17	; 0x11
    1fe6:	81 11       	cpse	r24, r1
    1fe8:	02 c0       	rjmp	.+4      	; 0x1fee <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	09 c0       	rjmp	.+18     	; 0x2000 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1fee:	ce 01       	movw	r24, r28
    1ff0:	41 96       	adiw	r24, 0x11	; 17
    1ff2:	0e 94 db 12 	call	0x25b6	; 0x25b6 <xCoRoutineRemoveFromEventList>
    1ff6:	88 23       	and	r24, r24
    1ff8:	c1 f3       	breq	.-16     	; 0x1fea <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1ffa:	8b ef       	ldi	r24, 0xFB	; 251
    1ffc:	01 c0       	rjmp	.+2      	; 0x2000 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1ffe:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    2000:	78 94       	sei

		return xReturn;
	}
    2002:	df 91       	pop	r29
    2004:	cf 91       	pop	r28
    2006:	08 95       	ret

00002008 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    2008:	cf 93       	push	r28
    200a:	df 93       	push	r29
    200c:	ec 01       	movw	r28, r24
    200e:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2010:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2012:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2014:	81 11       	cpse	r24, r1
    2016:	0f c0       	rjmp	.+30     	; 0x2036 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2018:	41 15       	cp	r20, r1
    201a:	51 05       	cpc	r21, r1
    201c:	49 f0       	breq	.+18     	; 0x2030 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    201e:	be 01       	movw	r22, r28
    2020:	6f 5e       	subi	r22, 0xEF	; 239
    2022:	7f 4f       	sbci	r23, 0xFF	; 255
    2024:	ca 01       	movw	r24, r20
    2026:	0e 94 ac 11 	call	0x2358	; 0x2358 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    202a:	78 94       	sei
					return errQUEUE_BLOCKED;
    202c:	8c ef       	ldi	r24, 0xFC	; 252
    202e:	30 c0       	rjmp	.+96     	; 0x2090 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    2030:	78 94       	sei
					return errQUEUE_FULL;
    2032:	80 e0       	ldi	r24, 0x00	; 0
    2034:	2d c0       	rjmp	.+90     	; 0x2090 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    2036:	78 94       	sei

		portDISABLE_INTERRUPTS();
    2038:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    203a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    203c:	88 23       	and	r24, r24
    203e:	31 f1       	breq	.+76     	; 0x208c <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2040:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2042:	50 e0       	ldi	r21, 0x00	; 0
    2044:	2e 81       	ldd	r18, Y+6	; 0x06
    2046:	3f 81       	ldd	r19, Y+7	; 0x07
    2048:	24 0f       	add	r18, r20
    204a:	35 1f       	adc	r19, r21
    204c:	3f 83       	std	Y+7, r19	; 0x07
    204e:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2050:	8c 81       	ldd	r24, Y+4	; 0x04
    2052:	9d 81       	ldd	r25, Y+5	; 0x05
    2054:	28 17       	cp	r18, r24
    2056:	39 07       	cpc	r19, r25
    2058:	20 f0       	brcs	.+8      	; 0x2062 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    205a:	88 81       	ld	r24, Y
    205c:	99 81       	ldd	r25, Y+1	; 0x01
    205e:	9f 83       	std	Y+7, r25	; 0x07
    2060:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    2062:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2064:	91 50       	subi	r25, 0x01	; 1
    2066:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2068:	6e 81       	ldd	r22, Y+6	; 0x06
    206a:	7f 81       	ldd	r23, Y+7	; 0x07
    206c:	cf 01       	movw	r24, r30
    206e:	0e 94 0a 17 	call	0x2e14	; 0x2e14 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2072:	88 85       	ldd	r24, Y+8	; 0x08
    2074:	81 11       	cpse	r24, r1
    2076:	02 c0       	rjmp	.+4      	; 0x207c <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    2078:	81 e0       	ldi	r24, 0x01	; 1
    207a:	09 c0       	rjmp	.+18     	; 0x208e <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    207c:	ce 01       	movw	r24, r28
    207e:	08 96       	adiw	r24, 0x08	; 8
    2080:	0e 94 db 12 	call	0x25b6	; 0x25b6 <xCoRoutineRemoveFromEventList>
    2084:	88 23       	and	r24, r24
    2086:	c1 f3       	breq	.-16     	; 0x2078 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    2088:	8b ef       	ldi	r24, 0xFB	; 251
    208a:	01 c0       	rjmp	.+2      	; 0x208e <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    208c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    208e:	78 94       	sei

		return xReturn;
	}
    2090:	df 91       	pop	r29
    2092:	cf 91       	pop	r28
    2094:	08 95       	ret

00002096 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    2096:	0f 93       	push	r16
    2098:	1f 93       	push	r17
    209a:	cf 93       	push	r28
    209c:	8c 01       	movw	r16, r24
    209e:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    20a0:	fc 01       	movw	r30, r24
    20a2:	92 8d       	ldd	r25, Z+26	; 0x1a
    20a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    20a6:	98 17       	cp	r25, r24
    20a8:	10 f0       	brcs	.+4      	; 0x20ae <xQueueCRSendFromISR+0x18>
    20aa:	4c 2f       	mov	r20, r28
    20ac:	12 c0       	rjmp	.+36     	; 0x20d2 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    20ae:	40 e0       	ldi	r20, 0x00	; 0
    20b0:	c8 01       	movw	r24, r16
    20b2:	0e 94 ca 0b 	call	0x1794	; 0x1794 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    20b6:	c1 11       	cpse	r28, r1
    20b8:	f8 cf       	rjmp	.-16     	; 0x20aa <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20ba:	f8 01       	movw	r30, r16
    20bc:	81 89       	ldd	r24, Z+17	; 0x11
    20be:	88 23       	and	r24, r24
    20c0:	39 f0       	breq	.+14     	; 0x20d0 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20c2:	c8 01       	movw	r24, r16
    20c4:	41 96       	adiw	r24, 0x11	; 17
    20c6:	0e 94 db 12 	call	0x25b6	; 0x25b6 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    20ca:	41 e0       	ldi	r20, 0x01	; 1
    20cc:	81 11       	cpse	r24, r1
    20ce:	01 c0       	rjmp	.+2      	; 0x20d2 <xQueueCRSendFromISR+0x3c>
    20d0:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    20d2:	84 2f       	mov	r24, r20
    20d4:	cf 91       	pop	r28
    20d6:	1f 91       	pop	r17
    20d8:	0f 91       	pop	r16
    20da:	08 95       	ret

000020dc <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    20dc:	0f 93       	push	r16
    20de:	1f 93       	push	r17
    20e0:	cf 93       	push	r28
    20e2:	df 93       	push	r29
    20e4:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    20e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    20e8:	88 23       	and	r24, r24
    20ea:	79 f1       	breq	.+94     	; 0x214a <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    20ec:	24 8d       	ldd	r18, Z+28	; 0x1c
    20ee:	30 e0       	ldi	r19, 0x00	; 0
    20f0:	a6 81       	ldd	r26, Z+6	; 0x06
    20f2:	b7 81       	ldd	r27, Z+7	; 0x07
    20f4:	a2 0f       	add	r26, r18
    20f6:	b3 1f       	adc	r27, r19
    20f8:	b7 83       	std	Z+7, r27	; 0x07
    20fa:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    20fc:	84 81       	ldd	r24, Z+4	; 0x04
    20fe:	95 81       	ldd	r25, Z+5	; 0x05
    2100:	a8 17       	cp	r26, r24
    2102:	b9 07       	cpc	r27, r25
    2104:	20 f0       	brcs	.+8      	; 0x210e <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2106:	80 81       	ld	r24, Z
    2108:	91 81       	ldd	r25, Z+1	; 0x01
    210a:	97 83       	std	Z+7, r25	; 0x07
    210c:	86 83       	std	Z+6, r24	; 0x06
    210e:	8a 01       	movw	r16, r20
    2110:	cb 01       	movw	r24, r22
    2112:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    2114:	42 8d       	ldd	r20, Z+26	; 0x1a
    2116:	41 50       	subi	r20, 0x01	; 1
    2118:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    211a:	66 81       	ldd	r22, Z+6	; 0x06
    211c:	77 81       	ldd	r23, Z+7	; 0x07
    211e:	a9 01       	movw	r20, r18
    2120:	0e 94 0a 17 	call	0x2e14	; 0x2e14 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    2124:	f8 01       	movw	r30, r16
    2126:	80 81       	ld	r24, Z
    2128:	88 23       	and	r24, r24
    212a:	11 f0       	breq	.+4      	; 0x2130 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    212c:	81 e0       	ldi	r24, 0x01	; 1
    212e:	0e c0       	rjmp	.+28     	; 0x214c <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2130:	88 85       	ldd	r24, Y+8	; 0x08
    2132:	88 23       	and	r24, r24
    2134:	d9 f3       	breq	.-10     	; 0x212c <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2136:	ce 01       	movw	r24, r28
    2138:	08 96       	adiw	r24, 0x08	; 8
    213a:	0e 94 db 12 	call	0x25b6	; 0x25b6 <xCoRoutineRemoveFromEventList>
    213e:	88 23       	and	r24, r24
    2140:	a9 f3       	breq	.-22     	; 0x212c <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    2142:	81 e0       	ldi	r24, 0x01	; 1
    2144:	f8 01       	movw	r30, r16
    2146:	80 83       	st	Z, r24
    2148:	01 c0       	rjmp	.+2      	; 0x214c <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    214a:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    214c:	df 91       	pop	r29
    214e:	cf 91       	pop	r28
    2150:	1f 91       	pop	r17
    2152:	0f 91       	pop	r16
    2154:	08 95       	ret

00002156 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2156:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2158:	03 96       	adiw	r24, 0x03	; 3
    215a:	92 83       	std	Z+2, r25	; 0x02
    215c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    215e:	2f ef       	ldi	r18, 0xFF	; 255
    2160:	3f ef       	ldi	r19, 0xFF	; 255
    2162:	34 83       	std	Z+4, r19	; 0x04
    2164:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2166:	96 83       	std	Z+6, r25	; 0x06
    2168:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    216a:	90 87       	std	Z+8, r25	; 0x08
    216c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    216e:	10 82       	st	Z, r1
    2170:	08 95       	ret

00002172 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    2172:	fc 01       	movw	r30, r24
    2174:	11 86       	std	Z+9, r1	; 0x09
    2176:	10 86       	std	Z+8, r1	; 0x08
    2178:	08 95       	ret

0000217a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    217a:	cf 93       	push	r28
    217c:	df 93       	push	r29
    217e:	9c 01       	movw	r18, r24
    2180:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2182:	dc 01       	movw	r26, r24
    2184:	11 96       	adiw	r26, 0x01	; 1
    2186:	cd 91       	ld	r28, X+
    2188:	dc 91       	ld	r29, X
    218a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    218c:	d3 83       	std	Z+3, r29	; 0x03
    218e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2190:	8c 81       	ldd	r24, Y+4	; 0x04
    2192:	9d 81       	ldd	r25, Y+5	; 0x05
    2194:	95 83       	std	Z+5, r25	; 0x05
    2196:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2198:	8c 81       	ldd	r24, Y+4	; 0x04
    219a:	9d 81       	ldd	r25, Y+5	; 0x05
    219c:	dc 01       	movw	r26, r24
    219e:	13 96       	adiw	r26, 0x03	; 3
    21a0:	7c 93       	st	X, r23
    21a2:	6e 93       	st	-X, r22
    21a4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    21a6:	7d 83       	std	Y+5, r23	; 0x05
    21a8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    21aa:	31 87       	std	Z+9, r19	; 0x09
    21ac:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    21ae:	f9 01       	movw	r30, r18
    21b0:	80 81       	ld	r24, Z
    21b2:	8f 5f       	subi	r24, 0xFF	; 255
    21b4:	80 83       	st	Z, r24
}
    21b6:	df 91       	pop	r29
    21b8:	cf 91       	pop	r28
    21ba:	08 95       	ret

000021bc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    21bc:	0f 93       	push	r16
    21be:	1f 93       	push	r17
    21c0:	cf 93       	push	r28
    21c2:	df 93       	push	r29
    21c4:	8c 01       	movw	r16, r24
    21c6:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    21c8:	80 81       	ld	r24, Z
    21ca:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    21cc:	8f 3f       	cpi	r24, 0xFF	; 255
    21ce:	2f ef       	ldi	r18, 0xFF	; 255
    21d0:	92 07       	cpc	r25, r18
    21d2:	21 f4       	brne	.+8      	; 0x21dc <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    21d4:	e8 01       	movw	r28, r16
    21d6:	af 81       	ldd	r26, Y+7	; 0x07
    21d8:	b8 85       	ldd	r27, Y+8	; 0x08
    21da:	0e c0       	rjmp	.+28     	; 0x21f8 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    21dc:	d8 01       	movw	r26, r16
    21de:	13 96       	adiw	r26, 0x03	; 3
    21e0:	12 96       	adiw	r26, 0x02	; 2
    21e2:	2d 91       	ld	r18, X+
    21e4:	3c 91       	ld	r19, X
    21e6:	13 97       	sbiw	r26, 0x03	; 3
    21e8:	e9 01       	movw	r28, r18
    21ea:	48 81       	ld	r20, Y
    21ec:	59 81       	ldd	r21, Y+1	; 0x01
    21ee:	84 17       	cp	r24, r20
    21f0:	95 07       	cpc	r25, r21
    21f2:	10 f0       	brcs	.+4      	; 0x21f8 <vListInsert+0x3c>
    21f4:	d9 01       	movw	r26, r18
    21f6:	f4 cf       	rjmp	.-24     	; 0x21e0 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    21f8:	12 96       	adiw	r26, 0x02	; 2
    21fa:	8d 91       	ld	r24, X+
    21fc:	9c 91       	ld	r25, X
    21fe:	13 97       	sbiw	r26, 0x03	; 3
    2200:	93 83       	std	Z+3, r25	; 0x03
    2202:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2204:	ec 01       	movw	r28, r24
    2206:	fd 83       	std	Y+5, r31	; 0x05
    2208:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    220a:	b5 83       	std	Z+5, r27	; 0x05
    220c:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    220e:	13 96       	adiw	r26, 0x03	; 3
    2210:	fc 93       	st	X, r31
    2212:	ee 93       	st	-X, r30
    2214:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2216:	11 87       	std	Z+9, r17	; 0x09
    2218:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    221a:	f8 01       	movw	r30, r16
    221c:	80 81       	ld	r24, Z
    221e:	8f 5f       	subi	r24, 0xFF	; 255
    2220:	80 83       	st	Z, r24
}
    2222:	df 91       	pop	r29
    2224:	cf 91       	pop	r28
    2226:	1f 91       	pop	r17
    2228:	0f 91       	pop	r16
    222a:	08 95       	ret

0000222c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    222c:	cf 93       	push	r28
    222e:	df 93       	push	r29
    2230:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2232:	a0 85       	ldd	r26, Z+8	; 0x08
    2234:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2236:	82 81       	ldd	r24, Z+2	; 0x02
    2238:	93 81       	ldd	r25, Z+3	; 0x03
    223a:	24 81       	ldd	r18, Z+4	; 0x04
    223c:	35 81       	ldd	r19, Z+5	; 0x05
    223e:	ec 01       	movw	r28, r24
    2240:	3d 83       	std	Y+5, r19	; 0x05
    2242:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2244:	c4 81       	ldd	r28, Z+4	; 0x04
    2246:	d5 81       	ldd	r29, Z+5	; 0x05
    2248:	9b 83       	std	Y+3, r25	; 0x03
    224a:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    224c:	11 96       	adiw	r26, 0x01	; 1
    224e:	8d 91       	ld	r24, X+
    2250:	9c 91       	ld	r25, X
    2252:	12 97       	sbiw	r26, 0x02	; 2
    2254:	e8 17       	cp	r30, r24
    2256:	f9 07       	cpc	r31, r25
    2258:	21 f4       	brne	.+8      	; 0x2262 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    225a:	12 96       	adiw	r26, 0x02	; 2
    225c:	dc 93       	st	X, r29
    225e:	ce 93       	st	-X, r28
    2260:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2262:	11 86       	std	Z+9, r1	; 0x09
    2264:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2266:	8c 91       	ld	r24, X
    2268:	81 50       	subi	r24, 0x01	; 1
    226a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    226c:	8c 91       	ld	r24, X
}
    226e:	df 91       	pop	r29
    2270:	cf 91       	pop	r28
    2272:	08 95       	ret

00002274 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    2274:	cf 92       	push	r12
    2276:	df 92       	push	r13
    2278:	ef 92       	push	r14
    227a:	ff 92       	push	r15
    227c:	1f 93       	push	r17
    227e:	cf 93       	push	r28
    2280:	df 93       	push	r29
    2282:	6c 01       	movw	r12, r24
    2284:	16 2f       	mov	r17, r22
    2286:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    2288:	8a e1       	ldi	r24, 0x1A	; 26
    228a:	90 e0       	ldi	r25, 0x00	; 0
    228c:	0e 94 00 13 	call	0x2600	; 0x2600 <pvPortMalloc>
    2290:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    2292:	89 2b       	or	r24, r25
    2294:	09 f4       	brne	.+2      	; 0x2298 <xCoRoutineCreate+0x24>
    2296:	57 c0       	rjmp	.+174    	; 0x2346 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2298:	80 91 b3 02 	lds	r24, 0x02B3	; 0x8002b3 <pxCurrentCoRoutine>
    229c:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <pxCurrentCoRoutine+0x1>
    22a0:	89 2b       	or	r24, r25
    22a2:	21 f5       	brne	.+72     	; 0x22ec <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    22a4:	d0 93 b4 02 	sts	0x02B4, r29	; 0x8002b4 <pxCurrentCoRoutine+0x1>
    22a8:	c0 93 b3 02 	sts	0x02B3, r28	; 0x8002b3 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    22ac:	8b ed       	ldi	r24, 0xDB	; 219
    22ae:	92 e0       	ldi	r25, 0x02	; 2
    22b0:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
    22b4:	84 ee       	ldi	r24, 0xE4	; 228
    22b6:	92 e0       	ldi	r25, 0x02	; 2
    22b8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    22bc:	82 ed       	ldi	r24, 0xD2	; 210
    22be:	92 e0       	ldi	r25, 0x02	; 2
    22c0:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    22c4:	89 ec       	ldi	r24, 0xC9	; 201
    22c6:	92 e0       	ldi	r25, 0x02	; 2
    22c8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    22cc:	8c eb       	ldi	r24, 0xBC	; 188
    22ce:	92 e0       	ldi	r25, 0x02	; 2
    22d0:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    22d4:	82 ed       	ldi	r24, 0xD2	; 210
    22d6:	92 e0       	ldi	r25, 0x02	; 2
    22d8:	90 93 c8 02 	sts	0x02C8, r25	; 0x8002c8 <pxDelayedCoRoutineList+0x1>
    22dc:	80 93 c7 02 	sts	0x02C7, r24	; 0x8002c7 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    22e0:	89 ec       	ldi	r24, 0xC9	; 201
    22e2:	92 e0       	ldi	r25, 0x02	; 2
    22e4:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <pxOverflowDelayedCoRoutineList+0x1>
    22e8:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <pxOverflowDelayedCoRoutineList>
    22ec:	11 11       	cpse	r17, r1
    22ee:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    22f0:	19 8e       	std	Y+25, r1	; 0x19
    22f2:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    22f4:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    22f6:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    22f8:	fe 01       	movw	r30, r28
    22fa:	c1 92       	st	Z+, r12
    22fc:	d1 92       	st	Z+, r13
    22fe:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2300:	cf 01       	movw	r24, r30
    2302:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2306:	ce 01       	movw	r24, r28
    2308:	0c 96       	adiw	r24, 0x0c	; 12
    230a:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    230e:	d9 87       	std	Y+9, r29	; 0x09
    2310:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2312:	db 8b       	std	Y+19, r29	; 0x13
    2314:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2316:	82 e0       	ldi	r24, 0x02	; 2
    2318:	90 e0       	ldi	r25, 0x00	; 0
    231a:	81 1b       	sub	r24, r17
    231c:	91 09       	sbc	r25, r1
    231e:	9d 87       	std	Y+13, r25	; 0x0d
    2320:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2322:	8e 89       	ldd	r24, Y+22	; 0x16
    2324:	90 91 bb 02 	lds	r25, 0x02BB	; 0x8002bb <uxTopCoRoutineReadyPriority>
    2328:	98 17       	cp	r25, r24
    232a:	10 f4       	brcc	.+4      	; 0x2330 <xCoRoutineCreate+0xbc>
    232c:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <uxTopCoRoutineReadyPriority>
    2330:	f9 e0       	ldi	r31, 0x09	; 9
    2332:	8f 9f       	mul	r24, r31
    2334:	c0 01       	movw	r24, r0
    2336:	11 24       	eor	r1, r1
    2338:	b7 01       	movw	r22, r14
    233a:	85 52       	subi	r24, 0x25	; 37
    233c:	9d 4f       	sbci	r25, 0xFD	; 253
    233e:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>

		xReturn = pdPASS;
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	01 c0       	rjmp	.+2      	; 0x2348 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2346:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    2348:	df 91       	pop	r29
    234a:	cf 91       	pop	r28
    234c:	1f 91       	pop	r17
    234e:	ff 90       	pop	r15
    2350:	ef 90       	pop	r14
    2352:	df 90       	pop	r13
    2354:	cf 90       	pop	r12
    2356:	08 95       	ret

00002358 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    2358:	0f 93       	push	r16
    235a:	1f 93       	push	r17
    235c:	cf 93       	push	r28
    235e:	df 93       	push	r29
    2360:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2362:	c0 91 b9 02 	lds	r28, 0x02B9	; 0x8002b9 <xCoRoutineTickCount>
    2366:	d0 91 ba 02 	lds	r29, 0x02BA	; 0x8002ba <xCoRoutineTickCount+0x1>
    236a:	c8 0f       	add	r28, r24
    236c:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    236e:	80 91 b3 02 	lds	r24, 0x02B3	; 0x8002b3 <pxCurrentCoRoutine>
    2372:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <pxCurrentCoRoutine+0x1>
    2376:	02 96       	adiw	r24, 0x02	; 2
    2378:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    237c:	e0 91 b3 02 	lds	r30, 0x02B3	; 0x8002b3 <pxCurrentCoRoutine>
    2380:	f0 91 b4 02 	lds	r31, 0x02B4	; 0x8002b4 <pxCurrentCoRoutine+0x1>
    2384:	d3 83       	std	Z+3, r29	; 0x03
    2386:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2388:	80 91 b9 02 	lds	r24, 0x02B9	; 0x8002b9 <xCoRoutineTickCount>
    238c:	90 91 ba 02 	lds	r25, 0x02BA	; 0x8002ba <xCoRoutineTickCount+0x1>
    2390:	bf 01       	movw	r22, r30
    2392:	6e 5f       	subi	r22, 0xFE	; 254
    2394:	7f 4f       	sbci	r23, 0xFF	; 255
    2396:	c8 17       	cp	r28, r24
    2398:	d9 07       	cpc	r29, r25
    239a:	28 f4       	brcc	.+10     	; 0x23a6 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    239c:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <pxOverflowDelayedCoRoutineList>
    23a0:	90 91 c6 02 	lds	r25, 0x02C6	; 0x8002c6 <pxOverflowDelayedCoRoutineList+0x1>
    23a4:	04 c0       	rjmp	.+8      	; 0x23ae <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    23a6:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <pxDelayedCoRoutineList>
    23aa:	90 91 c8 02 	lds	r25, 0x02C8	; 0x8002c8 <pxDelayedCoRoutineList+0x1>
    23ae:	0e 94 de 10 	call	0x21bc	; 0x21bc <vListInsert>
	}

	if( pxEventList )
    23b2:	01 15       	cp	r16, r1
    23b4:	11 05       	cpc	r17, r1
    23b6:	69 f0       	breq	.+26     	; 0x23d2 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    23b8:	60 91 b3 02 	lds	r22, 0x02B3	; 0x8002b3 <pxCurrentCoRoutine>
    23bc:	70 91 b4 02 	lds	r23, 0x02B4	; 0x8002b4 <pxCurrentCoRoutine+0x1>
    23c0:	64 5f       	subi	r22, 0xF4	; 244
    23c2:	7f 4f       	sbci	r23, 0xFF	; 255
    23c4:	c8 01       	movw	r24, r16
	}
}
    23c6:	df 91       	pop	r29
    23c8:	cf 91       	pop	r28
    23ca:	1f 91       	pop	r17
    23cc:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    23ce:	0c 94 de 10 	jmp	0x21bc	; 0x21bc <vListInsert>
	}
}
    23d2:	df 91       	pop	r29
    23d4:	cf 91       	pop	r28
    23d6:	1f 91       	pop	r17
    23d8:	0f 91       	pop	r16
    23da:	08 95       	ret

000023dc <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    23dc:	ff 92       	push	r15
    23de:	0f 93       	push	r16
    23e0:	1f 93       	push	r17
    23e2:	cf 93       	push	r28
    23e4:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    23e6:	99 e0       	ldi	r25, 0x09	; 9
    23e8:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    23ea:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <xPendingReadyCoRoutineList>
    23ee:	88 23       	and	r24, r24
    23f0:	11 f1       	breq	.+68     	; 0x2436 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    23f2:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    23f4:	e0 91 c1 02 	lds	r30, 0x02C1	; 0x8002c1 <xPendingReadyCoRoutineList+0x5>
    23f8:	f0 91 c2 02 	lds	r31, 0x02C2	; 0x8002c2 <xPendingReadyCoRoutineList+0x6>
    23fc:	c6 81       	ldd	r28, Z+6	; 0x06
    23fe:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2400:	ce 01       	movw	r24, r28
    2402:	0c 96       	adiw	r24, 0x0c	; 12
    2404:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2408:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    240a:	8e 01       	movw	r16, r28
    240c:	0e 5f       	subi	r16, 0xFE	; 254
    240e:	1f 4f       	sbci	r17, 0xFF	; 255
    2410:	c8 01       	movw	r24, r16
    2412:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2416:	8e 89       	ldd	r24, Y+22	; 0x16
    2418:	90 91 bb 02 	lds	r25, 0x02BB	; 0x8002bb <uxTopCoRoutineReadyPriority>
    241c:	98 17       	cp	r25, r24
    241e:	10 f4       	brcc	.+4      	; 0x2424 <vCoRoutineSchedule+0x48>
    2420:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <uxTopCoRoutineReadyPriority>
    2424:	f8 9e       	mul	r15, r24
    2426:	c0 01       	movw	r24, r0
    2428:	11 24       	eor	r1, r1
    242a:	b8 01       	movw	r22, r16
    242c:	85 52       	subi	r24, 0x25	; 37
    242e:	9d 4f       	sbci	r25, 0xFD	; 253
    2430:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>
    2434:	da cf       	rjmp	.-76     	; 0x23ea <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2436:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <xTaskGetTickCount>
    243a:	20 91 b7 02 	lds	r18, 0x02B7	; 0x8002b7 <xLastTickCount>
    243e:	30 91 b8 02 	lds	r19, 0x02B8	; 0x8002b8 <xLastTickCount+0x1>
    2442:	82 1b       	sub	r24, r18
    2444:	93 0b       	sbc	r25, r19
    2446:	90 93 b6 02 	sts	0x02B6, r25	; 0x8002b6 <xPassedTicks+0x1>
    244a:	80 93 b5 02 	sts	0x02B5, r24	; 0x8002b5 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    244e:	89 e0       	ldi	r24, 0x09	; 9
    2450:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2452:	20 91 b5 02 	lds	r18, 0x02B5	; 0x8002b5 <xPassedTicks>
    2456:	30 91 b6 02 	lds	r19, 0x02B6	; 0x8002b6 <xPassedTicks+0x1>
    245a:	80 91 b9 02 	lds	r24, 0x02B9	; 0x8002b9 <xCoRoutineTickCount>
    245e:	90 91 ba 02 	lds	r25, 0x02BA	; 0x8002ba <xCoRoutineTickCount+0x1>
    2462:	21 15       	cp	r18, r1
    2464:	31 05       	cpc	r19, r1
    2466:	09 f4       	brne	.+2      	; 0x246a <vCoRoutineSchedule+0x8e>
    2468:	54 c0       	rjmp	.+168    	; 0x2512 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    246a:	01 96       	adiw	r24, 0x01	; 1
    246c:	90 93 ba 02 	sts	0x02BA, r25	; 0x8002ba <xCoRoutineTickCount+0x1>
    2470:	80 93 b9 02 	sts	0x02B9, r24	; 0x8002b9 <xCoRoutineTickCount>
		xPassedTicks--;
    2474:	21 50       	subi	r18, 0x01	; 1
    2476:	31 09       	sbc	r19, r1
    2478:	30 93 b6 02 	sts	0x02B6, r19	; 0x8002b6 <xPassedTicks+0x1>
    247c:	20 93 b5 02 	sts	0x02B5, r18	; 0x8002b5 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2480:	89 2b       	or	r24, r25
    2482:	09 f0       	breq	.+2      	; 0x2486 <vCoRoutineSchedule+0xaa>
    2484:	3e c0       	rjmp	.+124    	; 0x2502 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2486:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <pxDelayedCoRoutineList>
    248a:	90 91 c8 02 	lds	r25, 0x02C8	; 0x8002c8 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    248e:	20 91 c5 02 	lds	r18, 0x02C5	; 0x8002c5 <pxOverflowDelayedCoRoutineList>
    2492:	30 91 c6 02 	lds	r19, 0x02C6	; 0x8002c6 <pxOverflowDelayedCoRoutineList+0x1>
    2496:	30 93 c8 02 	sts	0x02C8, r19	; 0x8002c8 <pxDelayedCoRoutineList+0x1>
    249a:	20 93 c7 02 	sts	0x02C7, r18	; 0x8002c7 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    249e:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <pxOverflowDelayedCoRoutineList+0x1>
    24a2:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <pxOverflowDelayedCoRoutineList>
    24a6:	2d c0       	rjmp	.+90     	; 0x2502 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    24a8:	05 80       	ldd	r0, Z+5	; 0x05
    24aa:	f6 81       	ldd	r31, Z+6	; 0x06
    24ac:	e0 2d       	mov	r30, r0
    24ae:	c6 81       	ldd	r28, Z+6	; 0x06
    24b0:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    24b2:	2a 81       	ldd	r18, Y+2	; 0x02
    24b4:	3b 81       	ldd	r19, Y+3	; 0x03
    24b6:	80 91 b9 02 	lds	r24, 0x02B9	; 0x8002b9 <xCoRoutineTickCount>
    24ba:	90 91 ba 02 	lds	r25, 0x02BA	; 0x8002ba <xCoRoutineTickCount+0x1>
    24be:	82 17       	cp	r24, r18
    24c0:	93 07       	cpc	r25, r19
    24c2:	38 f2       	brcs	.-114    	; 0x2452 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    24c4:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    24c6:	8e 01       	movw	r16, r28
    24c8:	0e 5f       	subi	r16, 0xFE	; 254
    24ca:	1f 4f       	sbci	r17, 0xFF	; 255
    24cc:	c8 01       	movw	r24, r16
    24ce:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    24d2:	8c 89       	ldd	r24, Y+20	; 0x14
    24d4:	9d 89       	ldd	r25, Y+21	; 0x15
    24d6:	89 2b       	or	r24, r25
    24d8:	21 f0       	breq	.+8      	; 0x24e2 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    24da:	ce 01       	movw	r24, r28
    24dc:	0c 96       	adiw	r24, 0x0c	; 12
    24de:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    24e2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    24e4:	8e 89       	ldd	r24, Y+22	; 0x16
    24e6:	90 91 bb 02 	lds	r25, 0x02BB	; 0x8002bb <uxTopCoRoutineReadyPriority>
    24ea:	98 17       	cp	r25, r24
    24ec:	10 f4       	brcc	.+4      	; 0x24f2 <vCoRoutineSchedule+0x116>
    24ee:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <uxTopCoRoutineReadyPriority>
    24f2:	f8 9e       	mul	r15, r24
    24f4:	c0 01       	movw	r24, r0
    24f6:	11 24       	eor	r1, r1
    24f8:	b8 01       	movw	r22, r16
    24fa:	85 52       	subi	r24, 0x25	; 37
    24fc:	9d 4f       	sbci	r25, 0xFD	; 253
    24fe:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2502:	e0 91 c7 02 	lds	r30, 0x02C7	; 0x8002c7 <pxDelayedCoRoutineList>
    2506:	f0 91 c8 02 	lds	r31, 0x02C8	; 0x8002c8 <pxDelayedCoRoutineList+0x1>
    250a:	80 81       	ld	r24, Z
    250c:	81 11       	cpse	r24, r1
    250e:	cc cf       	rjmp	.-104    	; 0x24a8 <vCoRoutineSchedule+0xcc>
    2510:	a0 cf       	rjmp	.-192    	; 0x2452 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2512:	90 93 b8 02 	sts	0x02B8, r25	; 0x8002b8 <xLastTickCount+0x1>
    2516:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <xLastTickCount>
    251a:	80 91 bb 02 	lds	r24, 0x02BB	; 0x8002bb <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    251e:	69 e0       	ldi	r22, 0x09	; 9
    2520:	48 2f       	mov	r20, r24
    2522:	50 e0       	ldi	r21, 0x00	; 0
    2524:	64 9f       	mul	r22, r20
    2526:	90 01       	movw	r18, r0
    2528:	65 9f       	mul	r22, r21
    252a:	30 0d       	add	r19, r0
    252c:	11 24       	eor	r1, r1
    252e:	f9 01       	movw	r30, r18
    2530:	e5 52       	subi	r30, 0x25	; 37
    2532:	fd 4f       	sbci	r31, 0xFD	; 253
    2534:	90 81       	ld	r25, Z
    2536:	91 11       	cpse	r25, r1
    2538:	0c c0       	rjmp	.+24     	; 0x2552 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    253a:	81 11       	cpse	r24, r1
    253c:	08 c0       	rjmp	.+16     	; 0x254e <vCoRoutineSchedule+0x172>
    253e:	10 92 bb 02 	sts	0x02BB, r1	; 0x8002bb <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    2542:	df 91       	pop	r29
    2544:	cf 91       	pop	r28
    2546:	1f 91       	pop	r17
    2548:	0f 91       	pop	r16
    254a:	ff 90       	pop	r15
    254c:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    254e:	81 50       	subi	r24, 0x01	; 1
    2550:	e7 cf       	rjmp	.-50     	; 0x2520 <vCoRoutineSchedule+0x144>
    2552:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2556:	a1 81       	ldd	r26, Z+1	; 0x01
    2558:	b2 81       	ldd	r27, Z+2	; 0x02
    255a:	12 96       	adiw	r26, 0x02	; 2
    255c:	0d 90       	ld	r0, X+
    255e:	bc 91       	ld	r27, X
    2560:	a0 2d       	mov	r26, r0
    2562:	b2 83       	std	Z+2, r27	; 0x02
    2564:	a1 83       	std	Z+1, r26	; 0x01
    2566:	22 52       	subi	r18, 0x22	; 34
    2568:	3d 4f       	sbci	r19, 0xFD	; 253
    256a:	a2 17       	cp	r26, r18
    256c:	b3 07       	cpc	r27, r19
    256e:	31 f4       	brne	.+12     	; 0x257c <vCoRoutineSchedule+0x1a0>
    2570:	12 96       	adiw	r26, 0x02	; 2
    2572:	8d 91       	ld	r24, X+
    2574:	9c 91       	ld	r25, X
    2576:	13 97       	sbiw	r26, 0x03	; 3
    2578:	92 83       	std	Z+2, r25	; 0x02
    257a:	81 83       	std	Z+1, r24	; 0x01
    257c:	89 e0       	ldi	r24, 0x09	; 9
    257e:	84 9f       	mul	r24, r20
    2580:	f0 01       	movw	r30, r0
    2582:	85 9f       	mul	r24, r21
    2584:	f0 0d       	add	r31, r0
    2586:	11 24       	eor	r1, r1
    2588:	e5 52       	subi	r30, 0x25	; 37
    258a:	fd 4f       	sbci	r31, 0xFD	; 253
    258c:	01 80       	ldd	r0, Z+1	; 0x01
    258e:	f2 81       	ldd	r31, Z+2	; 0x02
    2590:	e0 2d       	mov	r30, r0
    2592:	86 81       	ldd	r24, Z+6	; 0x06
    2594:	97 81       	ldd	r25, Z+7	; 0x07
    2596:	90 93 b4 02 	sts	0x02B4, r25	; 0x8002b4 <pxCurrentCoRoutine+0x1>
    259a:	80 93 b3 02 	sts	0x02B3, r24	; 0x8002b3 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    259e:	dc 01       	movw	r26, r24
    25a0:	ed 91       	ld	r30, X+
    25a2:	fc 91       	ld	r31, X
    25a4:	11 97       	sbiw	r26, 0x01	; 1
    25a6:	57 96       	adiw	r26, 0x17	; 23
    25a8:	6c 91       	ld	r22, X

	return;
}
    25aa:	df 91       	pop	r29
    25ac:	cf 91       	pop	r28
    25ae:	1f 91       	pop	r17
    25b0:	0f 91       	pop	r16
    25b2:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    25b4:	19 94       	eijmp

000025b6 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    25b6:	0f 93       	push	r16
    25b8:	1f 93       	push	r17
    25ba:	cf 93       	push	r28
    25bc:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    25be:	dc 01       	movw	r26, r24
    25c0:	15 96       	adiw	r26, 0x05	; 5
    25c2:	ed 91       	ld	r30, X+
    25c4:	fc 91       	ld	r31, X
    25c6:	16 97       	sbiw	r26, 0x06	; 6
    25c8:	c6 81       	ldd	r28, Z+6	; 0x06
    25ca:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    25cc:	8e 01       	movw	r16, r28
    25ce:	04 5f       	subi	r16, 0xF4	; 244
    25d0:	1f 4f       	sbci	r17, 0xFF	; 255
    25d2:	c8 01       	movw	r24, r16
    25d4:	0e 94 16 11 	call	0x222c	; 0x222c <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    25d8:	b8 01       	movw	r22, r16
    25da:	8c eb       	ldi	r24, 0xBC	; 188
    25dc:	92 e0       	ldi	r25, 0x02	; 2
    25de:	0e 94 bd 10 	call	0x217a	; 0x217a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    25e2:	e0 91 b3 02 	lds	r30, 0x02B3	; 0x8002b3 <pxCurrentCoRoutine>
    25e6:	f0 91 b4 02 	lds	r31, 0x02B4	; 0x8002b4 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    25ea:	81 e0       	ldi	r24, 0x01	; 1
    25ec:	2e 89       	ldd	r18, Y+22	; 0x16
    25ee:	96 89       	ldd	r25, Z+22	; 0x16
    25f0:	29 17       	cp	r18, r25
    25f2:	08 f4       	brcc	.+2      	; 0x25f6 <xCoRoutineRemoveFromEventList+0x40>
    25f4:	80 e0       	ldi	r24, 0x00	; 0
}
    25f6:	df 91       	pop	r29
    25f8:	cf 91       	pop	r28
    25fa:	1f 91       	pop	r17
    25fc:	0f 91       	pop	r16
    25fe:	08 95       	ret

00002600 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2600:	cf 93       	push	r28
    2602:	df 93       	push	r29
    2604:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2606:	0e 94 dd 06 	call	0xdba	; 0xdba <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    260a:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <pucAlignedHeap.2081>
    260e:	90 91 ee 02 	lds	r25, 0x02EE	; 0x8002ee <pucAlignedHeap.2081+0x1>
    2612:	89 2b       	or	r24, r25
    2614:	31 f4       	brne	.+12     	; 0x2622 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2616:	82 ef       	ldi	r24, 0xF2	; 242
    2618:	92 e0       	ldi	r25, 0x02	; 2
    261a:	90 93 ee 02 	sts	0x02EE, r25	; 0x8002ee <pucAlignedHeap.2081+0x1>
    261e:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2622:	20 91 ef 02 	lds	r18, 0x02EF	; 0x8002ef <xNextFreeByte>
    2626:	30 91 f0 02 	lds	r19, 0x02F0	; 0x8002f0 <xNextFreeByte+0x1>
    262a:	c9 01       	movw	r24, r18
    262c:	8c 0f       	add	r24, r28
    262e:	9d 1f       	adc	r25, r29
    2630:	8b 3d       	cpi	r24, 0xDB	; 219
    2632:	45 e0       	ldi	r20, 0x05	; 5
    2634:	94 07       	cpc	r25, r20
    2636:	70 f4       	brcc	.+28     	; 0x2654 <pvPortMalloc+0x54>
    2638:	28 17       	cp	r18, r24
    263a:	39 07       	cpc	r19, r25
    263c:	58 f4       	brcc	.+22     	; 0x2654 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    263e:	c0 91 ed 02 	lds	r28, 0x02ED	; 0x8002ed <pucAlignedHeap.2081>
    2642:	d0 91 ee 02 	lds	r29, 0x02EE	; 0x8002ee <pucAlignedHeap.2081+0x1>
    2646:	c2 0f       	add	r28, r18
    2648:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    264a:	90 93 f0 02 	sts	0x02F0, r25	; 0x8002f0 <xNextFreeByte+0x1>
    264e:	80 93 ef 02 	sts	0x02EF, r24	; 0x8002ef <xNextFreeByte>
    2652:	02 c0       	rjmp	.+4      	; 0x2658 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2654:	c0 e0       	ldi	r28, 0x00	; 0
    2656:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2658:	0e 94 a9 07 	call	0xf52	; 0xf52 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    265c:	ce 01       	movw	r24, r28
    265e:	df 91       	pop	r29
    2660:	cf 91       	pop	r28
    2662:	08 95       	ret

00002664 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2664:	08 95       	ret

00002666 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2666:	10 92 f0 02 	sts	0x02F0, r1	; 0x8002f0 <xNextFreeByte+0x1>
    266a:	10 92 ef 02 	sts	0x02EF, r1	; 0x8002ef <xNextFreeByte>
    266e:	08 95       	ret

00002670 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2670:	20 91 ef 02 	lds	r18, 0x02EF	; 0x8002ef <xNextFreeByte>
    2674:	30 91 f0 02 	lds	r19, 0x02F0	; 0x8002f0 <xNextFreeByte+0x1>
}
    2678:	8b ed       	ldi	r24, 0xDB	; 219
    267a:	95 e0       	ldi	r25, 0x05	; 5
    267c:	82 1b       	sub	r24, r18
    267e:	93 0b       	sbc	r25, r19
    2680:	08 95       	ret

00002682 <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2682:	31 e1       	ldi	r19, 0x11	; 17
    2684:	fc 01       	movw	r30, r24
    2686:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2688:	31 97       	sbiw	r30, 0x01	; 1
    268a:	22 e2       	ldi	r18, 0x22	; 34
    268c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    268e:	31 97       	sbiw	r30, 0x01	; 1
    2690:	a3 e3       	ldi	r26, 0x33	; 51
    2692:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2694:	31 97       	sbiw	r30, 0x01	; 1
    2696:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2698:	31 97       	sbiw	r30, 0x01	; 1
    269a:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
    269c:	31 97       	sbiw	r30, 0x01	; 1
    269e:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    26a0:	31 97       	sbiw	r30, 0x01	; 1
    26a2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    26a4:	31 97       	sbiw	r30, 0x01	; 1
    26a6:	60 e8       	ldi	r22, 0x80	; 128
    26a8:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* EIND */
    26aa:	31 97       	sbiw	r30, 0x01	; 1
    26ac:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x00;	/* RAMPZ */
    26ae:	31 97       	sbiw	r30, 0x01	; 1
    26b0:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    26b2:	31 97       	sbiw	r30, 0x01	; 1
    26b4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    26b6:	31 97       	sbiw	r30, 0x01	; 1
    26b8:	62 e0       	ldi	r22, 0x02	; 2
    26ba:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    26bc:	31 97       	sbiw	r30, 0x01	; 1
    26be:	63 e0       	ldi	r22, 0x03	; 3
    26c0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    26c2:	31 97       	sbiw	r30, 0x01	; 1
    26c4:	64 e0       	ldi	r22, 0x04	; 4
    26c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    26c8:	31 97       	sbiw	r30, 0x01	; 1
    26ca:	65 e0       	ldi	r22, 0x05	; 5
    26cc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    26ce:	31 97       	sbiw	r30, 0x01	; 1
    26d0:	66 e0       	ldi	r22, 0x06	; 6
    26d2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    26d4:	31 97       	sbiw	r30, 0x01	; 1
    26d6:	67 e0       	ldi	r22, 0x07	; 7
    26d8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    26da:	31 97       	sbiw	r30, 0x01	; 1
    26dc:	68 e0       	ldi	r22, 0x08	; 8
    26de:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    26e0:	31 97       	sbiw	r30, 0x01	; 1
    26e2:	69 e0       	ldi	r22, 0x09	; 9
    26e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    26e6:	31 97       	sbiw	r30, 0x01	; 1
    26e8:	60 e1       	ldi	r22, 0x10	; 16
    26ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    26ec:	31 97       	sbiw	r30, 0x01	; 1
    26ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    26f0:	31 97       	sbiw	r30, 0x01	; 1
    26f2:	32 e1       	ldi	r19, 0x12	; 18
    26f4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    26f6:	31 97       	sbiw	r30, 0x01	; 1
    26f8:	33 e1       	ldi	r19, 0x13	; 19
    26fa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    26fc:	31 97       	sbiw	r30, 0x01	; 1
    26fe:	34 e1       	ldi	r19, 0x14	; 20
    2700:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2702:	31 97       	sbiw	r30, 0x01	; 1
    2704:	35 e1       	ldi	r19, 0x15	; 21
    2706:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2708:	31 97       	sbiw	r30, 0x01	; 1
    270a:	36 e1       	ldi	r19, 0x16	; 22
    270c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    270e:	31 97       	sbiw	r30, 0x01	; 1
    2710:	37 e1       	ldi	r19, 0x17	; 23
    2712:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2714:	31 97       	sbiw	r30, 0x01	; 1
    2716:	38 e1       	ldi	r19, 0x18	; 24
    2718:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    271a:	31 97       	sbiw	r30, 0x01	; 1
    271c:	39 e1       	ldi	r19, 0x19	; 25
    271e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2720:	31 97       	sbiw	r30, 0x01	; 1
    2722:	30 e2       	ldi	r19, 0x20	; 32
    2724:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2726:	31 97       	sbiw	r30, 0x01	; 1
    2728:	31 e2       	ldi	r19, 0x21	; 33
    272a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    272c:	31 97       	sbiw	r30, 0x01	; 1
    272e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2730:	31 97       	sbiw	r30, 0x01	; 1
    2732:	23 e2       	ldi	r18, 0x23	; 35
    2734:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2736:	31 97       	sbiw	r30, 0x01	; 1
    2738:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    273a:	31 97       	sbiw	r30, 0x01	; 1
    273c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    273e:	31 97       	sbiw	r30, 0x01	; 1
    2740:	26 e2       	ldi	r18, 0x26	; 38
    2742:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2744:	31 97       	sbiw	r30, 0x01	; 1
    2746:	27 e2       	ldi	r18, 0x27	; 39
    2748:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    274a:	31 97       	sbiw	r30, 0x01	; 1
    274c:	28 e2       	ldi	r18, 0x28	; 40
    274e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2750:	31 97       	sbiw	r30, 0x01	; 1
    2752:	29 e2       	ldi	r18, 0x29	; 41
    2754:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2756:	31 97       	sbiw	r30, 0x01	; 1
    2758:	20 e3       	ldi	r18, 0x30	; 48
    275a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    275c:	31 97       	sbiw	r30, 0x01	; 1
    275e:	21 e3       	ldi	r18, 0x31	; 49
    2760:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2762:	89 97       	sbiw	r24, 0x29	; 41
    2764:	08 95       	ret

00002766 <xPortStartScheduler>:
    //ulCompareMatch = 625 /= portCLOCK_PRESCALER; 20MHz with 64 prescale
    //ulCompareMatch = 108 /= portCLOCK_PRESCALER; 22.1184 MHz with 1024 prescale
    ulCompareMatch /= portCLOCK_PRESCALER;

 	/* actual port tick rate in Hz, calculated */
	portTickRateHz = (TickType_t) ((uint32_t) configCPU_CLOCK_HZ / ( portCLOCK_PRESCALER * ulCompareMatch ));
    2766:	88 ee       	ldi	r24, 0xE8	; 232
    2768:	93 e0       	ldi	r25, 0x03	; 3
    276a:	90 93 d7 08 	sts	0x08D7, r25	; 0x8008d7 <portTickRateHz+0x1>
    276e:	80 93 d6 08 	sts	0x08D6, r24	; 0x8008d6 <portTickRateHz>
	/* initialise first second of ticks */
	ticksRemainingInSec = portTickRateHz;
    2772:	90 93 d9 08 	sts	0x08D9, r25	; 0x8008d9 <ticksRemainingInSec+0x1>
    2776:	80 93 d8 08 	sts	0x08D8, r24	; 0x8008d8 <ticksRemainingInSec>

    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH
    ulCompareMatch >>= 8;
    ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t) 0xff );
    portOCRH = ucHighByte;
    277a:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
#endif

    portOCRL = ucLowByte;
    277e:	89 ef       	ldi	r24, 0xF9	; 249
    2780:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
   portTCCRb = portPRESCALE_1024;

#elif defined( portUSE_TIMER1 )
	/* Setup clock source and compare match behaviour. Assuming 328p (with Timer1) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
    2784:	8b e0       	ldi	r24, 0x0B	; 11
    2786:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally disabled. */
    ucLowByte = portTIMSK;
    278a:	ef e6       	ldi	r30, 0x6F	; 111
    278c:	f0 e0       	ldi	r31, 0x00	; 0
    278e:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2790:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
    2792:	80 83       	st	Z, r24

	/* Setup the relevant timer hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2794:	a0 91 56 02 	lds	r26, 0x0256	; 0x800256 <pxCurrentTCB>
    2798:	b0 91 57 02 	lds	r27, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    279c:	cd 91       	ld	r28, X+
    279e:	cd bf       	out	0x3d, r28	; 61
    27a0:	dd 91       	ld	r29, X+
    27a2:	de bf       	out	0x3e, r29	; 62
    27a4:	ff 91       	pop	r31
    27a6:	ef 91       	pop	r30
    27a8:	df 91       	pop	r29
    27aa:	cf 91       	pop	r28
    27ac:	bf 91       	pop	r27
    27ae:	af 91       	pop	r26
    27b0:	9f 91       	pop	r25
    27b2:	8f 91       	pop	r24
    27b4:	7f 91       	pop	r23
    27b6:	6f 91       	pop	r22
    27b8:	5f 91       	pop	r21
    27ba:	4f 91       	pop	r20
    27bc:	3f 91       	pop	r19
    27be:	2f 91       	pop	r18
    27c0:	1f 91       	pop	r17
    27c2:	0f 91       	pop	r16
    27c4:	ff 90       	pop	r15
    27c6:	ef 90       	pop	r14
    27c8:	df 90       	pop	r13
    27ca:	cf 90       	pop	r12
    27cc:	bf 90       	pop	r11
    27ce:	af 90       	pop	r10
    27d0:	9f 90       	pop	r9
    27d2:	8f 90       	pop	r8
    27d4:	7f 90       	pop	r7
    27d6:	6f 90       	pop	r6
    27d8:	5f 90       	pop	r5
    27da:	4f 90       	pop	r4
    27dc:	3f 90       	pop	r3
    27de:	2f 90       	pop	r2
    27e0:	1f 90       	pop	r1
    27e2:	0f 90       	pop	r0
    27e4:	0c be       	out	0x3c, r0	; 60
    27e6:	0f 90       	pop	r0
    27e8:	0b be       	out	0x3b, r0	; 59
    27ea:	0f 90       	pop	r0
    27ec:	0f be       	out	0x3f, r0	; 63
    27ee:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
    27f0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    27f2:	81 e0       	ldi	r24, 0x01	; 1
    27f4:	08 95       	ret

000027f6 <vPortEndScheduler>:

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts

#elif defined( portUSE_TIMER1 )
        portTIMSK &= ~( _BV(OCIE1B)|_BV(OCIE1A)|_BV(TOIE1) );	// disable all Timer1 interrupts
    27f6:	ef e6       	ldi	r30, 0x6F	; 111
    27f8:	f0 e0       	ldi	r31, 0x00	; 0
    27fa:	80 81       	ld	r24, Z
    27fc:	88 7f       	andi	r24, 0xF8	; 248
    27fe:	80 83       	st	Z, r24
    2800:	08 95       	ret

00002802 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2802:	0f 93       	push	r16
    2804:	1f 93       	push	r17
    2806:	cf 93       	push	r28
    2808:	df 93       	push	r29
    280a:	1f 92       	push	r1
    280c:	cd b7       	in	r28, 0x3d	; 61
    280e:	de b7       	in	r29, 0x3e	; 62
    2810:	8c 01       	movw	r16, r24
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2812:	fc 01       	movw	r30, r24
    2814:	80 8d       	ldd	r24, Z+24	; 0x18
    2816:	91 8d       	ldd	r25, Z+25	; 0x19
    2818:	8e 36       	cpi	r24, 0x6E	; 110
    281a:	f1 e0       	ldi	r31, 0x01	; 1
    281c:	9f 07       	cpc	r25, r31
    281e:	b1 f0       	breq	.+44     	; 0x284c <prvFlashCoRoutine+0x4a>
    2820:	8f 36       	cpi	r24, 0x6F	; 111
    2822:	21 e0       	ldi	r18, 0x01	; 1
    2824:	92 07       	cpc	r25, r18
    2826:	51 f1       	breq	.+84     	; 0x287c <prvFlashCoRoutine+0x7a>
    2828:	89 2b       	or	r24, r25
    282a:	61 f5       	brne	.+88     	; 0x2884 <prvFlashCoRoutine+0x82>
	( void ) uxIndex;

	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );
    282c:	4f ef       	ldi	r20, 0xFF	; 255
    282e:	5f ef       	ldi	r21, 0xFF	; 255
    2830:	be 01       	movw	r22, r28
    2832:	6f 5f       	subi	r22, 0xFF	; 255
    2834:	7f 4f       	sbci	r23, 0xFF	; 255
    2836:	80 91 cd 08 	lds	r24, 0x08CD	; 0x8008cd <xFlashQueue>
    283a:	90 91 ce 08 	lds	r25, 0x08CE	; 0x8008ce <xFlashQueue+0x1>
    283e:	0e 94 04 10 	call	0x2008	; 0x2008 <xQueueCRReceive>
    2842:	8c 3f       	cpi	r24, 0xFC	; 252
    2844:	71 f4       	brne	.+28     	; 0x2862 <prvFlashCoRoutine+0x60>
    2846:	8e e6       	ldi	r24, 0x6E	; 110
    2848:	91 e0       	ldi	r25, 0x01	; 1
    284a:	0f c0       	rjmp	.+30     	; 0x286a <prvFlashCoRoutine+0x68>
    284c:	40 e0       	ldi	r20, 0x00	; 0
    284e:	50 e0       	ldi	r21, 0x00	; 0
    2850:	be 01       	movw	r22, r28
    2852:	6f 5f       	subi	r22, 0xFF	; 255
    2854:	7f 4f       	sbci	r23, 0xFF	; 255
    2856:	80 91 cd 08 	lds	r24, 0x08CD	; 0x8008cd <xFlashQueue>
    285a:	90 91 ce 08 	lds	r25, 0x08CE	; 0x8008ce <xFlashQueue+0x1>
    285e:	0e 94 04 10 	call	0x2008	; 0x2008 <xQueueCRReceive>
    2862:	8b 3f       	cpi	r24, 0xFB	; 251
    2864:	31 f4       	brne	.+12     	; 0x2872 <prvFlashCoRoutine+0x70>
    2866:	8f e6       	ldi	r24, 0x6F	; 111
    2868:	91 e0       	ldi	r25, 0x01	; 1
    286a:	f8 01       	movw	r30, r16
    286c:	91 8f       	std	Z+25, r25	; 0x19
    286e:	80 8f       	std	Z+24, r24	; 0x18
    2870:	09 c0       	rjmp	.+18     	; 0x2884 <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    2872:	81 30       	cpi	r24, 0x01	; 1
    2874:	19 f0       	breq	.+6      	; 0x287c <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    2876:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <xCoRoutineFlashStatus>
    287a:	d8 cf       	rjmp	.-80     	; 0x282c <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    287c:	89 81       	ldd	r24, Y+1	; 0x01
    287e:	0e 94 66 02 	call	0x4cc	; 0x4cc <vParTestToggleLED>
    2882:	d4 cf       	rjmp	.-88     	; 0x282c <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2884:	0f 90       	pop	r0
    2886:	df 91       	pop	r29
    2888:	cf 91       	pop	r28
    288a:	1f 91       	pop	r17
    288c:	0f 91       	pop	r16
    288e:	08 95       	ret

00002890 <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    2890:	0f 93       	push	r16
    2892:	1f 93       	push	r17
    2894:	cf 93       	push	r28
    2896:	df 93       	push	r29
    2898:	1f 92       	push	r1
    289a:	cd b7       	in	r28, 0x3d	; 61
    289c:	de b7       	in	r29, 0x3e	; 62
    289e:	8c 01       	movw	r16, r24
    28a0:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    28a2:	fc 01       	movw	r30, r24
    28a4:	80 8d       	ldd	r24, Z+24	; 0x18
    28a6:	91 8d       	ldd	r25, Z+25	; 0x19
    28a8:	8e 32       	cpi	r24, 0x2E	; 46
    28aa:	f1 e0       	ldi	r31, 0x01	; 1
    28ac:	9f 07       	cpc	r25, r31
    28ae:	d9 f0       	breq	.+54     	; 0x28e6 <prvFixedDelayCoRoutine+0x56>
    28b0:	18 f4       	brcc	.+6      	; 0x28b8 <prvFixedDelayCoRoutine+0x28>
    28b2:	89 2b       	or	r24, r25
    28b4:	41 f0       	breq	.+16     	; 0x28c6 <prvFixedDelayCoRoutine+0x36>
    28b6:	3e c0       	rjmp	.+124    	; 0x2934 <prvFixedDelayCoRoutine+0xa4>
    28b8:	8f 32       	cpi	r24, 0x2F	; 47
    28ba:	e1 e0       	ldi	r30, 0x01	; 1
    28bc:	9e 07       	cpc	r25, r30
    28be:	39 f1       	breq	.+78     	; 0x290e <prvFixedDelayCoRoutine+0x7e>
    28c0:	82 34       	cpi	r24, 0x42	; 66
    28c2:	91 40       	sbci	r25, 0x01	; 1
    28c4:	b9 f5       	brne	.+110    	; 0x2934 <prvFixedDelayCoRoutine+0xa4>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    28c6:	40 e0       	ldi	r20, 0x00	; 0
    28c8:	50 e0       	ldi	r21, 0x00	; 0
    28ca:	be 01       	movw	r22, r28
    28cc:	6f 5f       	subi	r22, 0xFF	; 255
    28ce:	7f 4f       	sbci	r23, 0xFF	; 255
    28d0:	80 91 cd 08 	lds	r24, 0x08CD	; 0x8008cd <xFlashQueue>
    28d4:	90 91 ce 08 	lds	r25, 0x08CE	; 0x8008ce <xFlashQueue+0x1>
    28d8:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xQueueCRSend>
    28dc:	8c 3f       	cpi	r24, 0xFC	; 252
    28de:	71 f4       	brne	.+28     	; 0x28fc <prvFixedDelayCoRoutine+0x6c>
    28e0:	8e e2       	ldi	r24, 0x2E	; 46
    28e2:	91 e0       	ldi	r25, 0x01	; 1
    28e4:	24 c0       	rjmp	.+72     	; 0x292e <prvFixedDelayCoRoutine+0x9e>
    28e6:	40 e0       	ldi	r20, 0x00	; 0
    28e8:	50 e0       	ldi	r21, 0x00	; 0
    28ea:	be 01       	movw	r22, r28
    28ec:	6f 5f       	subi	r22, 0xFF	; 255
    28ee:	7f 4f       	sbci	r23, 0xFF	; 255
    28f0:	80 91 cd 08 	lds	r24, 0x08CD	; 0x8008cd <xFlashQueue>
    28f4:	90 91 ce 08 	lds	r25, 0x08CE	; 0x8008ce <xFlashQueue+0x1>
    28f8:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <xQueueCRSend>
    28fc:	8b 3f       	cpi	r24, 0xFB	; 251
    28fe:	19 f4       	brne	.+6      	; 0x2906 <prvFixedDelayCoRoutine+0x76>
    2900:	8f e2       	ldi	r24, 0x2F	; 47
    2902:	91 e0       	ldi	r25, 0x01	; 1
    2904:	14 c0       	rjmp	.+40     	; 0x292e <prvFixedDelayCoRoutine+0x9e>

		if( xResult != pdPASS )
    2906:	81 30       	cpi	r24, 0x01	; 1
    2908:	11 f0       	breq	.+4      	; 0x290e <prvFixedDelayCoRoutine+0x7e>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    290a:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <xCoRoutineFlashStatus>
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    290e:	e9 81       	ldd	r30, Y+1	; 0x01
    2910:	f0 e0       	ldi	r31, 0x00	; 0
    2912:	ee 0f       	add	r30, r30
    2914:	ff 1f       	adc	r31, r31
    2916:	ea 5f       	subi	r30, 0xFA	; 250
    2918:	fd 4f       	sbci	r31, 0xFD	; 253
    291a:	80 81       	ld	r24, Z
    291c:	91 81       	ldd	r25, Z+1	; 0x01
    291e:	00 97       	sbiw	r24, 0x00	; 0
    2920:	21 f0       	breq	.+8      	; 0x292a <prvFixedDelayCoRoutine+0x9a>
    2922:	60 e0       	ldi	r22, 0x00	; 0
    2924:	70 e0       	ldi	r23, 0x00	; 0
    2926:	0e 94 ac 11 	call	0x2358	; 0x2358 <vCoRoutineAddToDelayedList>
    292a:	82 e4       	ldi	r24, 0x42	; 66
    292c:	91 e0       	ldi	r25, 0x01	; 1
    292e:	f8 01       	movw	r30, r16
    2930:	91 8f       	std	Z+25, r25	; 0x19
    2932:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2934:	0f 90       	pop	r0
    2936:	df 91       	pop	r29
    2938:	cf 91       	pop	r28
    293a:	1f 91       	pop	r17
    293c:	0f 91       	pop	r16
    293e:	08 95       	ret

00002940 <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
    2940:	cf 93       	push	r28
    2942:	df 93       	push	r29
    2944:	d8 2f       	mov	r29, r24
    2946:	89 30       	cpi	r24, 0x09	; 9
    2948:	08 f0       	brcs	.+2      	; 0x294c <vStartFlashCoRoutines+0xc>
    294a:	d8 e0       	ldi	r29, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
    294c:	40 e0       	ldi	r20, 0x00	; 0
    294e:	61 e0       	ldi	r22, 0x01	; 1
    2950:	81 e0       	ldi	r24, 0x01	; 1
    2952:	0e 94 a9 0c 	call	0x1952	; 0x1952 <xQueueGenericCreate>
    2956:	90 93 ce 08 	sts	0x08CE, r25	; 0x8008ce <xFlashQueue+0x1>
    295a:	80 93 cd 08 	sts	0x08CD, r24	; 0x8008cd <xFlashQueue>

	if( xFlashQueue )
    295e:	89 2b       	or	r24, r25
    2960:	99 f0       	breq	.+38     	; 0x2988 <vStartFlashCoRoutines+0x48>
    2962:	c0 e0       	ldi	r28, 0x00	; 0
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    2964:	cd 17       	cp	r28, r29
    2966:	41 f0       	breq	.+16     	; 0x2978 <vStartFlashCoRoutines+0x38>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    2968:	4c 2f       	mov	r20, r28
    296a:	60 e0       	ldi	r22, 0x00	; 0
    296c:	88 e4       	ldi	r24, 0x48	; 72
    296e:	94 e1       	ldi	r25, 0x14	; 20
    2970:	0e 94 3a 11 	call	0x2274	; 0x2274 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    2974:	cf 5f       	subi	r28, 0xFF	; 255
    2976:	f6 cf       	rjmp	.-20     	; 0x2964 <vStartFlashCoRoutines+0x24>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    2978:	40 e0       	ldi	r20, 0x00	; 0
    297a:	61 e0       	ldi	r22, 0x01	; 1
    297c:	81 e0       	ldi	r24, 0x01	; 1
    297e:	94 e1       	ldi	r25, 0x14	; 20
	}
}
    2980:	df 91       	pop	r29
    2982:	cf 91       	pop	r28
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    2984:	0c 94 3a 11 	jmp	0x2274	; 0x2274 <xCoRoutineCreate>
	}
}
    2988:	df 91       	pop	r29
    298a:	cf 91       	pop	r28
    298c:	08 95       	ret

0000298e <xAreFlashCoRoutinesStillRunning>:
BaseType_t xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    298e:	80 91 05 02 	lds	r24, 0x0205	; 0x800205 <xCoRoutineFlashStatus>
    2992:	08 95       	ret

00002994 <vStartIntegerMathTasks>:
static BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    2994:	ef 92       	push	r14
    2996:	ff 92       	push	r15
    2998:	0f 93       	push	r16
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    299a:	e1 2c       	mov	r14, r1
    299c:	f1 2c       	mov	r15, r1
    299e:	08 2f       	mov	r16, r24
    29a0:	2f ec       	ldi	r18, 0xCF	; 207
    29a2:	38 e0       	ldi	r19, 0x08	; 8
    29a4:	45 e5       	ldi	r20, 0x55	; 85
    29a6:	50 e0       	ldi	r21, 0x00	; 0
    29a8:	6b e2       	ldi	r22, 0x2B	; 43
    29aa:	72 e0       	ldi	r23, 0x02	; 2
    29ac:	86 eb       	ldi	r24, 0xB6	; 182
    29ae:	90 e0       	ldi	r25, 0x00	; 0
    29b0:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>
	}
}
    29b4:	0f 91       	pop	r16
    29b6:	ff 90       	pop	r15
    29b8:	ef 90       	pop	r14
    29ba:	08 95       	ret

000029bc <xAreIntegerMathsTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
BaseType_t xReturn = pdTRUE;
    29bc:	81 e0       	ldi	r24, 0x01	; 1
    29be:	90 91 cf 08 	lds	r25, 0x08CF	; 0x8008cf <xTaskCheck>
    29c2:	91 11       	cpse	r25, r1
    29c4:	01 c0       	rjmp	.+2      	; 0x29c8 <xAreIntegerMathsTaskStillRunning+0xc>
    29c6:	80 e0       	ldi	r24, 0x00	; 0
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    29c8:	10 92 cf 08 	sts	0x08CF, r1	; 0x8008cf <xTaskCheck>
	}

	return xReturn;
}
    29cc:	08 95       	ret

000029ce <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    29ce:	ef 92       	push	r14
    29d0:	ff 92       	push	r15
    29d2:	0f 93       	push	r16
    29d4:	cf 93       	push	r28
    29d6:	c8 2f       	mov	r28, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    29d8:	40 e0       	ldi	r20, 0x00	; 0
    29da:	62 e0       	ldi	r22, 0x02	; 2
    29dc:	8a e0       	ldi	r24, 0x0A	; 10
    29de:	0e 94 a9 0c 	call	0x1952	; 0x1952 <xQueueGenericCreate>
    29e2:	90 93 d1 08 	sts	0x08D1, r25	; 0x8008d1 <xPolledQueue.2203+0x1>
    29e6:	80 93 d0 08 	sts	0x08D0, r24	; 0x8008d0 <xPolledQueue.2203>

	if( xPolledQueue != NULL )
    29ea:	89 2b       	or	r24, r25
    29ec:	b9 f0       	breq	.+46     	; 0x2a1c <vStartPolledQueueTasks+0x4e>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    29ee:	e1 2c       	mov	r14, r1
    29f0:	f1 2c       	mov	r15, r1
    29f2:	0c 2f       	mov	r16, r28
    29f4:	20 ed       	ldi	r18, 0xD0	; 208
    29f6:	38 e0       	ldi	r19, 0x08	; 8
    29f8:	45 e5       	ldi	r20, 0x55	; 85
    29fa:	50 e0       	ldi	r21, 0x00	; 0
    29fc:	63 e3       	ldi	r22, 0x33	; 51
    29fe:	72 e0       	ldi	r23, 0x02	; 2
    2a00:	8c e3       	ldi	r24, 0x3C	; 60
    2a02:	91 e0       	ldi	r25, 0x01	; 1
    2a04:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    2a08:	20 ed       	ldi	r18, 0xD0	; 208
    2a0a:	38 e0       	ldi	r19, 0x08	; 8
    2a0c:	45 e5       	ldi	r20, 0x55	; 85
    2a0e:	50 e0       	ldi	r21, 0x00	; 0
    2a10:	6b e3       	ldi	r22, 0x3B	; 59
    2a12:	72 e0       	ldi	r23, 0x02	; 2
    2a14:	8a e0       	ldi	r24, 0x0A	; 10
    2a16:	91 e0       	ldi	r25, 0x01	; 1
    2a18:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>
	}
}
    2a1c:	cf 91       	pop	r28
    2a1e:	0f 91       	pop	r16
    2a20:	ff 90       	pop	r15
    2a22:	ef 90       	pop	r14
    2a24:	08 95       	ret

00002a26 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2a26:	80 91 d3 08 	lds	r24, 0x08D3	; 0x8008d3 <xPollingConsumerCount>
    2a2a:	88 23       	and	r24, r24
    2a2c:	29 f0       	breq	.+10     	; 0x2a38 <xArePollingQueuesStillRunning+0x12>
		( xPollingProducerCount == pollqINITIAL_VALUE )
    2a2e:	90 91 d2 08 	lds	r25, 0x08D2	; 0x8008d2 <xPollingProducerCount>
	  )
	{
		xReturn = pdFALSE;
    2a32:	81 e0       	ldi	r24, 0x01	; 1
    2a34:	91 11       	cpse	r25, r1
    2a36:	01 c0       	rjmp	.+2      	; 0x2a3a <xArePollingQueuesStillRunning+0x14>
    2a38:	80 e0       	ldi	r24, 0x00	; 0
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    2a3a:	10 92 d3 08 	sts	0x08D3, r1	; 0x8008d3 <xPollingConsumerCount>
	xPollingProducerCount = pollqINITIAL_VALUE;
    2a3e:	10 92 d2 08 	sts	0x08D2, r1	; 0x8008d2 <xPollingProducerCount>

	return xReturn;
}
    2a42:	08 95       	ret

00002a44 <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
    2a44:	ef 92       	push	r14
    2a46:	ff 92       	push	r15
    2a48:	0f 93       	push	r16
    2a4a:	cf 93       	push	r28
    2a4c:	c8 2f       	mov	r28, r24
    2a4e:	cb 01       	movw	r24, r22
    2a50:	ba 01       	movw	r22, r20
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    2a52:	20 93 d5 08 	sts	0x08D5, r18	; 0x8008d5 <uxBaseLED>
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    2a56:	48 e1       	ldi	r20, 0x18	; 24
    2a58:	0e 94 8a 02 	call	0x514	; 0x514 <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
    2a5c:	0f ef       	ldi	r16, 0xFF	; 255
    2a5e:	0c 0f       	add	r16, r28
    2a60:	e1 2c       	mov	r14, r1
    2a62:	f1 2c       	mov	r15, r1
    2a64:	20 e0       	ldi	r18, 0x00	; 0
    2a66:	30 e0       	ldi	r19, 0x00	; 0
    2a68:	45 e5       	ldi	r20, 0x55	; 85
    2a6a:	50 e0       	ldi	r21, 0x00	; 0
    2a6c:	63 e4       	ldi	r22, 0x43	; 67
    2a6e:	72 e0       	ldi	r23, 0x02	; 2
    2a70:	85 eb       	ldi	r24, 0xB5	; 181
    2a72:	91 e0       	ldi	r25, 0x01	; 1
    2a74:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
    2a78:	0c 2f       	mov	r16, r28
    2a7a:	20 e0       	ldi	r18, 0x00	; 0
    2a7c:	30 e0       	ldi	r19, 0x00	; 0
    2a7e:	45 e5       	ldi	r20, 0x55	; 85
    2a80:	50 e0       	ldi	r21, 0x00	; 0
    2a82:	69 e4       	ldi	r22, 0x49	; 73
    2a84:	72 e0       	ldi	r23, 0x02	; 2
    2a86:	86 e7       	ldi	r24, 0x76	; 118
    2a88:	91 e0       	ldi	r25, 0x01	; 1
    2a8a:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>
}
    2a8e:	cf 91       	pop	r28
    2a90:	0f 91       	pop	r16
    2a92:	ff 90       	pop	r15
    2a94:	ef 90       	pop	r14
    2a96:	08 95       	ret

00002a98 <xAreComTestTasksStillRunning>:
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    2a98:	90 91 d4 08 	lds	r25, 0x08D4	; 0x8008d4 <uxRxLoops>
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    2a9c:	10 92 d4 08 	sts	0x08D4, r1	; 0x8008d4 <uxRxLoops>

	return xReturn;
    2aa0:	81 e0       	ldi	r24, 0x01	; 1
    2aa2:	91 11       	cpse	r25, r1
    2aa4:	01 c0       	rjmp	.+2      	; 0x2aa8 <xAreComTestTasksStillRunning+0x10>
    2aa6:	80 e0       	ldi	r24, 0x00	; 0
}
    2aa8:	08 95       	ret

00002aaa <system_tick>:
    2aaa:	8f 93       	push	r24
    2aac:	8f b7       	in	r24, 0x3f	; 63
    2aae:	8f 93       	push	r24
    2ab0:	f8 94       	cli
    2ab2:	80 91 da 08 	lds	r24, 0x08DA	; 0x8008da <__system_time>
    2ab6:	8f 5f       	subi	r24, 0xFF	; 255
    2ab8:	80 93 da 08 	sts	0x08DA, r24	; 0x8008da <__system_time>
    2abc:	80 91 db 08 	lds	r24, 0x08DB	; 0x8008db <__system_time+0x1>
    2ac0:	8f 4f       	sbci	r24, 0xFF	; 255
    2ac2:	80 93 db 08 	sts	0x08DB, r24	; 0x8008db <__system_time+0x1>
    2ac6:	80 91 dc 08 	lds	r24, 0x08DC	; 0x8008dc <__system_time+0x2>
    2aca:	8f 4f       	sbci	r24, 0xFF	; 255
    2acc:	80 93 dc 08 	sts	0x08DC, r24	; 0x8008dc <__system_time+0x2>
    2ad0:	80 91 dd 08 	lds	r24, 0x08DD	; 0x8008dd <__system_time+0x3>
    2ad4:	8f 4f       	sbci	r24, 0xFF	; 255
    2ad6:	80 93 dd 08 	sts	0x08DD, r24	; 0x8008dd <__system_time+0x3>
    2ada:	8f 91       	pop	r24
    2adc:	8f bf       	out	0x3f, r24	; 63
    2ade:	8f 91       	pop	r24
    2ae0:	08 95       	ret

00002ae2 <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

short main( void )
{
    2ae2:	ef 92       	push	r14
    2ae4:	ff 92       	push	r15
    2ae6:	0f 93       	push	r16
    2ae8:	cf 93       	push	r28
    2aea:	df 93       	push	r29
    2aec:	1f 92       	push	r1
    2aee:	cd b7       	in	r28, 0x3d	; 61
    2af0:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
    2af2:	41 e0       	ldi	r20, 0x01	; 1
    2af4:	50 e0       	ldi	r21, 0x00	; 0
    2af6:	60 e5       	ldi	r22, 0x50	; 80
    2af8:	70 e0       	ldi	r23, 0x00	; 0
    2afa:	ce 01       	movw	r24, r28
    2afc:	01 96       	adiw	r24, 0x01	; 1
    2afe:	0e 94 13 17 	call	0x2e26	; 0x2e26 <eeprom_read_block>
	ucCount++;
    2b02:	69 81       	ldd	r22, Y+1	; 0x01
    2b04:	6f 5f       	subi	r22, 0xFF	; 255
    2b06:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
    2b08:	80 e5       	ldi	r24, 0x50	; 80
    2b0a:	90 e0       	ldi	r25, 0x00	; 0
    2b0c:	0e 94 23 17 	call	0x2e46	; 0x2e46 <eeprom_write_byte>
short main( void )
{
	prvIncrementResetCount();

	/* Setup the LED's for output. */
	vParTestInitialise();
    2b10:	0e 94 39 02 	call	0x472	; 0x472 <vParTestInitialise>

	/* Create the standard demo tasks. */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
    2b14:	80 e0       	ldi	r24, 0x00	; 0
    2b16:	0e 94 ca 14 	call	0x2994	; 0x2994 <vStartIntegerMathTasks>
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
    2b1a:	24 e0       	ldi	r18, 0x04	; 4
    2b1c:	40 e0       	ldi	r20, 0x00	; 0
    2b1e:	52 ec       	ldi	r21, 0xC2	; 194
    2b20:	61 e0       	ldi	r22, 0x01	; 1
    2b22:	70 e0       	ldi	r23, 0x00	; 0
    2b24:	82 e0       	ldi	r24, 0x02	; 2
    2b26:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vAltStartComTestTasks>
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
    2b2a:	82 e0       	ldi	r24, 0x02	; 2
    2b2c:	0e 94 e7 14 	call	0x29ce	; 0x29ce <vStartPolledQueueTasks>
	vStartRegTestTasks();
    2b30:	0e 94 db 04 	call	0x9b6	; 0x9b6 <vStartRegTestTasks>

	/* Create the tasks defined within this file. */
	xTaskCreate( vErrorChecks, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
    2b34:	e1 2c       	mov	r14, r1
    2b36:	f1 2c       	mov	r15, r1
    2b38:	03 e0       	ldi	r16, 0x03	; 3
    2b3a:	20 e0       	ldi	r18, 0x00	; 0
    2b3c:	30 e0       	ldi	r19, 0x00	; 0
    2b3e:	45 e5       	ldi	r20, 0x55	; 85
    2b40:	50 e0       	ldi	r21, 0x00	; 0
    2b42:	66 e1       	ldi	r22, 0x16	; 22
    2b44:	72 e0       	ldi	r23, 0x02	; 2
    2b46:	8e ef       	ldi	r24, 0xFE	; 254
    2b48:	91 e0       	ldi	r25, 0x01	; 1
    2b4a:	0e 94 5d 05 	call	0xaba	; 0xaba <xTaskCreate>

	/* Create the co-routines that flash the LED's. */
	vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES );
    2b4e:	83 e0       	ldi	r24, 0x03	; 3
    2b50:	0e 94 a0 14 	call	0x2940	; 0x2940 <vStartFlashCoRoutines>

	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    2b54:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vTaskStartScheduler>

	return 0;
}
    2b58:	80 e0       	ldi	r24, 0x00	; 0
    2b5a:	90 e0       	ldi	r25, 0x00	; 0
    2b5c:	0f 90       	pop	r0
    2b5e:	df 91       	pop	r29
    2b60:	cf 91       	pop	r28
    2b62:	0f 91       	pop	r16
    2b64:	ff 90       	pop	r15
    2b66:	ef 90       	pop	r14
    2b68:	08 95       	ret

00002b6a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2b6a:	0f 92       	push	r0
    2b6c:	0f b6       	in	r0, 0x3f	; 63
    2b6e:	f8 94       	cli
    2b70:	0f 92       	push	r0
    2b72:	0b b6       	in	r0, 0x3b	; 59
    2b74:	0f 92       	push	r0
    2b76:	0c b6       	in	r0, 0x3c	; 60
    2b78:	0f 92       	push	r0
    2b7a:	1f 92       	push	r1
    2b7c:	11 24       	eor	r1, r1
    2b7e:	2f 92       	push	r2
    2b80:	3f 92       	push	r3
    2b82:	4f 92       	push	r4
    2b84:	5f 92       	push	r5
    2b86:	6f 92       	push	r6
    2b88:	7f 92       	push	r7
    2b8a:	8f 92       	push	r8
    2b8c:	9f 92       	push	r9
    2b8e:	af 92       	push	r10
    2b90:	bf 92       	push	r11
    2b92:	cf 92       	push	r12
    2b94:	df 92       	push	r13
    2b96:	ef 92       	push	r14
    2b98:	ff 92       	push	r15
    2b9a:	0f 93       	push	r16
    2b9c:	1f 93       	push	r17
    2b9e:	2f 93       	push	r18
    2ba0:	3f 93       	push	r19
    2ba2:	4f 93       	push	r20
    2ba4:	5f 93       	push	r21
    2ba6:	6f 93       	push	r22
    2ba8:	7f 93       	push	r23
    2baa:	8f 93       	push	r24
    2bac:	9f 93       	push	r25
    2bae:	af 93       	push	r26
    2bb0:	bf 93       	push	r27
    2bb2:	cf 93       	push	r28
    2bb4:	df 93       	push	r29
    2bb6:	ef 93       	push	r30
    2bb8:	ff 93       	push	r31
    2bba:	a0 91 56 02 	lds	r26, 0x0256	; 0x800256 <pxCurrentTCB>
    2bbe:	b0 91 57 02 	lds	r27, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    2bc2:	0d b6       	in	r0, 0x3d	; 61
    2bc4:	0d 92       	st	X+, r0
    2bc6:	0e b6       	in	r0, 0x3e	; 62
    2bc8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2bca:	0e 94 63 08 	call	0x10c6	; 0x10c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2bce:	a0 91 56 02 	lds	r26, 0x0256	; 0x800256 <pxCurrentTCB>
    2bd2:	b0 91 57 02 	lds	r27, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    2bd6:	cd 91       	ld	r28, X+
    2bd8:	cd bf       	out	0x3d, r28	; 61
    2bda:	dd 91       	ld	r29, X+
    2bdc:	de bf       	out	0x3e, r29	; 62
    2bde:	ff 91       	pop	r31
    2be0:	ef 91       	pop	r30
    2be2:	df 91       	pop	r29
    2be4:	cf 91       	pop	r28
    2be6:	bf 91       	pop	r27
    2be8:	af 91       	pop	r26
    2bea:	9f 91       	pop	r25
    2bec:	8f 91       	pop	r24
    2bee:	7f 91       	pop	r23
    2bf0:	6f 91       	pop	r22
    2bf2:	5f 91       	pop	r21
    2bf4:	4f 91       	pop	r20
    2bf6:	3f 91       	pop	r19
    2bf8:	2f 91       	pop	r18
    2bfa:	1f 91       	pop	r17
    2bfc:	0f 91       	pop	r16
    2bfe:	ff 90       	pop	r15
    2c00:	ef 90       	pop	r14
    2c02:	df 90       	pop	r13
    2c04:	cf 90       	pop	r12
    2c06:	bf 90       	pop	r11
    2c08:	af 90       	pop	r10
    2c0a:	9f 90       	pop	r9
    2c0c:	8f 90       	pop	r8
    2c0e:	7f 90       	pop	r7
    2c10:	6f 90       	pop	r6
    2c12:	5f 90       	pop	r5
    2c14:	4f 90       	pop	r4
    2c16:	3f 90       	pop	r3
    2c18:	2f 90       	pop	r2
    2c1a:	1f 90       	pop	r1
    2c1c:	0f 90       	pop	r0
    2c1e:	0c be       	out	0x3c, r0	; 60
    2c20:	0f 90       	pop	r0
    2c22:	0b be       	out	0x3b, r0	; 59
    2c24:	0f 90       	pop	r0
    2c26:	0f be       	out	0x3f, r0	; 63
    2c28:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2c2a:	08 95       	ret

00002c2c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2c2c:	0f 92       	push	r0
    2c2e:	0f b6       	in	r0, 0x3f	; 63
    2c30:	f8 94       	cli
    2c32:	0f 92       	push	r0
    2c34:	0b b6       	in	r0, 0x3b	; 59
    2c36:	0f 92       	push	r0
    2c38:	0c b6       	in	r0, 0x3c	; 60
    2c3a:	0f 92       	push	r0
    2c3c:	1f 92       	push	r1
    2c3e:	11 24       	eor	r1, r1
    2c40:	2f 92       	push	r2
    2c42:	3f 92       	push	r3
    2c44:	4f 92       	push	r4
    2c46:	5f 92       	push	r5
    2c48:	6f 92       	push	r6
    2c4a:	7f 92       	push	r7
    2c4c:	8f 92       	push	r8
    2c4e:	9f 92       	push	r9
    2c50:	af 92       	push	r10
    2c52:	bf 92       	push	r11
    2c54:	cf 92       	push	r12
    2c56:	df 92       	push	r13
    2c58:	ef 92       	push	r14
    2c5a:	ff 92       	push	r15
    2c5c:	0f 93       	push	r16
    2c5e:	1f 93       	push	r17
    2c60:	2f 93       	push	r18
    2c62:	3f 93       	push	r19
    2c64:	4f 93       	push	r20
    2c66:	5f 93       	push	r21
    2c68:	6f 93       	push	r22
    2c6a:	7f 93       	push	r23
    2c6c:	8f 93       	push	r24
    2c6e:	9f 93       	push	r25
    2c70:	af 93       	push	r26
    2c72:	bf 93       	push	r27
    2c74:	cf 93       	push	r28
    2c76:	df 93       	push	r29
    2c78:	ef 93       	push	r30
    2c7a:	ff 93       	push	r31
    2c7c:	a0 91 56 02 	lds	r26, 0x0256	; 0x800256 <pxCurrentTCB>
    2c80:	b0 91 57 02 	lds	r27, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    2c84:	0d b6       	in	r0, 0x3d	; 61
    2c86:	0d 92       	st	X+, r0
    2c88:	0e b6       	in	r0, 0x3e	; 62
    2c8a:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    2c8c:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    2c8e:	80 91 d8 08 	lds	r24, 0x08D8	; 0x8008d8 <ticksRemainingInSec>
    2c92:	90 91 d9 08 	lds	r25, 0x08D9	; 0x8008d9 <ticksRemainingInSec+0x1>
    2c96:	01 97       	sbiw	r24, 0x01	; 1
    2c98:	90 93 d9 08 	sts	0x08D9, r25	; 0x8008d9 <ticksRemainingInSec+0x1>
    2c9c:	80 93 d8 08 	sts	0x08D8, r24	; 0x8008d8 <ticksRemainingInSec>
    2ca0:	89 2b       	or	r24, r25
    2ca2:	51 f4       	brne	.+20     	; 0x2cb8 <vPortYieldFromTick+0x8c>
	{
		system_tick();
    2ca4:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <system_tick>
		ticksRemainingInSec = portTickRateHz;
    2ca8:	80 91 d6 08 	lds	r24, 0x08D6	; 0x8008d6 <portTickRateHz>
    2cac:	90 91 d7 08 	lds	r25, 0x08D7	; 0x8008d7 <portTickRateHz+0x1>
    2cb0:	90 93 d9 08 	sts	0x08D9, r25	; 0x8008d9 <ticksRemainingInSec+0x1>
    2cb4:	80 93 d8 08 	sts	0x08D8, r24	; 0x8008d8 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    2cb8:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xTaskIncrementTick>
    2cbc:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2cbe:	0e 94 63 08 	call	0x10c6	; 0x10c6 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    2cc2:	a0 91 56 02 	lds	r26, 0x0256	; 0x800256 <pxCurrentTCB>
    2cc6:	b0 91 57 02 	lds	r27, 0x0257	; 0x800257 <pxCurrentTCB+0x1>
    2cca:	cd 91       	ld	r28, X+
    2ccc:	cd bf       	out	0x3d, r28	; 61
    2cce:	dd 91       	ld	r29, X+
    2cd0:	de bf       	out	0x3e, r29	; 62
    2cd2:	ff 91       	pop	r31
    2cd4:	ef 91       	pop	r30
    2cd6:	df 91       	pop	r29
    2cd8:	cf 91       	pop	r28
    2cda:	bf 91       	pop	r27
    2cdc:	af 91       	pop	r26
    2cde:	9f 91       	pop	r25
    2ce0:	8f 91       	pop	r24
    2ce2:	7f 91       	pop	r23
    2ce4:	6f 91       	pop	r22
    2ce6:	5f 91       	pop	r21
    2ce8:	4f 91       	pop	r20
    2cea:	3f 91       	pop	r19
    2cec:	2f 91       	pop	r18
    2cee:	1f 91       	pop	r17
    2cf0:	0f 91       	pop	r16
    2cf2:	ff 90       	pop	r15
    2cf4:	ef 90       	pop	r14
    2cf6:	df 90       	pop	r13
    2cf8:	cf 90       	pop	r12
    2cfa:	bf 90       	pop	r11
    2cfc:	af 90       	pop	r10
    2cfe:	9f 90       	pop	r9
    2d00:	8f 90       	pop	r8
    2d02:	7f 90       	pop	r7
    2d04:	6f 90       	pop	r6
    2d06:	5f 90       	pop	r5
    2d08:	4f 90       	pop	r4
    2d0a:	3f 90       	pop	r3
    2d0c:	2f 90       	pop	r2
    2d0e:	1f 90       	pop	r1
    2d10:	0f 90       	pop	r0
    2d12:	0c be       	out	0x3c, r0	; 60
    2d14:	0f 90       	pop	r0
    2d16:	0b be       	out	0x3b, r0	; 59
    2d18:	0f 90       	pop	r0
    2d1a:	0f be       	out	0x3f, r0	; 63
    2d1c:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2d1e:	08 95       	ret

00002d20 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    2d20:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    2d24:	18 95       	reti

00002d26 <__udivmodhi4>:
    2d26:	aa 1b       	sub	r26, r26
    2d28:	bb 1b       	sub	r27, r27
    2d2a:	51 e1       	ldi	r21, 0x11	; 17
    2d2c:	07 c0       	rjmp	.+14     	; 0x2d3c <__udivmodhi4_ep>

00002d2e <__udivmodhi4_loop>:
    2d2e:	aa 1f       	adc	r26, r26
    2d30:	bb 1f       	adc	r27, r27
    2d32:	a6 17       	cp	r26, r22
    2d34:	b7 07       	cpc	r27, r23
    2d36:	10 f0       	brcs	.+4      	; 0x2d3c <__udivmodhi4_ep>
    2d38:	a6 1b       	sub	r26, r22
    2d3a:	b7 0b       	sbc	r27, r23

00002d3c <__udivmodhi4_ep>:
    2d3c:	88 1f       	adc	r24, r24
    2d3e:	99 1f       	adc	r25, r25
    2d40:	5a 95       	dec	r21
    2d42:	a9 f7       	brne	.-22     	; 0x2d2e <__udivmodhi4_loop>
    2d44:	80 95       	com	r24
    2d46:	90 95       	com	r25
    2d48:	bc 01       	movw	r22, r24
    2d4a:	cd 01       	movw	r24, r26
    2d4c:	08 95       	ret

00002d4e <__udivmodsi4>:
    2d4e:	a1 e2       	ldi	r26, 0x21	; 33
    2d50:	1a 2e       	mov	r1, r26
    2d52:	aa 1b       	sub	r26, r26
    2d54:	bb 1b       	sub	r27, r27
    2d56:	fd 01       	movw	r30, r26
    2d58:	0d c0       	rjmp	.+26     	; 0x2d74 <__udivmodsi4_ep>

00002d5a <__udivmodsi4_loop>:
    2d5a:	aa 1f       	adc	r26, r26
    2d5c:	bb 1f       	adc	r27, r27
    2d5e:	ee 1f       	adc	r30, r30
    2d60:	ff 1f       	adc	r31, r31
    2d62:	a2 17       	cp	r26, r18
    2d64:	b3 07       	cpc	r27, r19
    2d66:	e4 07       	cpc	r30, r20
    2d68:	f5 07       	cpc	r31, r21
    2d6a:	20 f0       	brcs	.+8      	; 0x2d74 <__udivmodsi4_ep>
    2d6c:	a2 1b       	sub	r26, r18
    2d6e:	b3 0b       	sbc	r27, r19
    2d70:	e4 0b       	sbc	r30, r20
    2d72:	f5 0b       	sbc	r31, r21

00002d74 <__udivmodsi4_ep>:
    2d74:	66 1f       	adc	r22, r22
    2d76:	77 1f       	adc	r23, r23
    2d78:	88 1f       	adc	r24, r24
    2d7a:	99 1f       	adc	r25, r25
    2d7c:	1a 94       	dec	r1
    2d7e:	69 f7       	brne	.-38     	; 0x2d5a <__udivmodsi4_loop>
    2d80:	60 95       	com	r22
    2d82:	70 95       	com	r23
    2d84:	80 95       	com	r24
    2d86:	90 95       	com	r25
    2d88:	9b 01       	movw	r18, r22
    2d8a:	ac 01       	movw	r20, r24
    2d8c:	bd 01       	movw	r22, r26
    2d8e:	cf 01       	movw	r24, r30
    2d90:	08 95       	ret

00002d92 <__divmodsi4>:
    2d92:	05 2e       	mov	r0, r21
    2d94:	97 fb       	bst	r25, 7
    2d96:	1e f4       	brtc	.+6      	; 0x2d9e <__divmodsi4+0xc>
    2d98:	00 94       	com	r0
    2d9a:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__negsi2>
    2d9e:	57 fd       	sbrc	r21, 7
    2da0:	07 d0       	rcall	.+14     	; 0x2db0 <__divmodsi4_neg2>
    2da2:	0e 94 a7 16 	call	0x2d4e	; 0x2d4e <__udivmodsi4>
    2da6:	07 fc       	sbrc	r0, 7
    2da8:	03 d0       	rcall	.+6      	; 0x2db0 <__divmodsi4_neg2>
    2daa:	4e f4       	brtc	.+18     	; 0x2dbe <__divmodsi4_exit>
    2dac:	0c 94 e0 16 	jmp	0x2dc0	; 0x2dc0 <__negsi2>

00002db0 <__divmodsi4_neg2>:
    2db0:	50 95       	com	r21
    2db2:	40 95       	com	r20
    2db4:	30 95       	com	r19
    2db6:	21 95       	neg	r18
    2db8:	3f 4f       	sbci	r19, 0xFF	; 255
    2dba:	4f 4f       	sbci	r20, 0xFF	; 255
    2dbc:	5f 4f       	sbci	r21, 0xFF	; 255

00002dbe <__divmodsi4_exit>:
    2dbe:	08 95       	ret

00002dc0 <__negsi2>:
    2dc0:	90 95       	com	r25
    2dc2:	80 95       	com	r24
    2dc4:	70 95       	com	r23
    2dc6:	61 95       	neg	r22
    2dc8:	7f 4f       	sbci	r23, 0xFF	; 255
    2dca:	8f 4f       	sbci	r24, 0xFF	; 255
    2dcc:	9f 4f       	sbci	r25, 0xFF	; 255
    2dce:	08 95       	ret

00002dd0 <__muluhisi3>:
    2dd0:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <__umulhisi3>
    2dd4:	a5 9f       	mul	r26, r21
    2dd6:	90 0d       	add	r25, r0
    2dd8:	b4 9f       	mul	r27, r20
    2dda:	90 0d       	add	r25, r0
    2ddc:	a4 9f       	mul	r26, r20
    2dde:	80 0d       	add	r24, r0
    2de0:	91 1d       	adc	r25, r1
    2de2:	11 24       	eor	r1, r1
    2de4:	08 95       	ret

00002de6 <__mulshisi3>:
    2de6:	b7 ff       	sbrs	r27, 7
    2de8:	0c 94 e8 16 	jmp	0x2dd0	; 0x2dd0 <__muluhisi3>

00002dec <__mulohisi3>:
    2dec:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__muluhisi3>
    2df0:	82 1b       	sub	r24, r18
    2df2:	93 0b       	sbc	r25, r19
    2df4:	08 95       	ret

00002df6 <__umulhisi3>:
    2df6:	a2 9f       	mul	r26, r18
    2df8:	b0 01       	movw	r22, r0
    2dfa:	b3 9f       	mul	r27, r19
    2dfc:	c0 01       	movw	r24, r0
    2dfe:	a3 9f       	mul	r26, r19
    2e00:	70 0d       	add	r23, r0
    2e02:	81 1d       	adc	r24, r1
    2e04:	11 24       	eor	r1, r1
    2e06:	91 1d       	adc	r25, r1
    2e08:	b2 9f       	mul	r27, r18
    2e0a:	70 0d       	add	r23, r0
    2e0c:	81 1d       	adc	r24, r1
    2e0e:	11 24       	eor	r1, r1
    2e10:	91 1d       	adc	r25, r1
    2e12:	08 95       	ret

00002e14 <memcpy>:
    2e14:	fb 01       	movw	r30, r22
    2e16:	dc 01       	movw	r26, r24
    2e18:	02 c0       	rjmp	.+4      	; 0x2e1e <memcpy+0xa>
    2e1a:	01 90       	ld	r0, Z+
    2e1c:	0d 92       	st	X+, r0
    2e1e:	41 50       	subi	r20, 0x01	; 1
    2e20:	50 40       	sbci	r21, 0x00	; 0
    2e22:	d8 f7       	brcc	.-10     	; 0x2e1a <memcpy+0x6>
    2e24:	08 95       	ret

00002e26 <eeprom_read_block>:
    2e26:	dc 01       	movw	r26, r24
    2e28:	cb 01       	movw	r24, r22

00002e2a <eeprom_read_blraw>:
    2e2a:	fc 01       	movw	r30, r24
    2e2c:	f9 99       	sbic	0x1f, 1	; 31
    2e2e:	fe cf       	rjmp	.-4      	; 0x2e2c <eeprom_read_blraw+0x2>
    2e30:	06 c0       	rjmp	.+12     	; 0x2e3e <eeprom_read_blraw+0x14>
    2e32:	f2 bd       	out	0x22, r31	; 34
    2e34:	e1 bd       	out	0x21, r30	; 33
    2e36:	f8 9a       	sbi	0x1f, 0	; 31
    2e38:	31 96       	adiw	r30, 0x01	; 1
    2e3a:	00 b4       	in	r0, 0x20	; 32
    2e3c:	0d 92       	st	X+, r0
    2e3e:	41 50       	subi	r20, 0x01	; 1
    2e40:	50 40       	sbci	r21, 0x00	; 0
    2e42:	b8 f7       	brcc	.-18     	; 0x2e32 <eeprom_read_blraw+0x8>
    2e44:	08 95       	ret

00002e46 <eeprom_write_byte>:
    2e46:	26 2f       	mov	r18, r22

00002e48 <eeprom_write_r18>:
    2e48:	f9 99       	sbic	0x1f, 1	; 31
    2e4a:	fe cf       	rjmp	.-4      	; 0x2e48 <eeprom_write_r18>
    2e4c:	1f ba       	out	0x1f, r1	; 31
    2e4e:	92 bd       	out	0x22, r25	; 34
    2e50:	81 bd       	out	0x21, r24	; 33
    2e52:	20 bd       	out	0x20, r18	; 32
    2e54:	0f b6       	in	r0, 0x3f	; 63
    2e56:	f8 94       	cli
    2e58:	fa 9a       	sbi	0x1f, 2	; 31
    2e5a:	f9 9a       	sbi	0x1f, 1	; 31
    2e5c:	0f be       	out	0x3f, r0	; 63
    2e5e:	01 96       	adiw	r24, 0x01	; 1
    2e60:	08 95       	ret

00002e62 <_exit>:
    2e62:	f8 94       	cli

00002e64 <__stop_program>:
    2e64:	ff cf       	rjmp	.-2      	; 0x2e64 <__stop_program>
