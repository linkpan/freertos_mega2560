   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	prvIsQueueEmpty:
  13               	.LFB22:
  14               		.file 1 "../../Source/queue.c"
   1:../../Source/queue.c **** /*
   2:../../Source/queue.c ****  * FreeRTOS Kernel V10.1.1
   3:../../Source/queue.c ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../../Source/queue.c ****  *
   5:../../Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../../Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../../Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:../../Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../../Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../../Source/queue.c ****  * subject to the following conditions:
  11:../../Source/queue.c ****  *
  12:../../Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../../Source/queue.c ****  * copies or substantial portions of the Software.
  14:../../Source/queue.c ****  *
  15:../../Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../../Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../../Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../../Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../../Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../../Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../../Source/queue.c ****  *
  22:../../Source/queue.c ****  * http://www.FreeRTOS.org
  23:../../Source/queue.c ****  * http://aws.amazon.com/freertos
  24:../../Source/queue.c ****  *
  25:../../Source/queue.c ****  * 1 tab == 4 spaces!
  26:../../Source/queue.c ****  */
  27:../../Source/queue.c **** 
  28:../../Source/queue.c **** #include <stdlib.h>
  29:../../Source/queue.c **** #include <string.h>
  30:../../Source/queue.c **** 
  31:../../Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:../../Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:../../Source/queue.c **** task.h is included from an application file. */
  34:../../Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:../../Source/queue.c **** 
  36:../../Source/queue.c **** #include "FreeRTOS.h"
  37:../../Source/queue.c **** #include "task.h"
  38:../../Source/queue.c **** #include "queue.h"
  39:../../Source/queue.c **** 
  40:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:../../Source/queue.c **** 	#include "croutine.h"
  42:../../Source/queue.c **** #endif
  43:../../Source/queue.c **** 
  44:../../Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:../../Source/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:../../Source/queue.c **** for the header files above, but not in this file, in order to generate the
  47:../../Source/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:../../Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:../../Source/queue.c **** 
  50:../../Source/queue.c **** 
  51:../../Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:../../Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:../../Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:../../Source/queue.c **** 
  55:../../Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:../../Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:../../Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:../../Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:../../Source/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:../../Source/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:../../Source/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:../../Source/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:../../Source/queue.c **** being used for. */
  64:../../Source/queue.c **** #define uxQueueType						pcHead
  65:../../Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:../../Source/queue.c **** 
  67:../../Source/queue.c **** typedef struct QueuePointers
  68:../../Source/queue.c **** {
  69:../../Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:../../Source/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:../../Source/queue.c **** } QueuePointers_t;
  72:../../Source/queue.c **** 
  73:../../Source/queue.c **** typedef struct SemaphoreData
  74:../../Source/queue.c **** {
  75:../../Source/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:../../Source/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:../../Source/queue.c **** } SemaphoreData_t;
  78:../../Source/queue.c **** 
  79:../../Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:../../Source/queue.c **** zero. */
  81:../../Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:../../Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:../../Source/queue.c **** 
  84:../../Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
  85:../../Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:../../Source/queue.c **** 	performed just because a higher priority task has been woken. */
  87:../../Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:../../Source/queue.c **** #else
  89:../../Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:../../Source/queue.c **** #endif
  91:../../Source/queue.c **** 
  92:../../Source/queue.c **** /*
  93:../../Source/queue.c ****  * Definition of the queue used by the scheduler.
  94:../../Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:../../Source/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:../../Source/queue.c ****  */
  97:../../Source/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
  98:../../Source/queue.c **** {
  99:../../Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:../../Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:../../Source/queue.c **** 
 102:../../Source/queue.c **** 	union
 103:../../Source/queue.c **** 	{
 104:../../Source/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:../../Source/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:../../Source/queue.c **** 	} u;
 107:../../Source/queue.c **** 
 108:../../Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:../../Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:../../Source/queue.c **** 
 111:../../Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:../../Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:../../Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:../../Source/queue.c **** 
 115:../../Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:../../Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:../../Source/queue.c **** 
 118:../../Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:../../Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:../../Source/queue.c **** 	#endif
 121:../../Source/queue.c **** 
 122:../../Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:../../Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:../../Source/queue.c **** 	#endif
 125:../../Source/queue.c **** 
 126:../../Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:../../Source/queue.c **** 		UBaseType_t uxQueueNumber;
 128:../../Source/queue.c **** 		uint8_t ucQueueType;
 129:../../Source/queue.c **** 	#endif
 130:../../Source/queue.c **** 
 131:../../Source/queue.c **** } xQUEUE;
 132:../../Source/queue.c **** 
 133:../../Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:../../Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:../../Source/queue.c **** typedef xQUEUE Queue_t;
 136:../../Source/queue.c **** 
 137:../../Source/queue.c **** /*-----------------------------------------------------------*/
 138:../../Source/queue.c **** 
 139:../../Source/queue.c **** /*
 140:../../Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:../../Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:../../Source/queue.c ****  */
 143:../../Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:../../Source/queue.c **** 
 145:../../Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:../../Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:../../Source/queue.c **** 	more user friendly. */
 148:../../Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:../../Source/queue.c **** 	{
 150:../../Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:../../Source/queue.c **** 		QueueHandle_t xHandle;
 152:../../Source/queue.c **** 	} xQueueRegistryItem;
 153:../../Source/queue.c **** 
 154:../../Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:../../Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:../../Source/queue.c **** 	debuggers. */
 157:../../Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:../../Source/queue.c **** 
 159:../../Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:../../Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:../../Source/queue.c **** 	array position being vacant. */
 162:../../Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:../../Source/queue.c **** 
 164:../../Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:../../Source/queue.c **** 
 166:../../Source/queue.c **** /*
 167:../../Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:../../Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:../../Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:../../Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:../../Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:../../Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:../../Source/queue.c ****  */
 174:../../Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:../../Source/queue.c **** 
 176:../../Source/queue.c **** /*
 177:../../Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:../../Source/queue.c ****  *
 179:../../Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:../../Source/queue.c ****  */
 181:../../Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:../../Source/queue.c **** 
 183:../../Source/queue.c **** /*
 184:../../Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:../../Source/queue.c ****  *
 186:../../Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:../../Source/queue.c ****  */
 188:../../Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:../../Source/queue.c **** 
 190:../../Source/queue.c **** /*
 191:../../Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:../../Source/queue.c ****  * back of the queue.
 193:../../Source/queue.c ****  */
 194:../../Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:../../Source/queue.c **** 
 196:../../Source/queue.c **** /*
 197:../../Source/queue.c ****  * Copies an item out of a queue.
 198:../../Source/queue.c ****  */
 199:../../Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:../../Source/queue.c **** 
 201:../../Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:../../Source/queue.c **** 	/*
 203:../../Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:../../Source/queue.c **** 	 * the queue set that the queue contains data.
 205:../../Source/queue.c **** 	 */
 206:../../Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 207:../../Source/queue.c **** #endif
 208:../../Source/queue.c **** 
 209:../../Source/queue.c **** /*
 210:../../Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:../../Source/queue.c ****  * dynamically to fill in the structure's members.
 212:../../Source/queue.c ****  */
 213:../../Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:../../Source/queue.c **** 
 215:../../Source/queue.c **** /*
 216:../../Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:../../Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:../../Source/queue.c ****  * as a mutex.
 219:../../Source/queue.c ****  */
 220:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:../../Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:../../Source/queue.c **** #endif
 223:../../Source/queue.c **** 
 224:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:../../Source/queue.c **** 	/*
 226:../../Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:../../Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:../../Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:../../Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:../../Source/queue.c **** 	 * that priority.
 231:../../Source/queue.c **** 	 */
 232:../../Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:../../Source/queue.c **** #endif
 234:../../Source/queue.c **** /*-----------------------------------------------------------*/
 235:../../Source/queue.c **** 
 236:../../Source/queue.c **** /*
 237:../../Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:../../Source/queue.c ****  * accessing the queue event lists.
 239:../../Source/queue.c ****  */
 240:../../Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:../../Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:../../Source/queue.c **** 	{														\
 243:../../Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:../../Source/queue.c **** 		{													\
 245:../../Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:../../Source/queue.c **** 		}													\
 247:../../Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:../../Source/queue.c **** 		{													\
 249:../../Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:../../Source/queue.c **** 		}													\
 251:../../Source/queue.c **** 	}														\
 252:../../Source/queue.c **** 	taskEXIT_CRITICAL()
 253:../../Source/queue.c **** /*-----------------------------------------------------------*/
 254:../../Source/queue.c **** 
 255:../../Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:../../Source/queue.c **** {
 257:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 258:../../Source/queue.c **** 
 259:../../Source/queue.c **** 	configASSERT( pxQueue );
 260:../../Source/queue.c **** 
 261:../../Source/queue.c **** 	taskENTER_CRITICAL();
 262:../../Source/queue.c **** 	{
 263:../../Source/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
 264:../../Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 265:../../Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 266:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 267:../../Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 268:../../Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 269:../../Source/queue.c **** 
 270:../../Source/queue.c **** 		if( xNewQueue == pdFALSE )
 271:../../Source/queue.c **** 		{
 272:../../Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:../../Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:../../Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:../../Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:../../Source/queue.c **** 			it will be possible to write to it. */
 277:../../Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 278:../../Source/queue.c **** 			{
 279:../../Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 280:../../Source/queue.c **** 				{
 281:../../Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 282:../../Source/queue.c **** 				}
 283:../../Source/queue.c **** 				else
 284:../../Source/queue.c **** 				{
 285:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:../../Source/queue.c **** 				}
 287:../../Source/queue.c **** 			}
 288:../../Source/queue.c **** 			else
 289:../../Source/queue.c **** 			{
 290:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:../../Source/queue.c **** 			}
 292:../../Source/queue.c **** 		}
 293:../../Source/queue.c **** 		else
 294:../../Source/queue.c **** 		{
 295:../../Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 297:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 298:../../Source/queue.c **** 		}
 299:../../Source/queue.c **** 	}
 300:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 301:../../Source/queue.c **** 
 302:../../Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:../../Source/queue.c **** 	versions. */
 304:../../Source/queue.c **** 	return pdPASS;
 305:../../Source/queue.c **** }
 306:../../Source/queue.c **** /*-----------------------------------------------------------*/
 307:../../Source/queue.c **** 
 308:../../Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:../../Source/queue.c **** 
 310:../../Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:../../Source/queue.c **** 	{
 312:../../Source/queue.c **** 	Queue_t *pxNewQueue;
 313:../../Source/queue.c **** 
 314:../../Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:../../Source/queue.c **** 
 316:../../Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:../../Source/queue.c **** 		supplied. */
 318:../../Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:../../Source/queue.c **** 
 320:../../Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:../../Source/queue.c **** 		should not be provided if the item size is 0. */
 322:../../Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:../../Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:../../Source/queue.c **** 
 325:../../Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:../../Source/queue.c **** 		{
 327:../../Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:../../Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:../../Source/queue.c **** 			the real queue and semaphore structures. */
 330:../../Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:../../Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:../../Source/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:../../Source/queue.c **** 		}
 334:../../Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:../../Source/queue.c **** 
 336:../../Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:../../Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:../../Source/queue.c **** 		but is already set. */
 339:../../Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:../../Source/queue.c **** 
 341:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 342:../../Source/queue.c **** 		{
 343:../../Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:../../Source/queue.c **** 			{
 345:../../Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:../../Source/queue.c **** 				note this queue was allocated statically in case the queue is
 347:../../Source/queue.c **** 				later deleted. */
 348:../../Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:../../Source/queue.c **** 			}
 350:../../Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:../../Source/queue.c **** 
 352:../../Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:../../Source/queue.c **** 		}
 354:../../Source/queue.c **** 		else
 355:../../Source/queue.c **** 		{
 356:../../Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 357:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:../../Source/queue.c **** 		}
 359:../../Source/queue.c **** 
 360:../../Source/queue.c **** 		return pxNewQueue;
 361:../../Source/queue.c **** 	}
 362:../../Source/queue.c **** 
 363:../../Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:../../Source/queue.c **** /*-----------------------------------------------------------*/
 365:../../Source/queue.c **** 
 366:../../Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:../../Source/queue.c **** 
 368:../../Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:../../Source/queue.c **** 	{
 370:../../Source/queue.c **** 	Queue_t *pxNewQueue;
 371:../../Source/queue.c **** 	size_t xQueueSizeInBytes;
 372:../../Source/queue.c **** 	uint8_t *pucQueueStorage;
 373:../../Source/queue.c **** 
 374:../../Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 375:../../Source/queue.c **** 
 376:../../Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 377:../../Source/queue.c **** 		{
 378:../../Source/queue.c **** 			/* There is not going to be a queue storage area. */
 379:../../Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 380:../../Source/queue.c **** 		}
 381:../../Source/queue.c **** 		else
 382:../../Source/queue.c **** 		{
 383:../../Source/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 384:../../Source/queue.c **** 			can be in the queue at any time. */
 385:../../Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 386:../../Source/queue.c **** 		}
 387:../../Source/queue.c **** 
 388:../../Source/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 389:../../Source/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 390:../../Source/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 391:../../Source/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 392:../../Source/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 393:../../Source/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 394:../../Source/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 395:../../Source/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 396:../../Source/queue.c **** 		two bytes). */
 397:../../Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
 398:../../Source/queue.c **** 
 399:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 400:../../Source/queue.c **** 		{
 401:../../Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 402:../../Source/queue.c **** 			storage area. */
 403:../../Source/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 404:../../Source/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 405:../../Source/queue.c **** 
 406:../../Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 407:../../Source/queue.c **** 			{
 408:../../Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 409:../../Source/queue.c **** 				note this task was created dynamically in case it is later
 410:../../Source/queue.c **** 				deleted. */
 411:../../Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 412:../../Source/queue.c **** 			}
 413:../../Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 414:../../Source/queue.c **** 
 415:../../Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 416:../../Source/queue.c **** 		}
 417:../../Source/queue.c **** 		else
 418:../../Source/queue.c **** 		{
 419:../../Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 420:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 421:../../Source/queue.c **** 		}
 422:../../Source/queue.c **** 
 423:../../Source/queue.c **** 		return pxNewQueue;
 424:../../Source/queue.c **** 	}
 425:../../Source/queue.c **** 
 426:../../Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 427:../../Source/queue.c **** /*-----------------------------------------------------------*/
 428:../../Source/queue.c **** 
 429:../../Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 430:../../Source/queue.c **** {
 431:../../Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 432:../../Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 433:../../Source/queue.c **** 	( void ) ucQueueType;
 434:../../Source/queue.c **** 
 435:../../Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 436:../../Source/queue.c **** 	{
 437:../../Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 438:../../Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 439:../../Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 440:../../Source/queue.c **** 		value that is known to be within the memory map. */
 441:../../Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 442:../../Source/queue.c **** 	}
 443:../../Source/queue.c **** 	else
 444:../../Source/queue.c **** 	{
 445:../../Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 446:../../Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 447:../../Source/queue.c **** 	}
 448:../../Source/queue.c **** 
 449:../../Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 450:../../Source/queue.c **** 	defined. */
 451:../../Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 452:../../Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 453:../../Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 454:../../Source/queue.c **** 
 455:../../Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 456:../../Source/queue.c **** 	{
 457:../../Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 458:../../Source/queue.c **** 	}
 459:../../Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 460:../../Source/queue.c **** 
 461:../../Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 462:../../Source/queue.c **** 	{
 463:../../Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 464:../../Source/queue.c **** 	}
 465:../../Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 466:../../Source/queue.c **** 
 467:../../Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 468:../../Source/queue.c **** }
 469:../../Source/queue.c **** /*-----------------------------------------------------------*/
 470:../../Source/queue.c **** 
 471:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 472:../../Source/queue.c **** 
 473:../../Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 474:../../Source/queue.c **** 	{
 475:../../Source/queue.c **** 		if( pxNewQueue != NULL )
 476:../../Source/queue.c **** 		{
 477:../../Source/queue.c **** 			/* The queue create function will set all the queue structure members
 478:../../Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 479:../../Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 480:../../Source/queue.c **** 			in particular the information required for priority inheritance. */
 481:../../Source/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 482:../../Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 483:../../Source/queue.c **** 
 484:../../Source/queue.c **** 			/* In case this is a recursive mutex. */
 485:../../Source/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 486:../../Source/queue.c **** 
 487:../../Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 488:../../Source/queue.c **** 
 489:../../Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 490:../../Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 491:../../Source/queue.c **** 		}
 492:../../Source/queue.c **** 		else
 493:../../Source/queue.c **** 		{
 494:../../Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 495:../../Source/queue.c **** 		}
 496:../../Source/queue.c **** 	}
 497:../../Source/queue.c **** 
 498:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
 499:../../Source/queue.c **** /*-----------------------------------------------------------*/
 500:../../Source/queue.c **** 
 501:../../Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 502:../../Source/queue.c **** 
 503:../../Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 504:../../Source/queue.c **** 	{
 505:../../Source/queue.c **** 	QueueHandle_t xNewQueue;
 506:../../Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 507:../../Source/queue.c **** 
 508:../../Source/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 509:../../Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 510:../../Source/queue.c **** 
 511:../../Source/queue.c **** 		return xNewQueue;
 512:../../Source/queue.c **** 	}
 513:../../Source/queue.c **** 
 514:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
 515:../../Source/queue.c **** /*-----------------------------------------------------------*/
 516:../../Source/queue.c **** 
 517:../../Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 518:../../Source/queue.c **** 
 519:../../Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 520:../../Source/queue.c **** 	{
 521:../../Source/queue.c **** 	QueueHandle_t xNewQueue;
 522:../../Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 523:../../Source/queue.c **** 
 524:../../Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 525:../../Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 526:../../Source/queue.c **** 		( void ) ucQueueType;
 527:../../Source/queue.c **** 
 528:../../Source/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
 529:../../Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 530:../../Source/queue.c **** 
 531:../../Source/queue.c **** 		return xNewQueue;
 532:../../Source/queue.c **** 	}
 533:../../Source/queue.c **** 
 534:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
 535:../../Source/queue.c **** /*-----------------------------------------------------------*/
 536:../../Source/queue.c **** 
 537:../../Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 538:../../Source/queue.c **** 
 539:../../Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 540:../../Source/queue.c **** 	{
 541:../../Source/queue.c **** 	TaskHandle_t pxReturn;
 542:../../Source/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 543:../../Source/queue.c **** 
 544:../../Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 545:../../Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 546:../../Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 547:../../Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 548:../../Source/queue.c **** 		following critical section exiting and the function returning. */
 549:../../Source/queue.c **** 		taskENTER_CRITICAL();
 550:../../Source/queue.c **** 		{
 551:../../Source/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 552:../../Source/queue.c **** 			{
 553:../../Source/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 554:../../Source/queue.c **** 			}
 555:../../Source/queue.c **** 			else
 556:../../Source/queue.c **** 			{
 557:../../Source/queue.c **** 				pxReturn = NULL;
 558:../../Source/queue.c **** 			}
 559:../../Source/queue.c **** 		}
 560:../../Source/queue.c **** 		taskEXIT_CRITICAL();
 561:../../Source/queue.c **** 
 562:../../Source/queue.c **** 		return pxReturn;
 563:../../Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 564:../../Source/queue.c **** 
 565:../../Source/queue.c **** #endif
 566:../../Source/queue.c **** /*-----------------------------------------------------------*/
 567:../../Source/queue.c **** 
 568:../../Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 569:../../Source/queue.c **** 
 570:../../Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 571:../../Source/queue.c **** 	{
 572:../../Source/queue.c **** 	TaskHandle_t pxReturn;
 573:../../Source/queue.c **** 
 574:../../Source/queue.c **** 		configASSERT( xSemaphore );
 575:../../Source/queue.c **** 
 576:../../Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 577:../../Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 578:../../Source/queue.c **** 		not required here. */
 579:../../Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 580:../../Source/queue.c **** 		{
 581:../../Source/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 582:../../Source/queue.c **** 		}
 583:../../Source/queue.c **** 		else
 584:../../Source/queue.c **** 		{
 585:../../Source/queue.c **** 			pxReturn = NULL;
 586:../../Source/queue.c **** 		}
 587:../../Source/queue.c **** 
 588:../../Source/queue.c **** 		return pxReturn;
 589:../../Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 590:../../Source/queue.c **** 
 591:../../Source/queue.c **** #endif
 592:../../Source/queue.c **** /*-----------------------------------------------------------*/
 593:../../Source/queue.c **** 
 594:../../Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 595:../../Source/queue.c **** 
 596:../../Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 597:../../Source/queue.c **** 	{
 598:../../Source/queue.c **** 	BaseType_t xReturn;
 599:../../Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 600:../../Source/queue.c **** 
 601:../../Source/queue.c **** 		configASSERT( pxMutex );
 602:../../Source/queue.c **** 
 603:../../Source/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 604:../../Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 605:../../Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 606:../../Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 607:../../Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 608:../../Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 609:../../Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 610:../../Source/queue.c **** 		{
 611:../../Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 612:../../Source/queue.c **** 
 613:../../Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 614:../../Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 615:../../Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 616:../../Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 617:../../Source/queue.c **** 			uxRecursiveCallCount member. */
 618:../../Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 619:../../Source/queue.c **** 
 620:../../Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 621:../../Source/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 622:../../Source/queue.c **** 			{
 623:../../Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 624:../../Source/queue.c **** 				task that might be waiting to access the mutex. */
 625:../../Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 626:../../Source/queue.c **** 			}
 627:../../Source/queue.c **** 			else
 628:../../Source/queue.c **** 			{
 629:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 630:../../Source/queue.c **** 			}
 631:../../Source/queue.c **** 
 632:../../Source/queue.c **** 			xReturn = pdPASS;
 633:../../Source/queue.c **** 		}
 634:../../Source/queue.c **** 		else
 635:../../Source/queue.c **** 		{
 636:../../Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 637:../../Source/queue.c **** 			holder. */
 638:../../Source/queue.c **** 			xReturn = pdFAIL;
 639:../../Source/queue.c **** 
 640:../../Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 641:../../Source/queue.c **** 		}
 642:../../Source/queue.c **** 
 643:../../Source/queue.c **** 		return xReturn;
 644:../../Source/queue.c **** 	}
 645:../../Source/queue.c **** 
 646:../../Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 647:../../Source/queue.c **** /*-----------------------------------------------------------*/
 648:../../Source/queue.c **** 
 649:../../Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 650:../../Source/queue.c **** 
 651:../../Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 652:../../Source/queue.c **** 	{
 653:../../Source/queue.c **** 	BaseType_t xReturn;
 654:../../Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 655:../../Source/queue.c **** 
 656:../../Source/queue.c **** 		configASSERT( pxMutex );
 657:../../Source/queue.c **** 
 658:../../Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 659:../../Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 660:../../Source/queue.c **** 
 661:../../Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 662:../../Source/queue.c **** 
 663:../../Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 664:../../Source/queue.c **** 		{
 665:../../Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 666:../../Source/queue.c **** 			xReturn = pdPASS;
 667:../../Source/queue.c **** 		}
 668:../../Source/queue.c **** 		else
 669:../../Source/queue.c **** 		{
 670:../../Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 671:../../Source/queue.c **** 
 672:../../Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 673:../../Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 674:../../Source/queue.c **** 			before reaching here. */
 675:../../Source/queue.c **** 			if( xReturn != pdFAIL )
 676:../../Source/queue.c **** 			{
 677:../../Source/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 678:../../Source/queue.c **** 			}
 679:../../Source/queue.c **** 			else
 680:../../Source/queue.c **** 			{
 681:../../Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 682:../../Source/queue.c **** 			}
 683:../../Source/queue.c **** 		}
 684:../../Source/queue.c **** 
 685:../../Source/queue.c **** 		return xReturn;
 686:../../Source/queue.c **** 	}
 687:../../Source/queue.c **** 
 688:../../Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 689:../../Source/queue.c **** /*-----------------------------------------------------------*/
 690:../../Source/queue.c **** 
 691:../../Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 692:../../Source/queue.c **** 
 693:../../Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 694:../../Source/queue.c **** 	{
 695:../../Source/queue.c **** 	QueueHandle_t xHandle;
 696:../../Source/queue.c **** 
 697:../../Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 698:../../Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 699:../../Source/queue.c **** 
 700:../../Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 701:../../Source/queue.c **** 
 702:../../Source/queue.c **** 		if( xHandle != NULL )
 703:../../Source/queue.c **** 		{
 704:../../Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 705:../../Source/queue.c **** 
 706:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 707:../../Source/queue.c **** 		}
 708:../../Source/queue.c **** 		else
 709:../../Source/queue.c **** 		{
 710:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 711:../../Source/queue.c **** 		}
 712:../../Source/queue.c **** 
 713:../../Source/queue.c **** 		return xHandle;
 714:../../Source/queue.c **** 	}
 715:../../Source/queue.c **** 
 716:../../Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 717:../../Source/queue.c **** /*-----------------------------------------------------------*/
 718:../../Source/queue.c **** 
 719:../../Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 720:../../Source/queue.c **** 
 721:../../Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 722:../../Source/queue.c **** 	{
 723:../../Source/queue.c **** 	QueueHandle_t xHandle;
 724:../../Source/queue.c **** 
 725:../../Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 726:../../Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 727:../../Source/queue.c **** 
 728:../../Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 729:../../Source/queue.c **** 
 730:../../Source/queue.c **** 		if( xHandle != NULL )
 731:../../Source/queue.c **** 		{
 732:../../Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 733:../../Source/queue.c **** 
 734:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 735:../../Source/queue.c **** 		}
 736:../../Source/queue.c **** 		else
 737:../../Source/queue.c **** 		{
 738:../../Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 739:../../Source/queue.c **** 		}
 740:../../Source/queue.c **** 
 741:../../Source/queue.c **** 		return xHandle;
 742:../../Source/queue.c **** 	}
 743:../../Source/queue.c **** 
 744:../../Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 745:../../Source/queue.c **** /*-----------------------------------------------------------*/
 746:../../Source/queue.c **** 
 747:../../Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 748:../../Source/queue.c **** {
 749:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 750:../../Source/queue.c **** TimeOut_t xTimeOut;
 751:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 752:../../Source/queue.c **** 
 753:../../Source/queue.c **** 	configASSERT( pxQueue );
 754:../../Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 755:../../Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 756:../../Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 757:../../Source/queue.c **** 	{
 758:../../Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 759:../../Source/queue.c **** 	}
 760:../../Source/queue.c **** 	#endif
 761:../../Source/queue.c **** 
 762:../../Source/queue.c **** 
 763:../../Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 764:../../Source/queue.c **** 	allow return statements within the function itself.  This is done in the
 765:../../Source/queue.c **** 	interest of execution time efficiency. */
 766:../../Source/queue.c **** 	for( ;; )
 767:../../Source/queue.c **** 	{
 768:../../Source/queue.c **** 		taskENTER_CRITICAL();
 769:../../Source/queue.c **** 		{
 770:../../Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 771:../../Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 772:../../Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 773:../../Source/queue.c **** 			queue is full. */
 774:../../Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 775:../../Source/queue.c **** 			{
 776:../../Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 777:../../Source/queue.c **** 
 778:../../Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 779:../../Source/queue.c **** 				{
 780:../../Source/queue.c **** 				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 781:../../Source/queue.c **** 
 782:../../Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 783:../../Source/queue.c **** 
 784:../../Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 785:../../Source/queue.c **** 					{
 786:../../Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 787:../../Source/queue.c **** 						{
 788:../../Source/queue.c **** 							/* Do not notify the queue set as an existing item
 789:../../Source/queue.c **** 							was overwritten in the queue so the number of items
 790:../../Source/queue.c **** 							in the queue has not changed. */
 791:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 792:../../Source/queue.c **** 						}
 793:../../Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 794:../../Source/queue.c **** 						{
 795:../../Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 796:../../Source/queue.c **** 							to the queue set caused a higher priority task to
 797:../../Source/queue.c **** 							unblock. A context switch is required. */
 798:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 799:../../Source/queue.c **** 						}
 800:../../Source/queue.c **** 						else
 801:../../Source/queue.c **** 						{
 802:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 803:../../Source/queue.c **** 						}
 804:../../Source/queue.c **** 					}
 805:../../Source/queue.c **** 					else
 806:../../Source/queue.c **** 					{
 807:../../Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 808:../../Source/queue.c **** 						queue then unblock it now. */
 809:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 810:../../Source/queue.c **** 						{
 811:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 812:../../Source/queue.c **** 							{
 813:../../Source/queue.c **** 								/* The unblocked task has a priority higher than
 814:../../Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 815:../../Source/queue.c **** 								do this from within the critical section - the
 816:../../Source/queue.c **** 								kernel takes care of that. */
 817:../../Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 818:../../Source/queue.c **** 							}
 819:../../Source/queue.c **** 							else
 820:../../Source/queue.c **** 							{
 821:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 822:../../Source/queue.c **** 							}
 823:../../Source/queue.c **** 						}
 824:../../Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 825:../../Source/queue.c **** 						{
 826:../../Source/queue.c **** 							/* This path is a special case that will only get
 827:../../Source/queue.c **** 							executed if the task was holding multiple mutexes
 828:../../Source/queue.c **** 							and the mutexes were given back in an order that is
 829:../../Source/queue.c **** 							different to that in which they were taken. */
 830:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 831:../../Source/queue.c **** 						}
 832:../../Source/queue.c **** 						else
 833:../../Source/queue.c **** 						{
 834:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 835:../../Source/queue.c **** 						}
 836:../../Source/queue.c **** 					}
 837:../../Source/queue.c **** 				}
 838:../../Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 839:../../Source/queue.c **** 				{
 840:../../Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 841:../../Source/queue.c **** 
 842:../../Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 843:../../Source/queue.c **** 					queue then unblock it now. */
 844:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 845:../../Source/queue.c **** 					{
 846:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 847:../../Source/queue.c **** 						{
 848:../../Source/queue.c **** 							/* The unblocked task has a priority higher than
 849:../../Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 850:../../Source/queue.c **** 							this from within the critical section - the kernel
 851:../../Source/queue.c **** 							takes care of that. */
 852:../../Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 853:../../Source/queue.c **** 						}
 854:../../Source/queue.c **** 						else
 855:../../Source/queue.c **** 						{
 856:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 857:../../Source/queue.c **** 						}
 858:../../Source/queue.c **** 					}
 859:../../Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 860:../../Source/queue.c **** 					{
 861:../../Source/queue.c **** 						/* This path is a special case that will only get
 862:../../Source/queue.c **** 						executed if the task was holding multiple mutexes and
 863:../../Source/queue.c **** 						the mutexes were given back in an order that is
 864:../../Source/queue.c **** 						different to that in which they were taken. */
 865:../../Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 866:../../Source/queue.c **** 					}
 867:../../Source/queue.c **** 					else
 868:../../Source/queue.c **** 					{
 869:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 870:../../Source/queue.c **** 					}
 871:../../Source/queue.c **** 				}
 872:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 873:../../Source/queue.c **** 
 874:../../Source/queue.c **** 				taskEXIT_CRITICAL();
 875:../../Source/queue.c **** 				return pdPASS;
 876:../../Source/queue.c **** 			}
 877:../../Source/queue.c **** 			else
 878:../../Source/queue.c **** 			{
 879:../../Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 880:../../Source/queue.c **** 				{
 881:../../Source/queue.c **** 					/* The queue was full and no block time is specified (or
 882:../../Source/queue.c **** 					the block time has expired) so leave now. */
 883:../../Source/queue.c **** 					taskEXIT_CRITICAL();
 884:../../Source/queue.c **** 
 885:../../Source/queue.c **** 					/* Return to the original privilege level before exiting
 886:../../Source/queue.c **** 					the function. */
 887:../../Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 888:../../Source/queue.c **** 					return errQUEUE_FULL;
 889:../../Source/queue.c **** 				}
 890:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 891:../../Source/queue.c **** 				{
 892:../../Source/queue.c **** 					/* The queue was full and a block time was specified so
 893:../../Source/queue.c **** 					configure the timeout structure. */
 894:../../Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 895:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 896:../../Source/queue.c **** 				}
 897:../../Source/queue.c **** 				else
 898:../../Source/queue.c **** 				{
 899:../../Source/queue.c **** 					/* Entry time was already set. */
 900:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 901:../../Source/queue.c **** 				}
 902:../../Source/queue.c **** 			}
 903:../../Source/queue.c **** 		}
 904:../../Source/queue.c **** 		taskEXIT_CRITICAL();
 905:../../Source/queue.c **** 
 906:../../Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 907:../../Source/queue.c **** 		now the critical section has been exited. */
 908:../../Source/queue.c **** 
 909:../../Source/queue.c **** 		vTaskSuspendAll();
 910:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 911:../../Source/queue.c **** 
 912:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 913:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 914:../../Source/queue.c **** 		{
 915:../../Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 916:../../Source/queue.c **** 			{
 917:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 918:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 919:../../Source/queue.c **** 
 920:../../Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 921:../../Source/queue.c **** 				event list.  It is possible that interrupts occurring now
 922:../../Source/queue.c **** 				remove this task from the event list again - but as the
 923:../../Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 924:../../Source/queue.c **** 				ready last instead of the actual ready list. */
 925:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 926:../../Source/queue.c **** 
 927:../../Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 928:../../Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 929:../../Source/queue.c **** 				task is already in a ready list before it yields - in which
 930:../../Source/queue.c **** 				case the yield will not cause a context switch unless there
 931:../../Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 932:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 933:../../Source/queue.c **** 				{
 934:../../Source/queue.c **** 					portYIELD_WITHIN_API();
 935:../../Source/queue.c **** 				}
 936:../../Source/queue.c **** 			}
 937:../../Source/queue.c **** 			else
 938:../../Source/queue.c **** 			{
 939:../../Source/queue.c **** 				/* Try again. */
 940:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 941:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 942:../../Source/queue.c **** 			}
 943:../../Source/queue.c **** 		}
 944:../../Source/queue.c **** 		else
 945:../../Source/queue.c **** 		{
 946:../../Source/queue.c **** 			/* The timeout has expired. */
 947:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
 948:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 949:../../Source/queue.c **** 
 950:../../Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 951:../../Source/queue.c **** 			return errQUEUE_FULL;
 952:../../Source/queue.c **** 		}
 953:../../Source/queue.c **** 	} /*lint -restore */
 954:../../Source/queue.c **** }
 955:../../Source/queue.c **** /*-----------------------------------------------------------*/
 956:../../Source/queue.c **** 
 957:../../Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 958:../../Source/queue.c **** {
 959:../../Source/queue.c **** BaseType_t xReturn;
 960:../../Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 961:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 962:../../Source/queue.c **** 
 963:../../Source/queue.c **** 	configASSERT( pxQueue );
 964:../../Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 965:../../Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 966:../../Source/queue.c **** 
 967:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 968:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 969:../../Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 970:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 971:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 972:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 973:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 974:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 975:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 976:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 977:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 978:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 979:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 980:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 981:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 982:../../Source/queue.c **** 
 983:../../Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 984:../../Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 985:../../Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 986:../../Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 987:../../Source/queue.c **** 	post). */
 988:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 989:../../Source/queue.c **** 	{
 990:../../Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 991:../../Source/queue.c **** 		{
 992:../../Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 993:../../Source/queue.c **** 
 994:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 995:../../Source/queue.c **** 
 996:../../Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 997:../../Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 998:../../Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 999:../../Source/queue.c **** 			called here even though the disinherit function does not check if
1000:../../Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
1001:../../Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1002:../../Source/queue.c **** 
1003:../../Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1004:../../Source/queue.c **** 			be done when the queue is unlocked later. */
1005:../../Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1006:../../Source/queue.c **** 			{
1007:../../Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1008:../../Source/queue.c **** 				{
1009:../../Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1010:../../Source/queue.c **** 					{
1011:../../Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
1012:../../Source/queue.c **** 						{
1013:../../Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1014:../../Source/queue.c **** 							to the queue set caused a higher priority task to
1015:../../Source/queue.c **** 							unblock.  A context switch is required. */
1016:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1017:../../Source/queue.c **** 							{
1018:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1019:../../Source/queue.c **** 							}
1020:../../Source/queue.c **** 							else
1021:../../Source/queue.c **** 							{
1022:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1023:../../Source/queue.c **** 							}
1024:../../Source/queue.c **** 						}
1025:../../Source/queue.c **** 						else
1026:../../Source/queue.c **** 						{
1027:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1028:../../Source/queue.c **** 						}
1029:../../Source/queue.c **** 					}
1030:../../Source/queue.c **** 					else
1031:../../Source/queue.c **** 					{
1032:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1033:../../Source/queue.c **** 						{
1034:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1035:../../Source/queue.c **** 							{
1036:../../Source/queue.c **** 								/* The task waiting has a higher priority so
1037:../../Source/queue.c **** 								record that a context switch is required. */
1038:../../Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1039:../../Source/queue.c **** 								{
1040:../../Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1041:../../Source/queue.c **** 								}
1042:../../Source/queue.c **** 								else
1043:../../Source/queue.c **** 								{
1044:../../Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1045:../../Source/queue.c **** 								}
1046:../../Source/queue.c **** 							}
1047:../../Source/queue.c **** 							else
1048:../../Source/queue.c **** 							{
1049:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1050:../../Source/queue.c **** 							}
1051:../../Source/queue.c **** 						}
1052:../../Source/queue.c **** 						else
1053:../../Source/queue.c **** 						{
1054:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1055:../../Source/queue.c **** 						}
1056:../../Source/queue.c **** 					}
1057:../../Source/queue.c **** 				}
1058:../../Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1059:../../Source/queue.c **** 				{
1060:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1061:../../Source/queue.c **** 					{
1062:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1063:../../Source/queue.c **** 						{
1064:../../Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1065:../../Source/queue.c **** 							context	switch is required. */
1066:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1067:../../Source/queue.c **** 							{
1068:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1069:../../Source/queue.c **** 							}
1070:../../Source/queue.c **** 							else
1071:../../Source/queue.c **** 							{
1072:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1073:../../Source/queue.c **** 							}
1074:../../Source/queue.c **** 						}
1075:../../Source/queue.c **** 						else
1076:../../Source/queue.c **** 						{
1077:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1078:../../Source/queue.c **** 						}
1079:../../Source/queue.c **** 					}
1080:../../Source/queue.c **** 					else
1081:../../Source/queue.c **** 					{
1082:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1083:../../Source/queue.c **** 					}
1084:../../Source/queue.c **** 				}
1085:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1086:../../Source/queue.c **** 			}
1087:../../Source/queue.c **** 			else
1088:../../Source/queue.c **** 			{
1089:../../Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1090:../../Source/queue.c **** 				knows that data was posted while it was locked. */
1091:../../Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1092:../../Source/queue.c **** 			}
1093:../../Source/queue.c **** 
1094:../../Source/queue.c **** 			xReturn = pdPASS;
1095:../../Source/queue.c **** 		}
1096:../../Source/queue.c **** 		else
1097:../../Source/queue.c **** 		{
1098:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1099:../../Source/queue.c **** 			xReturn = errQUEUE_FULL;
1100:../../Source/queue.c **** 		}
1101:../../Source/queue.c **** 	}
1102:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1103:../../Source/queue.c **** 
1104:../../Source/queue.c **** 	return xReturn;
1105:../../Source/queue.c **** }
1106:../../Source/queue.c **** /*-----------------------------------------------------------*/
1107:../../Source/queue.c **** 
1108:../../Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1109:../../Source/queue.c **** {
1110:../../Source/queue.c **** BaseType_t xReturn;
1111:../../Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1112:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1113:../../Source/queue.c **** 
1114:../../Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1115:../../Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1116:../../Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1117:../../Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1118:../../Source/queue.c **** 	post). */
1119:../../Source/queue.c **** 
1120:../../Source/queue.c **** 	configASSERT( pxQueue );
1121:../../Source/queue.c **** 
1122:../../Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1123:../../Source/queue.c **** 	if the item size is not 0. */
1124:../../Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1125:../../Source/queue.c **** 
1126:../../Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1127:../../Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1128:../../Source/queue.c **** 	interrupts, only tasks. */
1129:../../Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
1130:../../Source/queue.c **** 
1131:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1132:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1133:../../Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1134:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1135:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1136:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1137:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1138:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1139:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1140:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1141:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1142:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1143:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1144:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1145:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1146:../../Source/queue.c **** 
1147:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1148:../../Source/queue.c **** 	{
1149:../../Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1150:../../Source/queue.c **** 
1151:../../Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1152:../../Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1153:../../Source/queue.c **** 		space'. */
1154:../../Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
1155:../../Source/queue.c **** 		{
1156:../../Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
1157:../../Source/queue.c **** 
1158:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1159:../../Source/queue.c **** 
1160:../../Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1161:../../Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1162:../../Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1163:../../Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1164:../../Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1165:../../Source/queue.c **** 			messages (semaphores) available. */
1166:../../Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1167:../../Source/queue.c **** 
1168:../../Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1169:../../Source/queue.c **** 			be done when the queue is unlocked later. */
1170:../../Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1171:../../Source/queue.c **** 			{
1172:../../Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1173:../../Source/queue.c **** 				{
1174:../../Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1175:../../Source/queue.c **** 					{
1176:../../Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1177:../../Source/queue.c **** 						{
1178:../../Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1179:../../Source/queue.c **** 							posting	to the queue set caused a higher priority
1180:../../Source/queue.c **** 							task to	unblock.  A context switch is required. */
1181:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1182:../../Source/queue.c **** 							{
1183:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1184:../../Source/queue.c **** 							}
1185:../../Source/queue.c **** 							else
1186:../../Source/queue.c **** 							{
1187:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1188:../../Source/queue.c **** 							}
1189:../../Source/queue.c **** 						}
1190:../../Source/queue.c **** 						else
1191:../../Source/queue.c **** 						{
1192:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1193:../../Source/queue.c **** 						}
1194:../../Source/queue.c **** 					}
1195:../../Source/queue.c **** 					else
1196:../../Source/queue.c **** 					{
1197:../../Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1198:../../Source/queue.c **** 						{
1199:../../Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1200:../../Source/queue.c **** 							{
1201:../../Source/queue.c **** 								/* The task waiting has a higher priority so
1202:../../Source/queue.c **** 								record that a context switch is required. */
1203:../../Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1204:../../Source/queue.c **** 								{
1205:../../Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1206:../../Source/queue.c **** 								}
1207:../../Source/queue.c **** 								else
1208:../../Source/queue.c **** 								{
1209:../../Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1210:../../Source/queue.c **** 								}
1211:../../Source/queue.c **** 							}
1212:../../Source/queue.c **** 							else
1213:../../Source/queue.c **** 							{
1214:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1215:../../Source/queue.c **** 							}
1216:../../Source/queue.c **** 						}
1217:../../Source/queue.c **** 						else
1218:../../Source/queue.c **** 						{
1219:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1220:../../Source/queue.c **** 						}
1221:../../Source/queue.c **** 					}
1222:../../Source/queue.c **** 				}
1223:../../Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1224:../../Source/queue.c **** 				{
1225:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1226:../../Source/queue.c **** 					{
1227:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1228:../../Source/queue.c **** 						{
1229:../../Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1230:../../Source/queue.c **** 							context	switch is required. */
1231:../../Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1232:../../Source/queue.c **** 							{
1233:../../Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1234:../../Source/queue.c **** 							}
1235:../../Source/queue.c **** 							else
1236:../../Source/queue.c **** 							{
1237:../../Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1238:../../Source/queue.c **** 							}
1239:../../Source/queue.c **** 						}
1240:../../Source/queue.c **** 						else
1241:../../Source/queue.c **** 						{
1242:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1243:../../Source/queue.c **** 						}
1244:../../Source/queue.c **** 					}
1245:../../Source/queue.c **** 					else
1246:../../Source/queue.c **** 					{
1247:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1248:../../Source/queue.c **** 					}
1249:../../Source/queue.c **** 				}
1250:../../Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1251:../../Source/queue.c **** 			}
1252:../../Source/queue.c **** 			else
1253:../../Source/queue.c **** 			{
1254:../../Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1255:../../Source/queue.c **** 				knows that data was posted while it was locked. */
1256:../../Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1257:../../Source/queue.c **** 			}
1258:../../Source/queue.c **** 
1259:../../Source/queue.c **** 			xReturn = pdPASS;
1260:../../Source/queue.c **** 		}
1261:../../Source/queue.c **** 		else
1262:../../Source/queue.c **** 		{
1263:../../Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1264:../../Source/queue.c **** 			xReturn = errQUEUE_FULL;
1265:../../Source/queue.c **** 		}
1266:../../Source/queue.c **** 	}
1267:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1268:../../Source/queue.c **** 
1269:../../Source/queue.c **** 	return xReturn;
1270:../../Source/queue.c **** }
1271:../../Source/queue.c **** /*-----------------------------------------------------------*/
1272:../../Source/queue.c **** 
1273:../../Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1274:../../Source/queue.c **** {
1275:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1276:../../Source/queue.c **** TimeOut_t xTimeOut;
1277:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1278:../../Source/queue.c **** 
1279:../../Source/queue.c **** 	/* Check the pointer is not NULL. */
1280:../../Source/queue.c **** 	configASSERT( ( pxQueue ) );
1281:../../Source/queue.c **** 
1282:../../Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1283:../../Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1284:../../Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1285:../../Source/queue.c **** 
1286:../../Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1287:../../Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1288:../../Source/queue.c **** 	{
1289:../../Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1290:../../Source/queue.c **** 	}
1291:../../Source/queue.c **** 	#endif
1292:../../Source/queue.c **** 
1293:../../Source/queue.c **** 
1294:../../Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1295:../../Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1296:../../Source/queue.c **** 	interest of execution time efficiency. */
1297:../../Source/queue.c **** 	for( ;; )
1298:../../Source/queue.c **** 	{
1299:../../Source/queue.c **** 		taskENTER_CRITICAL();
1300:../../Source/queue.c **** 		{
1301:../../Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1302:../../Source/queue.c **** 
1303:../../Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1304:../../Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1305:../../Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1306:../../Source/queue.c **** 			{
1307:../../Source/queue.c **** 				/* Data available, remove one item. */
1308:../../Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1309:../../Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1310:../../Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1311:../../Source/queue.c **** 
1312:../../Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1313:../../Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1314:../../Source/queue.c **** 				task. */
1315:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1316:../../Source/queue.c **** 				{
1317:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1318:../../Source/queue.c **** 					{
1319:../../Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1320:../../Source/queue.c **** 					}
1321:../../Source/queue.c **** 					else
1322:../../Source/queue.c **** 					{
1323:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1324:../../Source/queue.c **** 					}
1325:../../Source/queue.c **** 				}
1326:../../Source/queue.c **** 				else
1327:../../Source/queue.c **** 				{
1328:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1329:../../Source/queue.c **** 				}
1330:../../Source/queue.c **** 
1331:../../Source/queue.c **** 				taskEXIT_CRITICAL();
1332:../../Source/queue.c **** 				return pdPASS;
1333:../../Source/queue.c **** 			}
1334:../../Source/queue.c **** 			else
1335:../../Source/queue.c **** 			{
1336:../../Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1337:../../Source/queue.c **** 				{
1338:../../Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1339:../../Source/queue.c **** 					the block time has expired) so leave now. */
1340:../../Source/queue.c **** 					taskEXIT_CRITICAL();
1341:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1342:../../Source/queue.c **** 					return errQUEUE_EMPTY;
1343:../../Source/queue.c **** 				}
1344:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1345:../../Source/queue.c **** 				{
1346:../../Source/queue.c **** 					/* The queue was empty and a block time was specified so
1347:../../Source/queue.c **** 					configure the timeout structure. */
1348:../../Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1349:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1350:../../Source/queue.c **** 				}
1351:../../Source/queue.c **** 				else
1352:../../Source/queue.c **** 				{
1353:../../Source/queue.c **** 					/* Entry time was already set. */
1354:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1355:../../Source/queue.c **** 				}
1356:../../Source/queue.c **** 			}
1357:../../Source/queue.c **** 		}
1358:../../Source/queue.c **** 		taskEXIT_CRITICAL();
1359:../../Source/queue.c **** 
1360:../../Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1361:../../Source/queue.c **** 		now the critical section has been exited. */
1362:../../Source/queue.c **** 
1363:../../Source/queue.c **** 		vTaskSuspendAll();
1364:../../Source/queue.c **** 		prvLockQueue( pxQueue );
1365:../../Source/queue.c **** 
1366:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1367:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1368:../../Source/queue.c **** 		{
1369:../../Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1370:../../Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1371:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1372:../../Source/queue.c **** 			{
1373:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1374:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1375:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1376:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1377:../../Source/queue.c **** 				{
1378:../../Source/queue.c **** 					portYIELD_WITHIN_API();
1379:../../Source/queue.c **** 				}
1380:../../Source/queue.c **** 				else
1381:../../Source/queue.c **** 				{
1382:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1383:../../Source/queue.c **** 				}
1384:../../Source/queue.c **** 			}
1385:../../Source/queue.c **** 			else
1386:../../Source/queue.c **** 			{
1387:../../Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1388:../../Source/queue.c **** 				data. */
1389:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1390:../../Source/queue.c **** 				( void ) xTaskResumeAll();
1391:../../Source/queue.c **** 			}
1392:../../Source/queue.c **** 		}
1393:../../Source/queue.c **** 		else
1394:../../Source/queue.c **** 		{
1395:../../Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1396:../../Source/queue.c **** 			back and attempt to read the data. */
1397:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
1398:../../Source/queue.c **** 			( void ) xTaskResumeAll();
1399:../../Source/queue.c **** 
1400:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1401:../../Source/queue.c **** 			{
1402:../../Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1403:../../Source/queue.c **** 				return errQUEUE_EMPTY;
1404:../../Source/queue.c **** 			}
1405:../../Source/queue.c **** 			else
1406:../../Source/queue.c **** 			{
1407:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1408:../../Source/queue.c **** 			}
1409:../../Source/queue.c **** 		}
1410:../../Source/queue.c **** 	} /*lint -restore */
1411:../../Source/queue.c **** }
1412:../../Source/queue.c **** /*-----------------------------------------------------------*/
1413:../../Source/queue.c **** 
1414:../../Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1415:../../Source/queue.c **** {
1416:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1417:../../Source/queue.c **** TimeOut_t xTimeOut;
1418:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1419:../../Source/queue.c **** 
1420:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1421:../../Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
1422:../../Source/queue.c **** #endif
1423:../../Source/queue.c **** 
1424:../../Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1425:../../Source/queue.c **** 	configASSERT( ( pxQueue ) );
1426:../../Source/queue.c **** 
1427:../../Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1428:../../Source/queue.c **** 	0. */
1429:../../Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1430:../../Source/queue.c **** 
1431:../../Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1432:../../Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1433:../../Source/queue.c **** 	{
1434:../../Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1435:../../Source/queue.c **** 	}
1436:../../Source/queue.c **** 	#endif
1437:../../Source/queue.c **** 
1438:../../Source/queue.c **** 
1439:../../Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1440:../../Source/queue.c **** 	statements within the function itself.  This is done in the interest
1441:../../Source/queue.c **** 	of execution time efficiency. */
1442:../../Source/queue.c **** 	for( ;; )
1443:../../Source/queue.c **** 	{
1444:../../Source/queue.c **** 		taskENTER_CRITICAL();
1445:../../Source/queue.c **** 		{
1446:../../Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1447:../../Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1448:../../Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1449:../../Source/queue.c **** 
1450:../../Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1451:../../Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1452:../../Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1453:../../Source/queue.c **** 			{
1454:../../Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1455:../../Source/queue.c **** 
1456:../../Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1457:../../Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1458:../../Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1459:../../Source/queue.c **** 
1460:../../Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1461:../../Source/queue.c **** 				{
1462:../../Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1463:../../Source/queue.c **** 					{
1464:../../Source/queue.c **** 						/* Record the information required to implement
1465:../../Source/queue.c **** 						priority inheritance should it become necessary. */
1466:../../Source/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1467:../../Source/queue.c **** 					}
1468:../../Source/queue.c **** 					else
1469:../../Source/queue.c **** 					{
1470:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1471:../../Source/queue.c **** 					}
1472:../../Source/queue.c **** 				}
1473:../../Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1474:../../Source/queue.c **** 
1475:../../Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1476:../../Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1477:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1478:../../Source/queue.c **** 				{
1479:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1480:../../Source/queue.c **** 					{
1481:../../Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1482:../../Source/queue.c **** 					}
1483:../../Source/queue.c **** 					else
1484:../../Source/queue.c **** 					{
1485:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1486:../../Source/queue.c **** 					}
1487:../../Source/queue.c **** 				}
1488:../../Source/queue.c **** 				else
1489:../../Source/queue.c **** 				{
1490:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1491:../../Source/queue.c **** 				}
1492:../../Source/queue.c **** 
1493:../../Source/queue.c **** 				taskEXIT_CRITICAL();
1494:../../Source/queue.c **** 				return pdPASS;
1495:../../Source/queue.c **** 			}
1496:../../Source/queue.c **** 			else
1497:../../Source/queue.c **** 			{
1498:../../Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1499:../../Source/queue.c **** 				{
1500:../../Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1501:../../Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1502:../../Source/queue.c **** 					if it were 0 the function would have exited. */
1503:../../Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1504:../../Source/queue.c **** 					{
1505:../../Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1506:../../Source/queue.c **** 					}
1507:../../Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1508:../../Source/queue.c **** 
1509:../../Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1510:../../Source/queue.c **** 					(or the block time has expired) so exit now. */
1511:../../Source/queue.c **** 					taskEXIT_CRITICAL();
1512:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1513:../../Source/queue.c **** 					return errQUEUE_EMPTY;
1514:../../Source/queue.c **** 				}
1515:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1516:../../Source/queue.c **** 				{
1517:../../Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1518:../../Source/queue.c **** 					so configure the timeout structure ready to block. */
1519:../../Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1520:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1521:../../Source/queue.c **** 				}
1522:../../Source/queue.c **** 				else
1523:../../Source/queue.c **** 				{
1524:../../Source/queue.c **** 					/* Entry time was already set. */
1525:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1526:../../Source/queue.c **** 				}
1527:../../Source/queue.c **** 			}
1528:../../Source/queue.c **** 		}
1529:../../Source/queue.c **** 		taskEXIT_CRITICAL();
1530:../../Source/queue.c **** 
1531:../../Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1532:../../Source/queue.c **** 		now the critical section has been exited. */
1533:../../Source/queue.c **** 
1534:../../Source/queue.c **** 		vTaskSuspendAll();
1535:../../Source/queue.c **** 		prvLockQueue( pxQueue );
1536:../../Source/queue.c **** 
1537:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1538:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1539:../../Source/queue.c **** 		{
1540:../../Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1541:../../Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1542:../../Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1543:../../Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1544:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1545:../../Source/queue.c **** 			{
1546:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1547:../../Source/queue.c **** 
1548:../../Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1549:../../Source/queue.c **** 				{
1550:../../Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1551:../../Source/queue.c **** 					{
1552:../../Source/queue.c **** 						taskENTER_CRITICAL();
1553:../../Source/queue.c **** 						{
1554:../../Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
1555:../../Source/queue.c **** 						}
1556:../../Source/queue.c **** 						taskEXIT_CRITICAL();
1557:../../Source/queue.c **** 					}
1558:../../Source/queue.c **** 					else
1559:../../Source/queue.c **** 					{
1560:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1561:../../Source/queue.c **** 					}
1562:../../Source/queue.c **** 				}
1563:../../Source/queue.c **** 				#endif
1564:../../Source/queue.c **** 
1565:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1566:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1567:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1568:../../Source/queue.c **** 				{
1569:../../Source/queue.c **** 					portYIELD_WITHIN_API();
1570:../../Source/queue.c **** 				}
1571:../../Source/queue.c **** 				else
1572:../../Source/queue.c **** 				{
1573:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1574:../../Source/queue.c **** 				}
1575:../../Source/queue.c **** 			}
1576:../../Source/queue.c **** 			else
1577:../../Source/queue.c **** 			{
1578:../../Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1579:../../Source/queue.c **** 				attempt to take the semaphore again. */
1580:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1581:../../Source/queue.c **** 				( void ) xTaskResumeAll();
1582:../../Source/queue.c **** 			}
1583:../../Source/queue.c **** 		}
1584:../../Source/queue.c **** 		else
1585:../../Source/queue.c **** 		{
1586:../../Source/queue.c **** 			/* Timed out. */
1587:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
1588:../../Source/queue.c **** 			( void ) xTaskResumeAll();
1589:../../Source/queue.c **** 
1590:../../Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1591:../../Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1592:../../Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1593:../../Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1594:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1595:../../Source/queue.c **** 			{
1596:../../Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1597:../../Source/queue.c **** 				{
1598:../../Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1599:../../Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1600:../../Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1601:../../Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
1602:../../Source/queue.c **** 					{
1603:../../Source/queue.c **** 						taskENTER_CRITICAL();
1604:../../Source/queue.c **** 						{
1605:../../Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1606:../../Source/queue.c **** 
1607:../../Source/queue.c **** 							/* This task blocking on the mutex caused another
1608:../../Source/queue.c **** 							task to inherit this task's priority.  Now this task
1609:../../Source/queue.c **** 							has timed out the priority should be disinherited
1610:../../Source/queue.c **** 							again, but only as low as the next highest priority
1611:../../Source/queue.c **** 							task that is waiting for the same mutex. */
1612:../../Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1613:../../Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
1614:../../Source/queue.c **** 						}
1615:../../Source/queue.c **** 						taskEXIT_CRITICAL();
1616:../../Source/queue.c **** 					}
1617:../../Source/queue.c **** 				}
1618:../../Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1619:../../Source/queue.c **** 
1620:../../Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1621:../../Source/queue.c **** 				return errQUEUE_EMPTY;
1622:../../Source/queue.c **** 			}
1623:../../Source/queue.c **** 			else
1624:../../Source/queue.c **** 			{
1625:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1626:../../Source/queue.c **** 			}
1627:../../Source/queue.c **** 		}
1628:../../Source/queue.c **** 	} /*lint -restore */
1629:../../Source/queue.c **** }
1630:../../Source/queue.c **** /*-----------------------------------------------------------*/
1631:../../Source/queue.c **** 
1632:../../Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1633:../../Source/queue.c **** {
1634:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1635:../../Source/queue.c **** TimeOut_t xTimeOut;
1636:../../Source/queue.c **** int8_t *pcOriginalReadPosition;
1637:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1638:../../Source/queue.c **** 
1639:../../Source/queue.c **** 	/* Check the pointer is not NULL. */
1640:../../Source/queue.c **** 	configASSERT( ( pxQueue ) );
1641:../../Source/queue.c **** 
1642:../../Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1643:../../Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1644:../../Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1645:../../Source/queue.c **** 
1646:../../Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1647:../../Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1648:../../Source/queue.c **** 	{
1649:../../Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1650:../../Source/queue.c **** 	}
1651:../../Source/queue.c **** 	#endif
1652:../../Source/queue.c **** 
1653:../../Source/queue.c **** 
1654:../../Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1655:../../Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1656:../../Source/queue.c **** 	interest of execution time efficiency. */
1657:../../Source/queue.c **** 	for( ;; )
1658:../../Source/queue.c **** 	{
1659:../../Source/queue.c **** 		taskENTER_CRITICAL();
1660:../../Source/queue.c **** 		{
1661:../../Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1662:../../Source/queue.c **** 
1663:../../Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1664:../../Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1665:../../Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1666:../../Source/queue.c **** 			{
1667:../../Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1668:../../Source/queue.c **** 				is read from the queue as this function is only peeking the
1669:../../Source/queue.c **** 				data, not removing it. */
1670:../../Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1671:../../Source/queue.c **** 
1672:../../Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1673:../../Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1674:../../Source/queue.c **** 
1675:../../Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1676:../../Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1677:../../Source/queue.c **** 
1678:../../Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1679:../../Source/queue.c **** 				any other tasks waiting for the data. */
1680:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1681:../../Source/queue.c **** 				{
1682:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1683:../../Source/queue.c **** 					{
1684:../../Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1685:../../Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1686:../../Source/queue.c **** 					}
1687:../../Source/queue.c **** 					else
1688:../../Source/queue.c **** 					{
1689:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1690:../../Source/queue.c **** 					}
1691:../../Source/queue.c **** 				}
1692:../../Source/queue.c **** 				else
1693:../../Source/queue.c **** 				{
1694:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1695:../../Source/queue.c **** 				}
1696:../../Source/queue.c **** 
1697:../../Source/queue.c **** 				taskEXIT_CRITICAL();
1698:../../Source/queue.c **** 				return pdPASS;
1699:../../Source/queue.c **** 			}
1700:../../Source/queue.c **** 			else
1701:../../Source/queue.c **** 			{
1702:../../Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1703:../../Source/queue.c **** 				{
1704:../../Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1705:../../Source/queue.c **** 					the block time has expired) so leave now. */
1706:../../Source/queue.c **** 					taskEXIT_CRITICAL();
1707:../../Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1708:../../Source/queue.c **** 					return errQUEUE_EMPTY;
1709:../../Source/queue.c **** 				}
1710:../../Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1711:../../Source/queue.c **** 				{
1712:../../Source/queue.c **** 					/* The queue was empty and a block time was specified so
1713:../../Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1714:../../Source/queue.c **** 					state. */
1715:../../Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1716:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1717:../../Source/queue.c **** 				}
1718:../../Source/queue.c **** 				else
1719:../../Source/queue.c **** 				{
1720:../../Source/queue.c **** 					/* Entry time was already set. */
1721:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1722:../../Source/queue.c **** 				}
1723:../../Source/queue.c **** 			}
1724:../../Source/queue.c **** 		}
1725:../../Source/queue.c **** 		taskEXIT_CRITICAL();
1726:../../Source/queue.c **** 
1727:../../Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1728:../../Source/queue.c **** 		now the critical section has been exited. */
1729:../../Source/queue.c **** 
1730:../../Source/queue.c **** 		vTaskSuspendAll();
1731:../../Source/queue.c **** 		prvLockQueue( pxQueue );
1732:../../Source/queue.c **** 
1733:../../Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1734:../../Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1735:../../Source/queue.c **** 		{
1736:../../Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1737:../../Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1738:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1739:../../Source/queue.c **** 			{
1740:../../Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1741:../../Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1742:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1743:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1744:../../Source/queue.c **** 				{
1745:../../Source/queue.c **** 					portYIELD_WITHIN_API();
1746:../../Source/queue.c **** 				}
1747:../../Source/queue.c **** 				else
1748:../../Source/queue.c **** 				{
1749:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1750:../../Source/queue.c **** 				}
1751:../../Source/queue.c **** 			}
1752:../../Source/queue.c **** 			else
1753:../../Source/queue.c **** 			{
1754:../../Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1755:../../Source/queue.c **** 				state, instead return to try and obtain the data. */
1756:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
1757:../../Source/queue.c **** 				( void ) xTaskResumeAll();
1758:../../Source/queue.c **** 			}
1759:../../Source/queue.c **** 		}
1760:../../Source/queue.c **** 		else
1761:../../Source/queue.c **** 		{
1762:../../Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1763:../../Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
1764:../../Source/queue.c **** 			prvUnlockQueue( pxQueue );
1765:../../Source/queue.c **** 			( void ) xTaskResumeAll();
1766:../../Source/queue.c **** 
1767:../../Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1768:../../Source/queue.c **** 			{
1769:../../Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1770:../../Source/queue.c **** 				return errQUEUE_EMPTY;
1771:../../Source/queue.c **** 			}
1772:../../Source/queue.c **** 			else
1773:../../Source/queue.c **** 			{
1774:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1775:../../Source/queue.c **** 			}
1776:../../Source/queue.c **** 		}
1777:../../Source/queue.c **** 	} /*lint -restore */
1778:../../Source/queue.c **** }
1779:../../Source/queue.c **** /*-----------------------------------------------------------*/
1780:../../Source/queue.c **** 
1781:../../Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1782:../../Source/queue.c **** {
1783:../../Source/queue.c **** BaseType_t xReturn;
1784:../../Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1785:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1786:../../Source/queue.c **** 
1787:../../Source/queue.c **** 	configASSERT( pxQueue );
1788:../../Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1789:../../Source/queue.c **** 
1790:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1791:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1792:../../Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1793:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1794:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1795:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1796:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1797:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1798:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1799:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1800:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1801:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1802:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1803:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1804:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1805:../../Source/queue.c **** 
1806:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1807:../../Source/queue.c **** 	{
1808:../../Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1809:../../Source/queue.c **** 
1810:../../Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1811:../../Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1812:../../Source/queue.c **** 		{
1813:../../Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
1814:../../Source/queue.c **** 
1815:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1816:../../Source/queue.c **** 
1817:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1818:../../Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1819:../../Source/queue.c **** 
1820:../../Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1821:../../Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1822:../../Source/queue.c **** 			will know that an ISR has removed data while the queue was
1823:../../Source/queue.c **** 			locked. */
1824:../../Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
1825:../../Source/queue.c **** 			{
1826:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1827:../../Source/queue.c **** 				{
1828:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1829:../../Source/queue.c **** 					{
1830:../../Source/queue.c **** 						/* The task waiting has a higher priority than us so
1831:../../Source/queue.c **** 						force a context switch. */
1832:../../Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1833:../../Source/queue.c **** 						{
1834:../../Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1835:../../Source/queue.c **** 						}
1836:../../Source/queue.c **** 						else
1837:../../Source/queue.c **** 						{
1838:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1839:../../Source/queue.c **** 						}
1840:../../Source/queue.c **** 					}
1841:../../Source/queue.c **** 					else
1842:../../Source/queue.c **** 					{
1843:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1844:../../Source/queue.c **** 					}
1845:../../Source/queue.c **** 				}
1846:../../Source/queue.c **** 				else
1847:../../Source/queue.c **** 				{
1848:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1849:../../Source/queue.c **** 				}
1850:../../Source/queue.c **** 			}
1851:../../Source/queue.c **** 			else
1852:../../Source/queue.c **** 			{
1853:../../Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1854:../../Source/queue.c **** 				knows that data was removed while it was locked. */
1855:../../Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1856:../../Source/queue.c **** 			}
1857:../../Source/queue.c **** 
1858:../../Source/queue.c **** 			xReturn = pdPASS;
1859:../../Source/queue.c **** 		}
1860:../../Source/queue.c **** 		else
1861:../../Source/queue.c **** 		{
1862:../../Source/queue.c **** 			xReturn = pdFAIL;
1863:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1864:../../Source/queue.c **** 		}
1865:../../Source/queue.c **** 	}
1866:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1867:../../Source/queue.c **** 
1868:../../Source/queue.c **** 	return xReturn;
1869:../../Source/queue.c **** }
1870:../../Source/queue.c **** /*-----------------------------------------------------------*/
1871:../../Source/queue.c **** 
1872:../../Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1873:../../Source/queue.c **** {
1874:../../Source/queue.c **** BaseType_t xReturn;
1875:../../Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1876:../../Source/queue.c **** int8_t *pcOriginalReadPosition;
1877:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1878:../../Source/queue.c **** 
1879:../../Source/queue.c **** 	configASSERT( pxQueue );
1880:../../Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1881:../../Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1882:../../Source/queue.c **** 
1883:../../Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1884:../../Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1885:../../Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1886:../../Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1887:../../Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1888:../../Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1889:../../Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1890:../../Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1891:../../Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1892:../../Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1893:../../Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1894:../../Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1895:../../Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1896:../../Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1897:../../Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1898:../../Source/queue.c **** 
1899:../../Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1900:../../Source/queue.c **** 	{
1901:../../Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1902:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1903:../../Source/queue.c **** 		{
1904:../../Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1905:../../Source/queue.c **** 
1906:../../Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1907:../../Source/queue.c **** 			actually being removed from the queue. */
1908:../../Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1909:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1910:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1911:../../Source/queue.c **** 
1912:../../Source/queue.c **** 			xReturn = pdPASS;
1913:../../Source/queue.c **** 		}
1914:../../Source/queue.c **** 		else
1915:../../Source/queue.c **** 		{
1916:../../Source/queue.c **** 			xReturn = pdFAIL;
1917:../../Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1918:../../Source/queue.c **** 		}
1919:../../Source/queue.c **** 	}
1920:../../Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1921:../../Source/queue.c **** 
1922:../../Source/queue.c **** 	return xReturn;
1923:../../Source/queue.c **** }
1924:../../Source/queue.c **** /*-----------------------------------------------------------*/
1925:../../Source/queue.c **** 
1926:../../Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1927:../../Source/queue.c **** {
1928:../../Source/queue.c **** UBaseType_t uxReturn;
1929:../../Source/queue.c **** 
1930:../../Source/queue.c **** 	configASSERT( xQueue );
1931:../../Source/queue.c **** 
1932:../../Source/queue.c **** 	taskENTER_CRITICAL();
1933:../../Source/queue.c **** 	{
1934:../../Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1935:../../Source/queue.c **** 	}
1936:../../Source/queue.c **** 	taskEXIT_CRITICAL();
1937:../../Source/queue.c **** 
1938:../../Source/queue.c **** 	return uxReturn;
1939:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1940:../../Source/queue.c **** /*-----------------------------------------------------------*/
1941:../../Source/queue.c **** 
1942:../../Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1943:../../Source/queue.c **** {
1944:../../Source/queue.c **** UBaseType_t uxReturn;
1945:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1946:../../Source/queue.c **** 
1947:../../Source/queue.c **** 	configASSERT( pxQueue );
1948:../../Source/queue.c **** 
1949:../../Source/queue.c **** 	taskENTER_CRITICAL();
1950:../../Source/queue.c **** 	{
1951:../../Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1952:../../Source/queue.c **** 	}
1953:../../Source/queue.c **** 	taskEXIT_CRITICAL();
1954:../../Source/queue.c **** 
1955:../../Source/queue.c **** 	return uxReturn;
1956:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1957:../../Source/queue.c **** /*-----------------------------------------------------------*/
1958:../../Source/queue.c **** 
1959:../../Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1960:../../Source/queue.c **** {
1961:../../Source/queue.c **** UBaseType_t uxReturn;
1962:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1963:../../Source/queue.c **** 
1964:../../Source/queue.c **** 	configASSERT( pxQueue );
1965:../../Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
1966:../../Source/queue.c **** 
1967:../../Source/queue.c **** 	return uxReturn;
1968:../../Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1969:../../Source/queue.c **** /*-----------------------------------------------------------*/
1970:../../Source/queue.c **** 
1971:../../Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1972:../../Source/queue.c **** {
1973:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
1974:../../Source/queue.c **** 
1975:../../Source/queue.c **** 	configASSERT( pxQueue );
1976:../../Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1977:../../Source/queue.c **** 
1978:../../Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1979:../../Source/queue.c **** 	{
1980:../../Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1981:../../Source/queue.c **** 	}
1982:../../Source/queue.c **** 	#endif
1983:../../Source/queue.c **** 
1984:../../Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1985:../../Source/queue.c **** 	{
1986:../../Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1987:../../Source/queue.c **** 		again. */
1988:../../Source/queue.c **** 		vPortFree( pxQueue );
1989:../../Source/queue.c **** 	}
1990:../../Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1991:../../Source/queue.c **** 	{
1992:../../Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1993:../../Source/queue.c **** 		check before attempting to free the memory. */
1994:../../Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1995:../../Source/queue.c **** 		{
1996:../../Source/queue.c **** 			vPortFree( pxQueue );
1997:../../Source/queue.c **** 		}
1998:../../Source/queue.c **** 		else
1999:../../Source/queue.c **** 		{
2000:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2001:../../Source/queue.c **** 		}
2002:../../Source/queue.c **** 	}
2003:../../Source/queue.c **** 	#else
2004:../../Source/queue.c **** 	{
2005:../../Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2006:../../Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2007:../../Source/queue.c **** 		( void ) pxQueue;
2008:../../Source/queue.c **** 	}
2009:../../Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2010:../../Source/queue.c **** }
2011:../../Source/queue.c **** /*-----------------------------------------------------------*/
2012:../../Source/queue.c **** 
2013:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2014:../../Source/queue.c **** 
2015:../../Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2016:../../Source/queue.c **** 	{
2017:../../Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2018:../../Source/queue.c **** 	}
2019:../../Source/queue.c **** 
2020:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2021:../../Source/queue.c **** /*-----------------------------------------------------------*/
2022:../../Source/queue.c **** 
2023:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2024:../../Source/queue.c **** 
2025:../../Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2026:../../Source/queue.c **** 	{
2027:../../Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2028:../../Source/queue.c **** 	}
2029:../../Source/queue.c **** 
2030:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2031:../../Source/queue.c **** /*-----------------------------------------------------------*/
2032:../../Source/queue.c **** 
2033:../../Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2034:../../Source/queue.c **** 
2035:../../Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2036:../../Source/queue.c **** 	{
2037:../../Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2038:../../Source/queue.c **** 	}
2039:../../Source/queue.c **** 
2040:../../Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2041:../../Source/queue.c **** /*-----------------------------------------------------------*/
2042:../../Source/queue.c **** 
2043:../../Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2044:../../Source/queue.c **** 
2045:../../Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2046:../../Source/queue.c **** 	{
2047:../../Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2048:../../Source/queue.c **** 
2049:../../Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2050:../../Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2051:../../Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2052:../../Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2053:../../Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2054:../../Source/queue.c **** 		mutex. */
2055:../../Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2056:../../Source/queue.c **** 		{
2057:../../Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
2058:../../Source/queue.c **** 		}
2059:../../Source/queue.c **** 		else
2060:../../Source/queue.c **** 		{
2061:../../Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2062:../../Source/queue.c **** 		}
2063:../../Source/queue.c **** 
2064:../../Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
2065:../../Source/queue.c **** 	}
2066:../../Source/queue.c **** 
2067:../../Source/queue.c **** #endif /* configUSE_MUTEXES */
2068:../../Source/queue.c **** /*-----------------------------------------------------------*/
2069:../../Source/queue.c **** 
2070:../../Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2071:../../Source/queue.c **** {
2072:../../Source/queue.c **** BaseType_t xReturn = pdFALSE;
2073:../../Source/queue.c **** UBaseType_t uxMessagesWaiting;
2074:../../Source/queue.c **** 
2075:../../Source/queue.c **** 	/* This function is called from a critical section. */
2076:../../Source/queue.c **** 
2077:../../Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2078:../../Source/queue.c **** 
2079:../../Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2080:../../Source/queue.c **** 	{
2081:../../Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2082:../../Source/queue.c **** 		{
2083:../../Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2084:../../Source/queue.c **** 			{
2085:../../Source/queue.c **** 				/* The mutex is no longer being held. */
2086:../../Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2087:../../Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
2088:../../Source/queue.c **** 			}
2089:../../Source/queue.c **** 			else
2090:../../Source/queue.c **** 			{
2091:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2092:../../Source/queue.c **** 			}
2093:../../Source/queue.c **** 		}
2094:../../Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2095:../../Source/queue.c **** 	}
2096:../../Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
2097:../../Source/queue.c **** 	{
2098:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
2099:../../Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
2100:../../Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
2101:../../Source/queue.c **** 		{
2102:../../Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
2103:../../Source/queue.c **** 		}
2104:../../Source/queue.c **** 		else
2105:../../Source/queue.c **** 		{
2106:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2107:../../Source/queue.c **** 		}
2108:../../Source/queue.c **** 	}
2109:../../Source/queue.c **** 	else
2110:../../Source/queue.c **** 	{
2111:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
2112:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2113:../../Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
2114:../../Source/queue.c **** 		{
2115:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2116:../../Source/queue.c **** 		}
2117:../../Source/queue.c **** 		else
2118:../../Source/queue.c **** 		{
2119:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2120:../../Source/queue.c **** 		}
2121:../../Source/queue.c **** 
2122:../../Source/queue.c **** 		if( xPosition == queueOVERWRITE )
2123:../../Source/queue.c **** 		{
2124:../../Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2125:../../Source/queue.c **** 			{
2126:../../Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2127:../../Source/queue.c **** 				one from the recorded number of items in the queue so when
2128:../../Source/queue.c **** 				one is added again below the number of recorded items remains
2129:../../Source/queue.c **** 				correct. */
2130:../../Source/queue.c **** 				--uxMessagesWaiting;
2131:../../Source/queue.c **** 			}
2132:../../Source/queue.c **** 			else
2133:../../Source/queue.c **** 			{
2134:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2135:../../Source/queue.c **** 			}
2136:../../Source/queue.c **** 		}
2137:../../Source/queue.c **** 		else
2138:../../Source/queue.c **** 		{
2139:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2140:../../Source/queue.c **** 		}
2141:../../Source/queue.c **** 	}
2142:../../Source/queue.c **** 
2143:../../Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2144:../../Source/queue.c **** 
2145:../../Source/queue.c **** 	return xReturn;
2146:../../Source/queue.c **** }
2147:../../Source/queue.c **** /*-----------------------------------------------------------*/
2148:../../Source/queue.c **** 
2149:../../Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2150:../../Source/queue.c **** {
2151:../../Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2152:../../Source/queue.c **** 	{
2153:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
2154:../../Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
2155:../../Source/queue.c **** 		{
2156:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2157:../../Source/queue.c **** 		}
2158:../../Source/queue.c **** 		else
2159:../../Source/queue.c **** 		{
2160:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2161:../../Source/queue.c **** 		}
2162:../../Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
2163:../../Source/queue.c **** 	}
2164:../../Source/queue.c **** }
2165:../../Source/queue.c **** /*-----------------------------------------------------------*/
2166:../../Source/queue.c **** 
2167:../../Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2168:../../Source/queue.c **** {
2169:../../Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2170:../../Source/queue.c **** 
2171:../../Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2172:../../Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2173:../../Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2174:../../Source/queue.c **** 	updated. */
2175:../../Source/queue.c **** 	taskENTER_CRITICAL();
2176:../../Source/queue.c **** 	{
2177:../../Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
2178:../../Source/queue.c **** 
2179:../../Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2180:../../Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
2181:../../Source/queue.c **** 		{
2182:../../Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2183:../../Source/queue.c **** 			blocked waiting for data to become available? */
2184:../../Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2185:../../Source/queue.c **** 			{
2186:../../Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2187:../../Source/queue.c **** 				{
2188:../../Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
2189:../../Source/queue.c **** 					{
2190:../../Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2191:../../Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2192:../../Source/queue.c **** 						A context switch is required. */
2193:../../Source/queue.c **** 						vTaskMissedYield();
2194:../../Source/queue.c **** 					}
2195:../../Source/queue.c **** 					else
2196:../../Source/queue.c **** 					{
2197:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2198:../../Source/queue.c **** 					}
2199:../../Source/queue.c **** 				}
2200:../../Source/queue.c **** 				else
2201:../../Source/queue.c **** 				{
2202:../../Source/queue.c **** 					/* Tasks that are removed from the event list will get
2203:../../Source/queue.c **** 					added to the pending ready list as the scheduler is still
2204:../../Source/queue.c **** 					suspended. */
2205:../../Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2206:../../Source/queue.c **** 					{
2207:../../Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2208:../../Source/queue.c **** 						{
2209:../../Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2210:../../Source/queue.c **** 							context	switch is required. */
2211:../../Source/queue.c **** 							vTaskMissedYield();
2212:../../Source/queue.c **** 						}
2213:../../Source/queue.c **** 						else
2214:../../Source/queue.c **** 						{
2215:../../Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2216:../../Source/queue.c **** 						}
2217:../../Source/queue.c **** 					}
2218:../../Source/queue.c **** 					else
2219:../../Source/queue.c **** 					{
2220:../../Source/queue.c **** 						break;
2221:../../Source/queue.c **** 					}
2222:../../Source/queue.c **** 				}
2223:../../Source/queue.c **** 			}
2224:../../Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2225:../../Source/queue.c **** 			{
2226:../../Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2227:../../Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2228:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2229:../../Source/queue.c **** 				{
2230:../../Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2231:../../Source/queue.c **** 					{
2232:../../Source/queue.c **** 						/* The task waiting has a higher priority so record that
2233:../../Source/queue.c **** 						a context switch is required. */
2234:../../Source/queue.c **** 						vTaskMissedYield();
2235:../../Source/queue.c **** 					}
2236:../../Source/queue.c **** 					else
2237:../../Source/queue.c **** 					{
2238:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2239:../../Source/queue.c **** 					}
2240:../../Source/queue.c **** 				}
2241:../../Source/queue.c **** 				else
2242:../../Source/queue.c **** 				{
2243:../../Source/queue.c **** 					break;
2244:../../Source/queue.c **** 				}
2245:../../Source/queue.c **** 			}
2246:../../Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2247:../../Source/queue.c **** 
2248:../../Source/queue.c **** 			--cTxLock;
2249:../../Source/queue.c **** 		}
2250:../../Source/queue.c **** 
2251:../../Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
2252:../../Source/queue.c **** 	}
2253:../../Source/queue.c **** 	taskEXIT_CRITICAL();
2254:../../Source/queue.c **** 
2255:../../Source/queue.c **** 	/* Do the same for the Rx lock. */
2256:../../Source/queue.c **** 	taskENTER_CRITICAL();
2257:../../Source/queue.c **** 	{
2258:../../Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
2259:../../Source/queue.c **** 
2260:../../Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
2261:../../Source/queue.c **** 		{
2262:../../Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2263:../../Source/queue.c **** 			{
2264:../../Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2265:../../Source/queue.c **** 				{
2266:../../Source/queue.c **** 					vTaskMissedYield();
2267:../../Source/queue.c **** 				}
2268:../../Source/queue.c **** 				else
2269:../../Source/queue.c **** 				{
2270:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2271:../../Source/queue.c **** 				}
2272:../../Source/queue.c **** 
2273:../../Source/queue.c **** 				--cRxLock;
2274:../../Source/queue.c **** 			}
2275:../../Source/queue.c **** 			else
2276:../../Source/queue.c **** 			{
2277:../../Source/queue.c **** 				break;
2278:../../Source/queue.c **** 			}
2279:../../Source/queue.c **** 		}
2280:../../Source/queue.c **** 
2281:../../Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
2282:../../Source/queue.c **** 	}
2283:../../Source/queue.c **** 	taskEXIT_CRITICAL();
2284:../../Source/queue.c **** }
2285:../../Source/queue.c **** /*-----------------------------------------------------------*/
2286:../../Source/queue.c **** 
2287:../../Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2288:../../Source/queue.c **** {
  15               		.loc 1 2288 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
2289:../../Source/queue.c **** BaseType_t xReturn;
2290:../../Source/queue.c **** 
2291:../../Source/queue.c **** 	taskENTER_CRITICAL();
  22               		.loc 1 2291 0
  23               	/* #APP */
  24               	 ;  2291 "../../Source/queue.c" 1
  25 0000 0FB6      		in __tmp_reg__, __SREG__
  26 0002 F894      		cli
  27 0004 0F92      		push __tmp_reg__
  28               		
  29               	 ;  0 "" 2
2292:../../Source/queue.c **** 	{
2293:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  30               		.loc 1 2293 0
  31               	/* #NOAPP */
  32 0006 FC01      		movw r30,r24
  33 0008 928D      		ldd r25,Z+26
  34               	.LVL1:
2294:../../Source/queue.c **** 		{
2295:../../Source/queue.c **** 			xReturn = pdTRUE;
2296:../../Source/queue.c **** 		}
2297:../../Source/queue.c **** 		else
2298:../../Source/queue.c **** 		{
2299:../../Source/queue.c **** 			xReturn = pdFALSE;
2300:../../Source/queue.c **** 		}
2301:../../Source/queue.c **** 	}
2302:../../Source/queue.c **** 	taskEXIT_CRITICAL();
  35               		.loc 1 2302 0
  36               	/* #APP */
  37               	 ;  2302 "../../Source/queue.c" 1
  38 000a 0F90      		pop __tmp_reg__
  39 000c 0FBE      		out __SREG__, __tmp_reg__
  40               		
  41               	 ;  0 "" 2
2303:../../Source/queue.c **** 
2304:../../Source/queue.c **** 	return xReturn;
  42               		.loc 1 2304 0
  43               	/* #NOAPP */
  44 000e 81E0      		ldi r24,lo8(1)
  45               	.LVL2:
  46 0010 9111      		cpse r25,__zero_reg__
  47 0012 80E0      		ldi r24,0
  48               	.L2:
2305:../../Source/queue.c **** }
  49               		.loc 1 2305 0
  50 0014 0895      		ret
  51               		.cfi_endproc
  52               	.LFE22:
  55               	prvCopyDataToQueue:
  56               	.LFB19:
2071:../../Source/queue.c **** BaseType_t xReturn = pdFALSE;
  57               		.loc 1 2071 0
  58               		.cfi_startproc
  59               	.LVL3:
  60 0016 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 4
  63               		.cfi_offset 16, -3
  64 0018 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 5
  67               		.cfi_offset 17, -4
  68 001a CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 6
  71               		.cfi_offset 28, -5
  72 001c DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 7
  75               		.cfi_offset 29, -6
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 001e EC01      		movw r28,r24
  81 0020 042F      		mov r16,r20
  82               	.LVL4:
2077:../../Source/queue.c **** 
  83               		.loc 1 2077 0
  84 0022 1A8D      		ldd r17,Y+26
  85               	.LVL5:
2079:../../Source/queue.c **** 	{
  86               		.loc 1 2079 0
  87 0024 4C8D      		ldd r20,Y+28
  88               	.LVL6:
  89 0026 4423      		tst r20
  90 0028 01F0      		breq .L8
  91 002a 50E0      		ldi r21,0
2096:../../Source/queue.c **** 	{
  92               		.loc 1 2096 0
  93 002c 0111      		cpse r16,__zero_reg__
  94 002e 00C0      		rjmp .L9
2098:../../Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
  95               		.loc 1 2098 0
  96 0030 8A81      		ldd r24,Y+2
  97 0032 9B81      		ldd r25,Y+3
  98               	.LVL7:
  99 0034 0E94 0000 		call memcpy
 100               	.LVL8:
2099:../../Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 101               		.loc 1 2099 0
 102 0038 2C8D      		ldd r18,Y+28
 103 003a 8A81      		ldd r24,Y+2
 104 003c 9B81      		ldd r25,Y+3
 105 003e 820F      		add r24,r18
 106 0040 911D      		adc r25,__zero_reg__
 107 0042 9B83      		std Y+3,r25
 108 0044 8A83      		std Y+2,r24
2100:../../Source/queue.c **** 		{
 109               		.loc 1 2100 0
 110 0046 2C81      		ldd r18,Y+4
 111 0048 3D81      		ldd r19,Y+5
 112 004a 8217      		cp r24,r18
 113 004c 9307      		cpc r25,r19
 114 004e 00F0      		brlo .L8
2102:../../Source/queue.c **** 		}
 115               		.loc 1 2102 0
 116 0050 8881      		ld r24,Y
 117 0052 9981      		ldd r25,Y+1
 118 0054 9B83      		std Y+3,r25
 119 0056 8A83      		std Y+2,r24
 120 0058 00C0      		rjmp .L8
 121               	.LVL9:
 122               	.L9:
2111:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 123               		.loc 1 2111 0
 124 005a 8E81      		ldd r24,Y+6
 125 005c 9F81      		ldd r25,Y+7
 126               	.LVL10:
 127 005e 0E94 0000 		call memcpy
 128               	.LVL11:
2112:../../Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 129               		.loc 1 2112 0
 130 0062 8C8D      		ldd r24,Y+28
 131 0064 90E0      		ldi r25,0
 132 0066 9195      		neg r25
 133 0068 8195      		neg r24
 134 006a 9109      		sbc r25,__zero_reg__
 135 006c 2E81      		ldd r18,Y+6
 136 006e 3F81      		ldd r19,Y+7
 137 0070 280F      		add r18,r24
 138 0072 391F      		adc r19,r25
 139 0074 3F83      		std Y+7,r19
 140 0076 2E83      		std Y+6,r18
2113:../../Source/queue.c **** 		{
 141               		.loc 1 2113 0
 142 0078 4881      		ld r20,Y
 143 007a 5981      		ldd r21,Y+1
 144 007c 2417      		cp r18,r20
 145 007e 3507      		cpc r19,r21
 146 0080 00F4      		brsh .L10
2115:../../Source/queue.c **** 		}
 147               		.loc 1 2115 0
 148 0082 2C81      		ldd r18,Y+4
 149 0084 3D81      		ldd r19,Y+5
 150 0086 820F      		add r24,r18
 151 0088 931F      		adc r25,r19
 152 008a 9F83      		std Y+7,r25
 153 008c 8E83      		std Y+6,r24
 154               	.L10:
2122:../../Source/queue.c **** 		{
 155               		.loc 1 2122 0
 156 008e 0230      		cpi r16,lo8(2)
 157 0090 01F4      		brne .L8
2124:../../Source/queue.c **** 			{
 158               		.loc 1 2124 0
 159 0092 1111      		cpse r17,__zero_reg__
2130:../../Source/queue.c **** 			}
 160               		.loc 1 2130 0
 161 0094 1150      		subi r17,lo8(-(-1))
 162               	.LVL12:
 163               	.L8:
2143:../../Source/queue.c **** 
 164               		.loc 1 2143 0
 165 0096 1F5F      		subi r17,lo8(-(1))
 166               	.LVL13:
 167 0098 1A8F      		std Y+26,r17
2146:../../Source/queue.c **** /*-----------------------------------------------------------*/
 168               		.loc 1 2146 0
 169 009a 80E0      		ldi r24,0
 170               	/* epilogue start */
 171 009c DF91      		pop r29
 172 009e CF91      		pop r28
 173               	.LVL14:
 174 00a0 1F91      		pop r17
 175               	.LVL15:
 176 00a2 0F91      		pop r16
 177               	.LVL16:
 178 00a4 0895      		ret
 179               		.cfi_endproc
 180               	.LFE19:
 183               	prvCopyDataFromQueue:
 184               	.LFB20:
2150:../../Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 185               		.loc 1 2150 0
 186               		.cfi_startproc
 187               	.LVL17:
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 192 00a6 FC01      		movw r30,r24
 193 00a8 CB01      		movw r24,r22
 194               	.LVL18:
2151:../../Source/queue.c **** 	{
 195               		.loc 1 2151 0
 196 00aa 448D      		ldd r20,Z+28
 197 00ac 4423      		tst r20
 198 00ae 01F0      		breq .L17
2153:../../Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 199               		.loc 1 2153 0
 200 00b0 50E0      		ldi r21,0
 201 00b2 2681      		ldd r18,Z+6
 202 00b4 3781      		ldd r19,Z+7
 203 00b6 240F      		add r18,r20
 204 00b8 351F      		adc r19,r21
 205 00ba 3783      		std Z+7,r19
 206 00bc 2683      		std Z+6,r18
2154:../../Source/queue.c **** 		{
 207               		.loc 1 2154 0
 208 00be 6481      		ldd r22,Z+4
 209 00c0 7581      		ldd r23,Z+5
 210               	.LVL19:
 211 00c2 2617      		cp r18,r22
 212 00c4 3707      		cpc r19,r23
 213 00c6 00F0      		brlo .L19
2156:../../Source/queue.c **** 		}
 214               		.loc 1 2156 0
 215 00c8 2081      		ld r18,Z
 216 00ca 3181      		ldd r19,Z+1
 217 00cc 3783      		std Z+7,r19
 218 00ce 2683      		std Z+6,r18
 219               	.L19:
2162:../../Source/queue.c **** 	}
 220               		.loc 1 2162 0
 221 00d0 6681      		ldd r22,Z+6
 222 00d2 7781      		ldd r23,Z+7
 223 00d4 0C94 0000 		jmp memcpy
 224               	.LVL20:
 225               	.L17:
 226 00d8 0895      		ret
 227               		.cfi_endproc
 228               	.LFE20:
 231               	prvUnlockQueue:
 232               	.LFB21:
2168:../../Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 233               		.loc 1 2168 0
 234               		.cfi_startproc
 235               	.LVL21:
 236 00da EF92      		push r14
 237               	.LCFI4:
 238               		.cfi_def_cfa_offset 4
 239               		.cfi_offset 14, -3
 240 00dc FF92      		push r15
 241               	.LCFI5:
 242               		.cfi_def_cfa_offset 5
 243               		.cfi_offset 15, -4
 244 00de 1F93      		push r17
 245               	.LCFI6:
 246               		.cfi_def_cfa_offset 6
 247               		.cfi_offset 17, -5
 248 00e0 CF93      		push r28
 249               	.LCFI7:
 250               		.cfi_def_cfa_offset 7
 251               		.cfi_offset 28, -6
 252 00e2 DF93      		push r29
 253               	.LCFI8:
 254               		.cfi_def_cfa_offset 8
 255               		.cfi_offset 29, -7
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 5 */
 259               	.L__stack_usage = 5
 260 00e4 EC01      		movw r28,r24
2175:../../Source/queue.c **** 	{
 261               		.loc 1 2175 0
 262               	/* #APP */
 263               	 ;  2175 "../../Source/queue.c" 1
 264 00e6 0FB6      		in __tmp_reg__, __SREG__
 265 00e8 F894      		cli
 266 00ea 0F92      		push __tmp_reg__
 267               		
 268               	 ;  0 "" 2
 269               	/* #NOAPP */
 270               	.LBB2:
2177:../../Source/queue.c **** 
 271               		.loc 1 2177 0
 272 00ec 1E8D      		ldd r17,Y+30
 273               	.LVL22:
2230:../../Source/queue.c **** 					{
 274               		.loc 1 2230 0
 275 00ee 7C01      		movw r14,r24
 276 00f0 81E1      		ldi r24,17
 277 00f2 E80E      		add r14,r24
 278 00f4 F11C      		adc r15,__zero_reg__
 279               	.LVL23:
 280               	.L21:
2180:../../Source/queue.c **** 		{
 281               		.loc 1 2180 0
 282 00f6 1116      		cp __zero_reg__,r17
 283 00f8 04F4      		brge .L22
2228:../../Source/queue.c **** 				{
 284               		.loc 1 2228 0
 285 00fa 8989      		ldd r24,Y+17
 286 00fc 8823      		tst r24
 287 00fe 01F0      		breq .L22
2230:../../Source/queue.c **** 					{
 288               		.loc 1 2230 0
 289 0100 C701      		movw r24,r14
 290 0102 0E94 0000 		call xTaskRemoveFromEventList
 291               	.LVL24:
 292 0106 8111      		cpse r24,__zero_reg__
2234:../../Source/queue.c **** 					}
 293               		.loc 1 2234 0
 294 0108 0E94 0000 		call vTaskMissedYield
 295               	.LVL25:
 296               	.L23:
 297 010c 1150      		subi r17,lo8(-(-1))
 298               	.LVL26:
 299 010e 00C0      		rjmp .L21
 300               	.L22:
2251:../../Source/queue.c **** 	}
 301               		.loc 1 2251 0
 302 0110 8FEF      		ldi r24,lo8(-1)
 303 0112 8E8F      		std Y+30,r24
 304               	.LBE2:
2253:../../Source/queue.c **** 
 305               		.loc 1 2253 0
 306               	/* #APP */
 307               	 ;  2253 "../../Source/queue.c" 1
 308 0114 0F90      		pop __tmp_reg__
 309 0116 0FBE      		out __SREG__, __tmp_reg__
 310               		
 311               	 ;  0 "" 2
2256:../../Source/queue.c **** 	{
 312               		.loc 1 2256 0
 313               	 ;  2256 "../../Source/queue.c" 1
 314 0118 0FB6      		in __tmp_reg__, __SREG__
 315 011a F894      		cli
 316 011c 0F92      		push __tmp_reg__
 317               		
 318               	 ;  0 "" 2
 319               	/* #NOAPP */
 320               	.LBB3:
2258:../../Source/queue.c **** 
 321               		.loc 1 2258 0
 322 011e 1D8D      		ldd r17,Y+29
 323               	.LVL27:
2264:../../Source/queue.c **** 				{
 324               		.loc 1 2264 0
 325 0120 7E01      		movw r14,r28
 326 0122 88E0      		ldi r24,8
 327 0124 E80E      		add r14,r24
 328 0126 F11C      		adc r15,__zero_reg__
 329               	.L25:
2260:../../Source/queue.c **** 		{
 330               		.loc 1 2260 0
 331 0128 1116      		cp __zero_reg__,r17
 332 012a 04F4      		brge .L26
2262:../../Source/queue.c **** 			{
 333               		.loc 1 2262 0
 334 012c 8885      		ldd r24,Y+8
 335 012e 8823      		tst r24
 336 0130 01F0      		breq .L26
2264:../../Source/queue.c **** 				{
 337               		.loc 1 2264 0
 338 0132 C701      		movw r24,r14
 339 0134 0E94 0000 		call xTaskRemoveFromEventList
 340               	.LVL28:
 341 0138 8111      		cpse r24,__zero_reg__
2266:../../Source/queue.c **** 				}
 342               		.loc 1 2266 0
 343 013a 0E94 0000 		call vTaskMissedYield
 344               	.LVL29:
 345               	.L27:
 346 013e 1150      		subi r17,lo8(-(-1))
 347               	.LVL30:
 348 0140 00C0      		rjmp .L25
 349               	.L26:
2281:../../Source/queue.c **** 	}
 350               		.loc 1 2281 0
 351 0142 8FEF      		ldi r24,lo8(-1)
 352 0144 8D8F      		std Y+29,r24
 353               	.LBE3:
2283:../../Source/queue.c **** }
 354               		.loc 1 2283 0
 355               	/* #APP */
 356               	 ;  2283 "../../Source/queue.c" 1
 357 0146 0F90      		pop __tmp_reg__
 358 0148 0FBE      		out __SREG__, __tmp_reg__
 359               		
 360               	 ;  0 "" 2
 361               	/* epilogue start */
2284:../../Source/queue.c **** /*-----------------------------------------------------------*/
 362               		.loc 1 2284 0
 363               	/* #NOAPP */
 364 014a DF91      		pop r29
 365 014c CF91      		pop r28
 366               	.LVL31:
 367 014e 1F91      		pop r17
 368               	.LVL32:
 369 0150 FF90      		pop r15
 370 0152 EF90      		pop r14
 371               	.LVL33:
 372 0154 0895      		ret
 373               		.cfi_endproc
 374               	.LFE21:
 376               	.global	xQueueGenericReset
 378               	xQueueGenericReset:
 379               	.LFB4:
 256:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 380               		.loc 1 256 0
 381               		.cfi_startproc
 382               	.LVL34:
 383 0156 CF93      		push r28
 384               	.LCFI9:
 385               		.cfi_def_cfa_offset 4
 386               		.cfi_offset 28, -3
 387 0158 DF93      		push r29
 388               	.LCFI10:
 389               		.cfi_def_cfa_offset 5
 390               		.cfi_offset 29, -4
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 2 */
 394               	.L__stack_usage = 2
 395 015a EC01      		movw r28,r24
 396               	.LVL35:
 261:../../Source/queue.c **** 	{
 397               		.loc 1 261 0
 398               	/* #APP */
 399               	 ;  261 "../../Source/queue.c" 1
 400 015c 0FB6      		in __tmp_reg__, __SREG__
 401 015e F894      		cli
 402 0160 0F92      		push __tmp_reg__
 403               		
 404               	 ;  0 "" 2
 263:../../Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 405               		.loc 1 263 0
 406               	/* #NOAPP */
 407 0162 4881      		ld r20,Y
 408 0164 5981      		ldd r21,Y+1
 409 0166 8B8D      		ldd r24,Y+27
 410               	.LVL36:
 411 0168 7C8D      		ldd r23,Y+28
 412 016a 9A01      		movw r18,r20
 413 016c 879F      		mul r24,r23
 414 016e 200D      		add r18,r0
 415 0170 311D      		adc r19,r1
 416 0172 1124      		clr __zero_reg__
 417 0174 3D83      		std Y+5,r19
 418 0176 2C83      		std Y+4,r18
 264:../../Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 419               		.loc 1 264 0
 420 0178 1A8E      		std Y+26,__zero_reg__
 265:../../Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 421               		.loc 1 265 0
 422 017a 5B83      		std Y+3,r21
 423 017c 4A83      		std Y+2,r20
 266:../../Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 424               		.loc 1 266 0
 425 017e 90E0      		ldi r25,0
 426 0180 0197      		sbiw r24,1
 427 0182 789F      		mul r23,r24
 428 0184 9001      		movw r18,r0
 429 0186 799F      		mul r23,r25
 430 0188 300D      		add r19,r0
 431 018a 1124      		clr __zero_reg__
 432 018c CA01      		movw r24,r20
 433 018e 820F      		add r24,r18
 434 0190 931F      		adc r25,r19
 435 0192 9F83      		std Y+7,r25
 436 0194 8E83      		std Y+6,r24
 267:../../Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 437               		.loc 1 267 0
 438 0196 8FEF      		ldi r24,lo8(-1)
 439 0198 8D8F      		std Y+29,r24
 268:../../Source/queue.c **** 
 440               		.loc 1 268 0
 441 019a 8E8F      		std Y+30,r24
 270:../../Source/queue.c **** 		{
 442               		.loc 1 270 0
 443 019c 6111      		cpse r22,__zero_reg__
 444 019e 00C0      		rjmp .L42
 277:../../Source/queue.c **** 			{
 445               		.loc 1 277 0
 446 01a0 8885      		ldd r24,Y+8
 447 01a2 8823      		tst r24
 448 01a4 01F0      		breq .L44
 279:../../Source/queue.c **** 				{
 449               		.loc 1 279 0
 450 01a6 CE01      		movw r24,r28
 451 01a8 0896      		adiw r24,8
 452 01aa 0E94 0000 		call xTaskRemoveFromEventList
 453               	.LVL37:
 454 01ae 8823      		tst r24
 455 01b0 01F0      		breq .L44
 281:../../Source/queue.c **** 				}
 456               		.loc 1 281 0
 457 01b2 0E94 0000 		call vPortYield
 458               	.LVL38:
 459 01b6 00C0      		rjmp .L44
 460               	.LVL39:
 461               	.L42:
 296:../../Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 462               		.loc 1 296 0
 463 01b8 CE01      		movw r24,r28
 464 01ba 0896      		adiw r24,8
 465 01bc 0E94 0000 		call vListInitialise
 466               	.LVL40:
 297:../../Source/queue.c **** 		}
 467               		.loc 1 297 0
 468 01c0 CE01      		movw r24,r28
 469 01c2 4196      		adiw r24,17
 470 01c4 0E94 0000 		call vListInitialise
 471               	.LVL41:
 472               	.L44:
 300:../../Source/queue.c **** 
 473               		.loc 1 300 0
 474               	/* #APP */
 475               	 ;  300 "../../Source/queue.c" 1
 476 01c8 0F90      		pop __tmp_reg__
 477 01ca 0FBE      		out __SREG__, __tmp_reg__
 478               		
 479               	 ;  0 "" 2
 305:../../Source/queue.c **** /*-----------------------------------------------------------*/
 480               		.loc 1 305 0
 481               	/* #NOAPP */
 482 01cc 81E0      		ldi r24,lo8(1)
 483               	/* epilogue start */
 484 01ce DF91      		pop r29
 485 01d0 CF91      		pop r28
 486               	.LVL42:
 487 01d2 0895      		ret
 488               		.cfi_endproc
 489               	.LFE4:
 491               	.global	xQueueGenericCreate
 493               	xQueueGenericCreate:
 494               	.LFB5:
 369:../../Source/queue.c **** 	Queue_t *pxNewQueue;
 495               		.loc 1 369 0
 496               		.cfi_startproc
 497               	.LVL43:
 498 01d4 0F93      		push r16
 499               	.LCFI11:
 500               		.cfi_def_cfa_offset 4
 501               		.cfi_offset 16, -3
 502 01d6 1F93      		push r17
 503               	.LCFI12:
 504               		.cfi_def_cfa_offset 5
 505               		.cfi_offset 17, -4
 506 01d8 CF93      		push r28
 507               	.LCFI13:
 508               		.cfi_def_cfa_offset 6
 509               		.cfi_offset 28, -5
 510 01da DF93      		push r29
 511               	.LCFI14:
 512               		.cfi_def_cfa_offset 7
 513               		.cfi_offset 29, -6
 514               	/* prologue: function */
 515               	/* frame size = 0 */
 516               	/* stack size = 4 */
 517               	.L__stack_usage = 4
 518 01dc 082F      		mov r16,r24
 519 01de 162F      		mov r17,r22
 376:../../Source/queue.c **** 		{
 520               		.loc 1 376 0
 521 01e0 6623      		tst r22
 522 01e2 01F0      		breq .L54
 385:../../Source/queue.c **** 		}
 523               		.loc 1 385 0
 524 01e4 869F      		mul r24,r22
 525 01e6 C001      		movw r24,r0
 526 01e8 1124      		clr __zero_reg__
 527               	.LVL44:
 528 01ea 00C0      		rjmp .L50
 529               	.LVL45:
 530               	.L54:
 379:../../Source/queue.c **** 		}
 531               		.loc 1 379 0
 532 01ec 80E0      		ldi r24,0
 533 01ee 90E0      		ldi r25,0
 534               	.L50:
 535               	.LVL46:
 397:../../Source/queue.c **** 
 536               		.loc 1 397 0
 537 01f0 4F96      		adiw r24,31
 538               	.LVL47:
 539 01f2 0E94 0000 		call pvPortMalloc
 540               	.LVL48:
 541 01f6 EC01      		movw r28,r24
 542               	.LVL49:
 399:../../Source/queue.c **** 		{
 543               		.loc 1 399 0
 544 01f8 0097      		sbiw r24,0
 545 01fa 01F0      		breq .L51
 546               	.LVL50:
 547               	.LBB6:
 548               	.LBB7:
 435:../../Source/queue.c **** 	{
 549               		.loc 1 435 0
 550 01fc 1111      		cpse r17,__zero_reg__
 551 01fe 00C0      		rjmp .L52
 552               	.LVL51:
 441:../../Source/queue.c **** 	}
 553               		.loc 1 441 0
 554 0200 9983      		std Y+1,r25
 555 0202 8883      		st Y,r24
 556 0204 00C0      		rjmp .L53
 557               	.LVL52:
 558               	.L52:
 446:../../Source/queue.c **** 	}
 559               		.loc 1 446 0
 560 0206 4F96      		adiw r24,31
 561               	.LVL53:
 562 0208 9983      		std Y+1,r25
 563 020a 8883      		st Y,r24
 564               	.LVL54:
 565               	.L53:
 451:../../Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 566               		.loc 1 451 0
 567 020c 0B8F      		std Y+27,r16
 452:../../Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 568               		.loc 1 452 0
 569 020e 1C8F      		std Y+28,r17
 453:../../Source/queue.c **** 
 570               		.loc 1 453 0
 571 0210 61E0      		ldi r22,lo8(1)
 572 0212 CE01      		movw r24,r28
 573 0214 0E94 0000 		call xQueueGenericReset
 574               	.LVL55:
 575               	.L51:
 576               	.LBE7:
 577               	.LBE6:
 424:../../Source/queue.c **** 
 578               		.loc 1 424 0
 579 0218 CE01      		movw r24,r28
 580               	/* epilogue start */
 581 021a DF91      		pop r29
 582 021c CF91      		pop r28
 583               	.LVL56:
 584 021e 1F91      		pop r17
 585               	.LVL57:
 586 0220 0F91      		pop r16
 587               	.LVL58:
 588 0222 0895      		ret
 589               		.cfi_endproc
 590               	.LFE5:
 592               	.global	xQueueGenericSend
 594               	xQueueGenericSend:
 595               	.LFB7:
 748:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 596               		.loc 1 748 0
 597               		.cfi_startproc
 598               	.LVL59:
 599 0224 AF92      		push r10
 600               	.LCFI15:
 601               		.cfi_def_cfa_offset 4
 602               		.cfi_offset 10, -3
 603 0226 BF92      		push r11
 604               	.LCFI16:
 605               		.cfi_def_cfa_offset 5
 606               		.cfi_offset 11, -4
 607 0228 CF92      		push r12
 608               	.LCFI17:
 609               		.cfi_def_cfa_offset 6
 610               		.cfi_offset 12, -5
 611 022a DF92      		push r13
 612               	.LCFI18:
 613               		.cfi_def_cfa_offset 7
 614               		.cfi_offset 13, -6
 615 022c FF92      		push r15
 616               	.LCFI19:
 617               		.cfi_def_cfa_offset 8
 618               		.cfi_offset 15, -7
 619 022e 0F93      		push r16
 620               	.LCFI20:
 621               		.cfi_def_cfa_offset 9
 622               		.cfi_offset 16, -8
 623 0230 1F93      		push r17
 624               	.LCFI21:
 625               		.cfi_def_cfa_offset 10
 626               		.cfi_offset 17, -9
 627 0232 CF93      		push r28
 628               	.LCFI22:
 629               		.cfi_def_cfa_offset 11
 630               		.cfi_offset 28, -10
 631 0234 DF93      		push r29
 632               	.LCFI23:
 633               		.cfi_def_cfa_offset 12
 634               		.cfi_offset 29, -11
 635 0236 00D0      		rcall .
 636 0238 1F92      		push __zero_reg__
 637 023a 1F92      		push __zero_reg__
 638               	.LCFI24:
 639               		.cfi_def_cfa_offset 17
 640 023c CDB7      		in r28,__SP_L__
 641 023e DEB7      		in r29,__SP_H__
 642               	.LCFI25:
 643               		.cfi_def_cfa_register 28
 644               	/* prologue: function */
 645               	/* frame size = 5 */
 646               	/* stack size = 14 */
 647               	.L__stack_usage = 14
 648 0240 8C01      		movw r16,r24
 649 0242 6B01      		movw r12,r22
 650 0244 5D83      		std Y+5,r21
 651 0246 4C83      		std Y+4,r20
 652 0248 F22E      		mov r15,r18
 653               	.LVL60:
 749:../../Source/queue.c **** TimeOut_t xTimeOut;
 654               		.loc 1 749 0
 655 024a 80E0      		ldi r24,0
 656               	.LVL61:
 918:../../Source/queue.c **** 
 657               		.loc 1 918 0
 658 024c 5801      		movw r10,r16
 659 024e 98E0      		ldi r25,8
 660 0250 A90E      		add r10,r25
 661 0252 B11C      		adc r11,__zero_reg__
 662               	.LVL62:
 663               	.L59:
 768:../../Source/queue.c **** 		{
 664               		.loc 1 768 0
 665               	/* #APP */
 666               	 ;  768 "../../Source/queue.c" 1
 667 0254 0FB6      		in __tmp_reg__, __SREG__
 668 0256 F894      		cli
 669 0258 0F92      		push __tmp_reg__
 670               		
 671               	 ;  0 "" 2
 774:../../Source/queue.c **** 			{
 672               		.loc 1 774 0
 673               	/* #NOAPP */
 674 025a F801      		movw r30,r16
 675 025c 228D      		ldd r18,Z+26
 676 025e 938D      		ldd r25,Z+27
 677 0260 2917      		cp r18,r25
 678 0262 00F0      		brlo .L60
 774:../../Source/queue.c **** 			{
 679               		.loc 1 774 0 is_stmt 0 discriminator 1
 680 0264 F2E0      		ldi r31,lo8(2)
 681 0266 FF12      		cpse r15,r31
 682 0268 00C0      		rjmp .L61
 683               	.L60:
 840:../../Source/queue.c **** 
 684               		.loc 1 840 0 is_stmt 1
 685 026a 4F2D      		mov r20,r15
 686 026c B601      		movw r22,r12
 687 026e C801      		movw r24,r16
 688               	.LVL63:
 689 0270 0E94 0000 		call prvCopyDataToQueue
 690               	.LVL64:
 844:../../Source/queue.c **** 					{
 691               		.loc 1 844 0
 692 0274 F801      		movw r30,r16
 693 0276 9189      		ldd r25,Z+17
 694 0278 9923      		tst r25
 695 027a 01F0      		breq .L74
 846:../../Source/queue.c **** 						{
 696               		.loc 1 846 0
 697 027c C801      		movw r24,r16
 698               	.LVL65:
 699 027e 4196      		adiw r24,17
 700 0280 0E94 0000 		call xTaskRemoveFromEventList
 701               	.LVL66:
 702               	.L74:
 703 0284 8111      		cpse r24,__zero_reg__
 852:../../Source/queue.c **** 						}
 704               		.loc 1 852 0
 705 0286 0E94 0000 		call vPortYield
 706               	.LVL67:
 707               	.L64:
 874:../../Source/queue.c **** 				return pdPASS;
 708               		.loc 1 874 0
 709               	/* #APP */
 710               	 ;  874 "../../Source/queue.c" 1
 711 028a 0F90      		pop __tmp_reg__
 712 028c 0FBE      		out __SREG__, __tmp_reg__
 713               		
 714               	 ;  0 "" 2
 875:../../Source/queue.c **** 			}
 715               		.loc 1 875 0
 716               	/* #NOAPP */
 717 028e 81E0      		ldi r24,lo8(1)
 718 0290 00C0      		rjmp .L66
 719               	.LVL68:
 720               	.L61:
 879:../../Source/queue.c **** 				{
 721               		.loc 1 879 0
 722 0292 2C81      		ldd r18,Y+4
 723 0294 3D81      		ldd r19,Y+5
 724 0296 232B      		or r18,r19
 725 0298 01F4      		brne .L67
 883:../../Source/queue.c **** 
 726               		.loc 1 883 0
 727               	/* #APP */
 728               	 ;  883 "../../Source/queue.c" 1
 729 029a 0F90      		pop __tmp_reg__
 730 029c 0FBE      		out __SREG__, __tmp_reg__
 731               		
 732               	 ;  0 "" 2
 733               	/* #NOAPP */
 734 029e 00C0      		rjmp .L75
 735               	.L67:
 890:../../Source/queue.c **** 				{
 736               		.loc 1 890 0
 737 02a0 8111      		cpse r24,__zero_reg__
 738 02a2 00C0      		rjmp .L68
 894:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 739               		.loc 1 894 0
 740 02a4 CE01      		movw r24,r28
 741               	.LVL69:
 742 02a6 0196      		adiw r24,1
 743 02a8 0E94 0000 		call vTaskInternalSetTimeOutState
 744               	.LVL70:
 745               	.L68:
 904:../../Source/queue.c **** 
 746               		.loc 1 904 0
 747               	/* #APP */
 748               	 ;  904 "../../Source/queue.c" 1
 749 02ac 0F90      		pop __tmp_reg__
 750 02ae 0FBE      		out __SREG__, __tmp_reg__
 751               		
 752               	 ;  0 "" 2
 909:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 753               		.loc 1 909 0
 754               	/* #NOAPP */
 755 02b0 0E94 0000 		call vTaskSuspendAll
 756               	.LVL71:
 910:../../Source/queue.c **** 
 757               		.loc 1 910 0
 758               	/* #APP */
 759               	 ;  910 "../../Source/queue.c" 1
 760 02b4 0FB6      		in __tmp_reg__, __SREG__
 761 02b6 F894      		cli
 762 02b8 0F92      		push __tmp_reg__
 763               		
 764               	 ;  0 "" 2
 765               	/* #NOAPP */
 766 02ba F801      		movw r30,r16
 767 02bc 858D      		ldd r24,Z+29
 768 02be 8F3F      		cpi r24,lo8(-1)
 769 02c0 01F4      		brne .L69
 910:../../Source/queue.c **** 
 770               		.loc 1 910 0 is_stmt 0 discriminator 1
 771 02c2 158E      		std Z+29,__zero_reg__
 772               	.L69:
 910:../../Source/queue.c **** 
 773               		.loc 1 910 0 discriminator 3
 774 02c4 F801      		movw r30,r16
 775 02c6 868D      		ldd r24,Z+30
 776 02c8 8F3F      		cpi r24,lo8(-1)
 777 02ca 01F4      		brne .L70
 910:../../Source/queue.c **** 
 778               		.loc 1 910 0 discriminator 4
 779 02cc 168E      		std Z+30,__zero_reg__
 780               	.L70:
 910:../../Source/queue.c **** 
 781               		.loc 1 910 0 discriminator 6
 782               	/* #APP */
 783               	 ;  910 "../../Source/queue.c" 1
 784 02ce 0F90      		pop __tmp_reg__
 785 02d0 0FBE      		out __SREG__, __tmp_reg__
 786               		
 787               	 ;  0 "" 2
 913:../../Source/queue.c **** 		{
 788               		.loc 1 913 0 is_stmt 1 discriminator 6
 789               	/* #NOAPP */
 790 02d2 BE01      		movw r22,r28
 791 02d4 6C5F      		subi r22,-4
 792 02d6 7F4F      		sbci r23,-1
 793 02d8 CE01      		movw r24,r28
 794 02da 0196      		adiw r24,1
 795 02dc 0E94 0000 		call xTaskCheckForTimeOut
 796               	.LVL72:
 797 02e0 8111      		cpse r24,__zero_reg__
 798 02e2 00C0      		rjmp .L71
 799               	.LVL73:
 800               	.LBB10:
 801               	.LBB11:
2306:../../Source/queue.c **** /*-----------------------------------------------------------*/
2307:../../Source/queue.c **** 
2308:../../Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2309:../../Source/queue.c **** {
2310:../../Source/queue.c **** BaseType_t xReturn;
2311:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
2312:../../Source/queue.c **** 
2313:../../Source/queue.c **** 	configASSERT( pxQueue );
2314:../../Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2315:../../Source/queue.c **** 	{
2316:../../Source/queue.c **** 		xReturn = pdTRUE;
2317:../../Source/queue.c **** 	}
2318:../../Source/queue.c **** 	else
2319:../../Source/queue.c **** 	{
2320:../../Source/queue.c **** 		xReturn = pdFALSE;
2321:../../Source/queue.c **** 	}
2322:../../Source/queue.c **** 
2323:../../Source/queue.c **** 	return xReturn;
2324:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2325:../../Source/queue.c **** /*-----------------------------------------------------------*/
2326:../../Source/queue.c **** 
2327:../../Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2328:../../Source/queue.c **** {
2329:../../Source/queue.c **** BaseType_t xReturn;
2330:../../Source/queue.c **** 
2331:../../Source/queue.c **** 	taskENTER_CRITICAL();
 802               		.loc 1 2331 0
 803               	/* #APP */
 804               	 ;  2331 "../../Source/queue.c" 1
 805 02e4 0FB6      		in __tmp_reg__, __SREG__
 806 02e6 F894      		cli
 807 02e8 0F92      		push __tmp_reg__
 808               		
 809               	 ;  0 "" 2
2332:../../Source/queue.c **** 	{
2333:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 810               		.loc 1 2333 0
 811               	/* #NOAPP */
 812 02ea F801      		movw r30,r16
 813 02ec 928D      		ldd r25,Z+26
 814 02ee 838D      		ldd r24,Z+27
 815               	.LVL74:
2334:../../Source/queue.c **** 		{
2335:../../Source/queue.c **** 			xReturn = pdTRUE;
2336:../../Source/queue.c **** 		}
2337:../../Source/queue.c **** 		else
2338:../../Source/queue.c **** 		{
2339:../../Source/queue.c **** 			xReturn = pdFALSE;
2340:../../Source/queue.c **** 		}
2341:../../Source/queue.c **** 	}
2342:../../Source/queue.c **** 	taskEXIT_CRITICAL();
 816               		.loc 1 2342 0
 817               	/* #APP */
 818               	 ;  2342 "../../Source/queue.c" 1
 819 02f0 0F90      		pop __tmp_reg__
 820 02f2 0FBE      		out __SREG__, __tmp_reg__
 821               		
 822               	 ;  0 "" 2
 823               	.LVL75:
 824               	/* #NOAPP */
 825               	.LBE11:
 826               	.LBE10:
 915:../../Source/queue.c **** 			{
 827               		.loc 1 915 0
 828 02f4 9813      		cpse r25,r24
 829 02f6 00C0      		rjmp .L72
 918:../../Source/queue.c **** 
 830               		.loc 1 918 0
 831 02f8 6C81      		ldd r22,Y+4
 832 02fa 7D81      		ldd r23,Y+5
 833 02fc C501      		movw r24,r10
 834 02fe 0E94 0000 		call vTaskPlaceOnEventList
 835               	.LVL76:
 925:../../Source/queue.c **** 
 836               		.loc 1 925 0
 837 0302 C801      		movw r24,r16
 838 0304 0E94 0000 		call prvUnlockQueue
 839               	.LVL77:
 932:../../Source/queue.c **** 				{
 840               		.loc 1 932 0
 841 0308 0E94 0000 		call xTaskResumeAll
 842               	.LVL78:
 843 030c 8823      		tst r24
 844 030e 01F0      		breq .L76
 845               	.L73:
 846 0310 81E0      		ldi r24,lo8(1)
 847 0312 00C0      		rjmp .L59
 848               	.L76:
 934:../../Source/queue.c **** 				}
 849               		.loc 1 934 0
 850 0314 0E94 0000 		call vPortYield
 851               	.LVL79:
 852 0318 00C0      		rjmp .L73
 853               	.L72:
 940:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 854               		.loc 1 940 0
 855 031a C801      		movw r24,r16
 856 031c 0E94 0000 		call prvUnlockQueue
 857               	.LVL80:
 941:../../Source/queue.c **** 			}
 858               		.loc 1 941 0
 859 0320 0E94 0000 		call xTaskResumeAll
 860               	.LVL81:
 861 0324 00C0      		rjmp .L73
 862               	.L71:
 947:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 863               		.loc 1 947 0
 864 0326 C801      		movw r24,r16
 865 0328 0E94 0000 		call prvUnlockQueue
 866               	.LVL82:
 948:../../Source/queue.c **** 
 867               		.loc 1 948 0
 868 032c 0E94 0000 		call xTaskResumeAll
 869               	.LVL83:
 870               	.L75:
 951:../../Source/queue.c **** 		}
 871               		.loc 1 951 0
 872 0330 80E0      		ldi r24,0
 873               	.L66:
 874               	/* epilogue start */
 954:../../Source/queue.c **** /*-----------------------------------------------------------*/
 875               		.loc 1 954 0
 876 0332 0F90      		pop __tmp_reg__
 877 0334 0F90      		pop __tmp_reg__
 878 0336 0F90      		pop __tmp_reg__
 879 0338 0F90      		pop __tmp_reg__
 880 033a 0F90      		pop __tmp_reg__
 881 033c DF91      		pop r29
 882 033e CF91      		pop r28
 883               	.LVL84:
 884 0340 1F91      		pop r17
 885               	.LVL85:
 886 0342 0F91      		pop r16
 887               	.LVL86:
 888 0344 FF90      		pop r15
 889               	.LVL87:
 890 0346 DF90      		pop r13
 891               	.LVL88:
 892 0348 CF90      		pop r12
 893               	.LVL89:
 894 034a BF90      		pop r11
 895               	.LVL90:
 896 034c AF90      		pop r10
 897               	.LVL91:
 898 034e 0895      		ret
 899               		.cfi_endproc
 900               	.LFE7:
 902               	.global	xQueueGenericSendFromISR
 904               	xQueueGenericSendFromISR:
 905               	.LFB8:
 958:../../Source/queue.c **** BaseType_t xReturn;
 906               		.loc 1 958 0
 907               		.cfi_startproc
 908               	.LVL92:
 909 0350 EF92      		push r14
 910               	.LCFI26:
 911               		.cfi_def_cfa_offset 4
 912               		.cfi_offset 14, -3
 913 0352 FF92      		push r15
 914               	.LCFI27:
 915               		.cfi_def_cfa_offset 5
 916               		.cfi_offset 15, -4
 917 0354 1F93      		push r17
 918               	.LCFI28:
 919               		.cfi_def_cfa_offset 6
 920               		.cfi_offset 17, -5
 921 0356 CF93      		push r28
 922               	.LCFI29:
 923               		.cfi_def_cfa_offset 7
 924               		.cfi_offset 28, -6
 925 0358 DF93      		push r29
 926               	.LCFI30:
 927               		.cfi_def_cfa_offset 8
 928               		.cfi_offset 29, -7
 929               	/* prologue: function */
 930               	/* frame size = 0 */
 931               	/* stack size = 5 */
 932               	.L__stack_usage = 5
 933 035a EC01      		movw r28,r24
 934               	.LVL93:
 990:../../Source/queue.c **** 		{
 935               		.loc 1 990 0
 936 035c 9A8D      		ldd r25,Y+26
 937 035e 8B8D      		ldd r24,Y+27
 938               	.LVL94:
 939 0360 9817      		cp r25,r24
 940 0362 00F0      		brlo .L78
 990:../../Source/queue.c **** 		{
 941               		.loc 1 990 0 is_stmt 0 discriminator 1
 942 0364 2230      		cpi r18,lo8(2)
 943 0366 01F4      		brne .L83
 944               	.L78:
 945 0368 7A01      		movw r14,r20
 946               	.LBB12:
 992:../../Source/queue.c **** 
 947               		.loc 1 992 0 is_stmt 1
 948 036a 1E8D      		ldd r17,Y+30
 949               	.LVL95:
1001:../../Source/queue.c **** 
 950               		.loc 1 1001 0
 951 036c 422F      		mov r20,r18
 952               	.LVL96:
 953 036e CE01      		movw r24,r28
 954 0370 0E94 0000 		call prvCopyDataToQueue
 955               	.LVL97:
1005:../../Source/queue.c **** 			{
 956               		.loc 1 1005 0
 957 0374 1F3F      		cpi r17,lo8(-1)
 958 0376 01F4      		brne .L80
1060:../../Source/queue.c **** 					{
 959               		.loc 1 1060 0
 960 0378 8989      		ldd r24,Y+17
 961 037a 8823      		tst r24
 962 037c 01F0      		breq .L90
1062:../../Source/queue.c **** 						{
 963               		.loc 1 1062 0
 964 037e CE01      		movw r24,r28
 965 0380 4196      		adiw r24,17
 966 0382 0E94 0000 		call xTaskRemoveFromEventList
 967               	.LVL98:
 968 0386 8823      		tst r24
 969 0388 01F0      		breq .L90
1066:../../Source/queue.c **** 							{
 970               		.loc 1 1066 0
 971 038a E114      		cp r14,__zero_reg__
 972 038c F104      		cpc r15,__zero_reg__
 973 038e 01F0      		breq .L90
1068:../../Source/queue.c **** 							}
 974               		.loc 1 1068 0
 975 0390 81E0      		ldi r24,lo8(1)
 976 0392 F701      		movw r30,r14
 977 0394 8083      		st Z,r24
 978 0396 00C0      		rjmp .L79
 979               	.L80:
1091:../../Source/queue.c **** 			}
 980               		.loc 1 1091 0
 981 0398 1F5F      		subi r17,lo8(-(1))
 982               	.LVL99:
 983 039a 1E8F      		std Y+30,r17
 984               	.LVL100:
 985               	.L90:
1094:../../Source/queue.c **** 		}
 986               		.loc 1 1094 0
 987 039c 81E0      		ldi r24,lo8(1)
 988 039e 00C0      		rjmp .L79
 989               	.LVL101:
 990               	.L83:
 991               	.LBE12:
1099:../../Source/queue.c **** 		}
 992               		.loc 1 1099 0
 993 03a0 80E0      		ldi r24,0
 994               	.LVL102:
 995               	.L79:
 996               	/* epilogue start */
1105:../../Source/queue.c **** /*-----------------------------------------------------------*/
 997               		.loc 1 1105 0
 998 03a2 DF91      		pop r29
 999 03a4 CF91      		pop r28
 1000               	.LVL103:
 1001 03a6 1F91      		pop r17
 1002 03a8 FF90      		pop r15
 1003 03aa EF90      		pop r14
 1004 03ac 0895      		ret
 1005               		.cfi_endproc
 1006               	.LFE8:
 1008               	.global	xQueueGiveFromISR
 1010               	xQueueGiveFromISR:
 1011               	.LFB9:
1109:../../Source/queue.c **** BaseType_t xReturn;
 1012               		.loc 1 1109 0
 1013               		.cfi_startproc
 1014               	.LVL104:
 1015 03ae CF93      		push r28
 1016               	.LCFI31:
 1017               		.cfi_def_cfa_offset 4
 1018               		.cfi_offset 28, -3
 1019 03b0 DF93      		push r29
 1020               	.LCFI32:
 1021               		.cfi_def_cfa_offset 5
 1022               		.cfi_offset 29, -4
 1023               	/* prologue: function */
 1024               	/* frame size = 0 */
 1025               	/* stack size = 2 */
 1026               	.L__stack_usage = 2
 1027 03b2 FC01      		movw r30,r24
 1028               	.LVL105:
 1029               	.LBB13:
1149:../../Source/queue.c **** 
 1030               		.loc 1 1149 0
 1031 03b4 928D      		ldd r25,Z+26
 1032               	.LVL106:
1154:../../Source/queue.c **** 		{
 1033               		.loc 1 1154 0
 1034 03b6 838D      		ldd r24,Z+27
 1035               	.LVL107:
 1036 03b8 9817      		cp r25,r24
 1037 03ba 00F4      		brsh .L96
 1038               	.LBB14:
1156:../../Source/queue.c **** 
 1039               		.loc 1 1156 0
 1040 03bc 868D      		ldd r24,Z+30
 1041               	.LVL108:
1166:../../Source/queue.c **** 
 1042               		.loc 1 1166 0
 1043 03be 9F5F      		subi r25,lo8(-(1))
 1044               	.LVL109:
 1045 03c0 928F      		std Z+26,r25
1170:../../Source/queue.c **** 			{
 1046               		.loc 1 1170 0
 1047 03c2 8F3F      		cpi r24,lo8(-1)
 1048 03c4 01F4      		brne .L93
1225:../../Source/queue.c **** 					{
 1049               		.loc 1 1225 0
 1050 03c6 8189      		ldd r24,Z+17
 1051               	.LVL110:
 1052 03c8 8823      		tst r24
 1053 03ca 01F0      		breq .L103
 1054 03cc EB01      		movw r28,r22
 1055 03ce CF01      		movw r24,r30
1227:../../Source/queue.c **** 						{
 1056               		.loc 1 1227 0
 1057 03d0 4196      		adiw r24,17
 1058 03d2 0E94 0000 		call xTaskRemoveFromEventList
 1059               	.LVL111:
 1060 03d6 8823      		tst r24
 1061 03d8 01F0      		breq .L103
1231:../../Source/queue.c **** 							{
 1062               		.loc 1 1231 0
 1063 03da 2097      		sbiw r28,0
 1064 03dc 01F0      		breq .L103
1233:../../Source/queue.c **** 							}
 1065               		.loc 1 1233 0
 1066 03de 81E0      		ldi r24,lo8(1)
 1067 03e0 8883      		st Y,r24
 1068 03e2 00C0      		rjmp .L92
 1069               	.LVL112:
 1070               	.L93:
1256:../../Source/queue.c **** 			}
 1071               		.loc 1 1256 0
 1072 03e4 8F5F      		subi r24,lo8(-(1))
 1073               	.LVL113:
 1074 03e6 868F      		std Z+30,r24
 1075               	.LVL114:
 1076               	.L103:
1259:../../Source/queue.c **** 		}
 1077               		.loc 1 1259 0
 1078 03e8 81E0      		ldi r24,lo8(1)
 1079 03ea 00C0      		rjmp .L92
 1080               	.LVL115:
 1081               	.L96:
 1082               	.LBE14:
1264:../../Source/queue.c **** 		}
 1083               		.loc 1 1264 0
 1084 03ec 80E0      		ldi r24,0
 1085               	.LVL116:
 1086               	.L92:
 1087               	/* epilogue start */
 1088               	.LBE13:
1270:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1089               		.loc 1 1270 0
 1090 03ee DF91      		pop r29
 1091 03f0 CF91      		pop r28
 1092 03f2 0895      		ret
 1093               		.cfi_endproc
 1094               	.LFE9:
 1096               	.global	xQueueReceive
 1098               	xQueueReceive:
 1099               	.LFB10:
1274:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1100               		.loc 1 1274 0
 1101               		.cfi_startproc
 1102               	.LVL117:
 1103 03f4 AF92      		push r10
 1104               	.LCFI33:
 1105               		.cfi_def_cfa_offset 4
 1106               		.cfi_offset 10, -3
 1107 03f6 BF92      		push r11
 1108               	.LCFI34:
 1109               		.cfi_def_cfa_offset 5
 1110               		.cfi_offset 11, -4
 1111 03f8 CF92      		push r12
 1112               	.LCFI35:
 1113               		.cfi_def_cfa_offset 6
 1114               		.cfi_offset 12, -5
 1115 03fa DF92      		push r13
 1116               	.LCFI36:
 1117               		.cfi_def_cfa_offset 7
 1118               		.cfi_offset 13, -6
 1119 03fc FF92      		push r15
 1120               	.LCFI37:
 1121               		.cfi_def_cfa_offset 8
 1122               		.cfi_offset 15, -7
 1123 03fe 0F93      		push r16
 1124               	.LCFI38:
 1125               		.cfi_def_cfa_offset 9
 1126               		.cfi_offset 16, -8
 1127 0400 1F93      		push r17
 1128               	.LCFI39:
 1129               		.cfi_def_cfa_offset 10
 1130               		.cfi_offset 17, -9
 1131 0402 CF93      		push r28
 1132               	.LCFI40:
 1133               		.cfi_def_cfa_offset 11
 1134               		.cfi_offset 28, -10
 1135 0404 DF93      		push r29
 1136               	.LCFI41:
 1137               		.cfi_def_cfa_offset 12
 1138               		.cfi_offset 29, -11
 1139 0406 00D0      		rcall .
 1140 0408 1F92      		push __zero_reg__
 1141 040a 1F92      		push __zero_reg__
 1142               	.LCFI42:
 1143               		.cfi_def_cfa_offset 17
 1144 040c CDB7      		in r28,__SP_L__
 1145 040e DEB7      		in r29,__SP_H__
 1146               	.LCFI43:
 1147               		.cfi_def_cfa_register 28
 1148               	/* prologue: function */
 1149               	/* frame size = 5 */
 1150               	/* stack size = 14 */
 1151               	.L__stack_usage = 14
 1152 0410 8C01      		movw r16,r24
 1153 0412 6B01      		movw r12,r22
 1154 0414 5D83      		std Y+5,r21
 1155 0416 4C83      		std Y+4,r20
 1156               	.LVL118:
1275:../../Source/queue.c **** TimeOut_t xTimeOut;
 1157               		.loc 1 1275 0
 1158 0418 80E0      		ldi r24,0
 1159               	.LVL119:
1374:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1160               		.loc 1 1374 0
 1161 041a 5801      		movw r10,r16
 1162 041c 91E1      		ldi r25,17
 1163 041e A90E      		add r10,r25
 1164 0420 B11C      		adc r11,__zero_reg__
 1165               	.LVL120:
 1166               	.L105:
1299:../../Source/queue.c **** 		{
 1167               		.loc 1 1299 0
 1168               	/* #APP */
 1169               	 ;  1299 "../../Source/queue.c" 1
 1170 0422 0FB6      		in __tmp_reg__, __SREG__
 1171 0424 F894      		cli
 1172 0426 0F92      		push __tmp_reg__
 1173               		
 1174               	 ;  0 "" 2
 1175               	/* #NOAPP */
 1176               	.LBB15:
1301:../../Source/queue.c **** 
 1177               		.loc 1 1301 0
 1178 0428 F801      		movw r30,r16
 1179 042a F28C      		ldd r15,Z+26
 1180               	.LVL121:
1305:../../Source/queue.c **** 			{
 1181               		.loc 1 1305 0
 1182 042c FF20      		tst r15
 1183 042e 01F0      		breq .L106
1308:../../Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
 1184               		.loc 1 1308 0
 1185 0430 B601      		movw r22,r12
 1186 0432 C801      		movw r24,r16
 1187               	.LVL122:
 1188 0434 0E94 0000 		call prvCopyDataFromQueue
 1189               	.LVL123:
1310:../../Source/queue.c **** 
 1190               		.loc 1 1310 0
 1191 0438 FA94      		dec r15
 1192               	.LVL124:
 1193 043a F801      		movw r30,r16
 1194 043c F28E      		std Z+26,r15
1315:../../Source/queue.c **** 				{
 1195               		.loc 1 1315 0
 1196 043e 8085      		ldd r24,Z+8
 1197 0440 8823      		tst r24
 1198 0442 01F0      		breq .L108
1317:../../Source/queue.c **** 					{
 1199               		.loc 1 1317 0
 1200 0444 C801      		movw r24,r16
 1201 0446 0896      		adiw r24,8
 1202 0448 0E94 0000 		call xTaskRemoveFromEventList
 1203               	.LVL125:
 1204 044c 8111      		cpse r24,__zero_reg__
1319:../../Source/queue.c **** 					}
 1205               		.loc 1 1319 0
 1206 044e 0E94 0000 		call vPortYield
 1207               	.LVL126:
 1208               	.L108:
1331:../../Source/queue.c **** 				return pdPASS;
 1209               		.loc 1 1331 0
 1210               	/* #APP */
 1211               	 ;  1331 "../../Source/queue.c" 1
 1212 0452 0F90      		pop __tmp_reg__
 1213 0454 0FBE      		out __SREG__, __tmp_reg__
 1214               		
 1215               	 ;  0 "" 2
1332:../../Source/queue.c **** 			}
 1216               		.loc 1 1332 0
 1217               	/* #NOAPP */
 1218 0456 81E0      		ldi r24,lo8(1)
 1219 0458 00C0      		rjmp .L110
 1220               	.LVL127:
 1221               	.L106:
1336:../../Source/queue.c **** 				{
 1222               		.loc 1 1336 0
 1223 045a 2C81      		ldd r18,Y+4
 1224 045c 3D81      		ldd r19,Y+5
 1225 045e 232B      		or r18,r19
 1226 0460 01F4      		brne .L111
1340:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1227               		.loc 1 1340 0
 1228               	/* #APP */
 1229               	 ;  1340 "../../Source/queue.c" 1
 1230 0462 0F90      		pop __tmp_reg__
 1231 0464 0FBE      		out __SREG__, __tmp_reg__
 1232               		
 1233               	 ;  0 "" 2
 1234               	/* #NOAPP */
 1235 0466 00C0      		rjmp .L125
 1236               	.L111:
1344:../../Source/queue.c **** 				{
 1237               		.loc 1 1344 0
 1238 0468 8111      		cpse r24,__zero_reg__
 1239 046a 00C0      		rjmp .L112
1348:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1240               		.loc 1 1348 0
 1241 046c CE01      		movw r24,r28
 1242               	.LVL128:
 1243 046e 0196      		adiw r24,1
 1244 0470 0E94 0000 		call vTaskInternalSetTimeOutState
 1245               	.LVL129:
 1246               	.L112:
 1247               	.LBE15:
1358:../../Source/queue.c **** 
 1248               		.loc 1 1358 0
 1249               	/* #APP */
 1250               	 ;  1358 "../../Source/queue.c" 1
 1251 0474 0F90      		pop __tmp_reg__
 1252 0476 0FBE      		out __SREG__, __tmp_reg__
 1253               		
 1254               	 ;  0 "" 2
1363:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1255               		.loc 1 1363 0
 1256               	/* #NOAPP */
 1257 0478 0E94 0000 		call vTaskSuspendAll
 1258               	.LVL130:
1364:../../Source/queue.c **** 
 1259               		.loc 1 1364 0
 1260               	/* #APP */
 1261               	 ;  1364 "../../Source/queue.c" 1
 1262 047c 0FB6      		in __tmp_reg__, __SREG__
 1263 047e F894      		cli
 1264 0480 0F92      		push __tmp_reg__
 1265               		
 1266               	 ;  0 "" 2
 1267               	/* #NOAPP */
 1268 0482 F801      		movw r30,r16
 1269 0484 858D      		ldd r24,Z+29
 1270 0486 8F3F      		cpi r24,lo8(-1)
 1271 0488 01F4      		brne .L113
1364:../../Source/queue.c **** 
 1272               		.loc 1 1364 0 is_stmt 0 discriminator 1
 1273 048a 158E      		std Z+29,__zero_reg__
 1274               	.L113:
1364:../../Source/queue.c **** 
 1275               		.loc 1 1364 0 discriminator 3
 1276 048c F801      		movw r30,r16
 1277 048e 868D      		ldd r24,Z+30
 1278 0490 8F3F      		cpi r24,lo8(-1)
 1279 0492 01F4      		brne .L114
1364:../../Source/queue.c **** 
 1280               		.loc 1 1364 0 discriminator 4
 1281 0494 168E      		std Z+30,__zero_reg__
 1282               	.L114:
1364:../../Source/queue.c **** 
 1283               		.loc 1 1364 0 discriminator 6
 1284               	/* #APP */
 1285               	 ;  1364 "../../Source/queue.c" 1
 1286 0496 0F90      		pop __tmp_reg__
 1287 0498 0FBE      		out __SREG__, __tmp_reg__
 1288               		
 1289               	 ;  0 "" 2
1367:../../Source/queue.c **** 		{
 1290               		.loc 1 1367 0 is_stmt 1 discriminator 6
 1291               	/* #NOAPP */
 1292 049a BE01      		movw r22,r28
 1293 049c 6C5F      		subi r22,-4
 1294 049e 7F4F      		sbci r23,-1
 1295 04a0 CE01      		movw r24,r28
 1296 04a2 0196      		adiw r24,1
 1297 04a4 0E94 0000 		call xTaskCheckForTimeOut
 1298               	.LVL131:
 1299 04a8 8111      		cpse r24,__zero_reg__
 1300 04aa 00C0      		rjmp .L115
1371:../../Source/queue.c **** 			{
 1301               		.loc 1 1371 0
 1302 04ac C801      		movw r24,r16
 1303 04ae 0E94 0000 		call prvIsQueueEmpty
 1304               	.LVL132:
 1305 04b2 8823      		tst r24
 1306 04b4 01F0      		breq .L116
1374:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1307               		.loc 1 1374 0
 1308 04b6 6C81      		ldd r22,Y+4
 1309 04b8 7D81      		ldd r23,Y+5
 1310 04ba C501      		movw r24,r10
 1311 04bc 0E94 0000 		call vTaskPlaceOnEventList
 1312               	.LVL133:
1375:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1313               		.loc 1 1375 0
 1314 04c0 C801      		movw r24,r16
 1315 04c2 0E94 0000 		call prvUnlockQueue
 1316               	.LVL134:
1376:../../Source/queue.c **** 				{
 1317               		.loc 1 1376 0
 1318 04c6 0E94 0000 		call xTaskResumeAll
 1319               	.LVL135:
 1320 04ca 8823      		tst r24
 1321 04cc 01F0      		breq .L126
 1322               	.L118:
 1323 04ce 81E0      		ldi r24,lo8(1)
 1324 04d0 00C0      		rjmp .L105
 1325               	.L126:
1378:../../Source/queue.c **** 				}
 1326               		.loc 1 1378 0
 1327 04d2 0E94 0000 		call vPortYield
 1328               	.LVL136:
 1329 04d6 00C0      		rjmp .L118
 1330               	.L116:
1389:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 1331               		.loc 1 1389 0
 1332 04d8 C801      		movw r24,r16
 1333 04da 0E94 0000 		call prvUnlockQueue
 1334               	.LVL137:
1390:../../Source/queue.c **** 			}
 1335               		.loc 1 1390 0
 1336 04de 0E94 0000 		call xTaskResumeAll
 1337               	.LVL138:
 1338 04e2 00C0      		rjmp .L118
 1339               	.L115:
1397:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 1340               		.loc 1 1397 0
 1341 04e4 C801      		movw r24,r16
 1342 04e6 0E94 0000 		call prvUnlockQueue
 1343               	.LVL139:
1398:../../Source/queue.c **** 
 1344               		.loc 1 1398 0
 1345 04ea 0E94 0000 		call xTaskResumeAll
 1346               	.LVL140:
1400:../../Source/queue.c **** 			{
 1347               		.loc 1 1400 0
 1348 04ee C801      		movw r24,r16
 1349 04f0 0E94 0000 		call prvIsQueueEmpty
 1350               	.LVL141:
 1351 04f4 8823      		tst r24
 1352 04f6 01F0      		breq .L118
 1353               	.LVL142:
 1354               	.L125:
1403:../../Source/queue.c **** 			}
 1355               		.loc 1 1403 0
 1356 04f8 80E0      		ldi r24,0
 1357               	.LVL143:
 1358               	.L110:
 1359               	/* epilogue start */
1411:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1360               		.loc 1 1411 0
 1361 04fa 0F90      		pop __tmp_reg__
 1362 04fc 0F90      		pop __tmp_reg__
 1363 04fe 0F90      		pop __tmp_reg__
 1364 0500 0F90      		pop __tmp_reg__
 1365 0502 0F90      		pop __tmp_reg__
 1366 0504 DF91      		pop r29
 1367 0506 CF91      		pop r28
 1368               	.LVL144:
 1369 0508 1F91      		pop r17
 1370               	.LVL145:
 1371 050a 0F91      		pop r16
 1372               	.LVL146:
 1373 050c FF90      		pop r15
 1374               	.LVL147:
 1375 050e DF90      		pop r13
 1376               	.LVL148:
 1377 0510 CF90      		pop r12
 1378               	.LVL149:
 1379 0512 BF90      		pop r11
 1380               	.LVL150:
 1381 0514 AF90      		pop r10
 1382               	.LVL151:
 1383 0516 0895      		ret
 1384               		.cfi_endproc
 1385               	.LFE10:
 1387               	.global	xQueueSemaphoreTake
 1389               	xQueueSemaphoreTake:
 1390               	.LFB11:
1415:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1391               		.loc 1 1415 0
 1392               		.cfi_startproc
 1393               	.LVL152:
 1394 0518 EF92      		push r14
 1395               	.LCFI44:
 1396               		.cfi_def_cfa_offset 4
 1397               		.cfi_offset 14, -3
 1398 051a FF92      		push r15
 1399               	.LCFI45:
 1400               		.cfi_def_cfa_offset 5
 1401               		.cfi_offset 15, -4
 1402 051c 0F93      		push r16
 1403               	.LCFI46:
 1404               		.cfi_def_cfa_offset 6
 1405               		.cfi_offset 16, -5
 1406 051e 1F93      		push r17
 1407               	.LCFI47:
 1408               		.cfi_def_cfa_offset 7
 1409               		.cfi_offset 17, -6
 1410 0520 CF93      		push r28
 1411               	.LCFI48:
 1412               		.cfi_def_cfa_offset 8
 1413               		.cfi_offset 28, -7
 1414 0522 DF93      		push r29
 1415               	.LCFI49:
 1416               		.cfi_def_cfa_offset 9
 1417               		.cfi_offset 29, -8
 1418 0524 00D0      		rcall .
 1419 0526 1F92      		push __zero_reg__
 1420 0528 1F92      		push __zero_reg__
 1421               	.LCFI50:
 1422               		.cfi_def_cfa_offset 14
 1423 052a CDB7      		in r28,__SP_L__
 1424 052c DEB7      		in r29,__SP_H__
 1425               	.LCFI51:
 1426               		.cfi_def_cfa_register 28
 1427               	/* prologue: function */
 1428               	/* frame size = 5 */
 1429               	/* stack size = 11 */
 1430               	.L__stack_usage = 11
 1431 052e 8C01      		movw r16,r24
 1432 0530 7D83      		std Y+5,r23
 1433 0532 6C83      		std Y+4,r22
 1434               	.LVL153:
1416:../../Source/queue.c **** TimeOut_t xTimeOut;
 1435               		.loc 1 1416 0
 1436 0534 90E0      		ldi r25,0
1565:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1437               		.loc 1 1565 0
 1438 0536 7801      		movw r14,r16
 1439 0538 81E1      		ldi r24,17
 1440 053a E80E      		add r14,r24
 1441 053c F11C      		adc r15,__zero_reg__
 1442               	.LVL154:
 1443               	.L128:
1444:../../Source/queue.c **** 		{
 1444               		.loc 1 1444 0
 1445               	/* #APP */
 1446               	 ;  1444 "../../Source/queue.c" 1
 1447 053e 0FB6      		in __tmp_reg__, __SREG__
 1448 0540 F894      		cli
 1449 0542 0F92      		push __tmp_reg__
 1450               		
 1451               	 ;  0 "" 2
 1452               	/* #NOAPP */
 1453               	.LBB16:
1448:../../Source/queue.c **** 
 1454               		.loc 1 1448 0
 1455 0544 F801      		movw r30,r16
 1456 0546 828D      		ldd r24,Z+26
 1457               	.LVL155:
1452:../../Source/queue.c **** 			{
 1458               		.loc 1 1452 0
 1459 0548 8823      		tst r24
 1460 054a 01F0      		breq .L129
1458:../../Source/queue.c **** 
 1461               		.loc 1 1458 0
 1462 054c 8150      		subi r24,lo8(-(-1))
 1463               	.LVL156:
 1464 054e 828F      		std Z+26,r24
1477:../../Source/queue.c **** 				{
 1465               		.loc 1 1477 0
 1466 0550 8085      		ldd r24,Z+8
 1467               	.LVL157:
 1468 0552 8823      		tst r24
 1469 0554 01F0      		breq .L131
1479:../../Source/queue.c **** 					{
 1470               		.loc 1 1479 0
 1471 0556 C801      		movw r24,r16
 1472 0558 0896      		adiw r24,8
 1473 055a 0E94 0000 		call xTaskRemoveFromEventList
 1474               	.LVL158:
 1475 055e 8111      		cpse r24,__zero_reg__
1481:../../Source/queue.c **** 					}
 1476               		.loc 1 1481 0
 1477 0560 0E94 0000 		call vPortYield
 1478               	.LVL159:
 1479               	.L131:
1493:../../Source/queue.c **** 				return pdPASS;
 1480               		.loc 1 1493 0
 1481               	/* #APP */
 1482               	 ;  1493 "../../Source/queue.c" 1
 1483 0564 0F90      		pop __tmp_reg__
 1484 0566 0FBE      		out __SREG__, __tmp_reg__
 1485               		
 1486               	 ;  0 "" 2
1494:../../Source/queue.c **** 			}
 1487               		.loc 1 1494 0
 1488               	/* #NOAPP */
 1489 0568 81E0      		ldi r24,lo8(1)
 1490 056a 00C0      		rjmp .L133
 1491               	.LVL160:
 1492               	.L129:
1498:../../Source/queue.c **** 				{
 1493               		.loc 1 1498 0
 1494 056c 2C81      		ldd r18,Y+4
 1495 056e 3D81      		ldd r19,Y+5
 1496 0570 232B      		or r18,r19
 1497 0572 01F4      		brne .L134
1511:../../Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1498               		.loc 1 1511 0
 1499               	/* #APP */
 1500               	 ;  1511 "../../Source/queue.c" 1
 1501 0574 0F90      		pop __tmp_reg__
 1502 0576 0FBE      		out __SREG__, __tmp_reg__
 1503               		
 1504               	 ;  0 "" 2
 1505               	/* #NOAPP */
 1506 0578 00C0      		rjmp .L148
 1507               	.L134:
1515:../../Source/queue.c **** 				{
 1508               		.loc 1 1515 0
 1509 057a 9111      		cpse r25,__zero_reg__
 1510 057c 00C0      		rjmp .L135
1519:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1511               		.loc 1 1519 0
 1512 057e CE01      		movw r24,r28
 1513               	.LVL161:
 1514 0580 0196      		adiw r24,1
 1515 0582 0E94 0000 		call vTaskInternalSetTimeOutState
 1516               	.LVL162:
 1517               	.L135:
 1518               	.LBE16:
1529:../../Source/queue.c **** 
 1519               		.loc 1 1529 0
 1520               	/* #APP */
 1521               	 ;  1529 "../../Source/queue.c" 1
 1522 0586 0F90      		pop __tmp_reg__
 1523 0588 0FBE      		out __SREG__, __tmp_reg__
 1524               		
 1525               	 ;  0 "" 2
1534:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1526               		.loc 1 1534 0
 1527               	/* #NOAPP */
 1528 058a 0E94 0000 		call vTaskSuspendAll
 1529               	.LVL163:
1535:../../Source/queue.c **** 
 1530               		.loc 1 1535 0
 1531               	/* #APP */
 1532               	 ;  1535 "../../Source/queue.c" 1
 1533 058e 0FB6      		in __tmp_reg__, __SREG__
 1534 0590 F894      		cli
 1535 0592 0F92      		push __tmp_reg__
 1536               		
 1537               	 ;  0 "" 2
 1538               	/* #NOAPP */
 1539 0594 F801      		movw r30,r16
 1540 0596 858D      		ldd r24,Z+29
 1541 0598 8F3F      		cpi r24,lo8(-1)
 1542 059a 01F4      		brne .L136
1535:../../Source/queue.c **** 
 1543               		.loc 1 1535 0 is_stmt 0 discriminator 1
 1544 059c 158E      		std Z+29,__zero_reg__
 1545               	.L136:
1535:../../Source/queue.c **** 
 1546               		.loc 1 1535 0 discriminator 3
 1547 059e F801      		movw r30,r16
 1548 05a0 868D      		ldd r24,Z+30
 1549 05a2 8F3F      		cpi r24,lo8(-1)
 1550 05a4 01F4      		brne .L137
1535:../../Source/queue.c **** 
 1551               		.loc 1 1535 0 discriminator 4
 1552 05a6 168E      		std Z+30,__zero_reg__
 1553               	.L137:
1535:../../Source/queue.c **** 
 1554               		.loc 1 1535 0 discriminator 6
 1555               	/* #APP */
 1556               	 ;  1535 "../../Source/queue.c" 1
 1557 05a8 0F90      		pop __tmp_reg__
 1558 05aa 0FBE      		out __SREG__, __tmp_reg__
 1559               		
 1560               	 ;  0 "" 2
1538:../../Source/queue.c **** 		{
 1561               		.loc 1 1538 0 is_stmt 1 discriminator 6
 1562               	/* #NOAPP */
 1563 05ac BE01      		movw r22,r28
 1564 05ae 6C5F      		subi r22,-4
 1565 05b0 7F4F      		sbci r23,-1
 1566 05b2 CE01      		movw r24,r28
 1567 05b4 0196      		adiw r24,1
 1568 05b6 0E94 0000 		call xTaskCheckForTimeOut
 1569               	.LVL164:
 1570 05ba 8111      		cpse r24,__zero_reg__
 1571 05bc 00C0      		rjmp .L138
1544:../../Source/queue.c **** 			{
 1572               		.loc 1 1544 0
 1573 05be C801      		movw r24,r16
 1574 05c0 0E94 0000 		call prvIsQueueEmpty
 1575               	.LVL165:
 1576 05c4 8823      		tst r24
 1577 05c6 01F0      		breq .L139
1565:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1578               		.loc 1 1565 0
 1579 05c8 6C81      		ldd r22,Y+4
 1580 05ca 7D81      		ldd r23,Y+5
 1581 05cc C701      		movw r24,r14
 1582 05ce 0E94 0000 		call vTaskPlaceOnEventList
 1583               	.LVL166:
1566:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1584               		.loc 1 1566 0
 1585 05d2 C801      		movw r24,r16
 1586 05d4 0E94 0000 		call prvUnlockQueue
 1587               	.LVL167:
1567:../../Source/queue.c **** 				{
 1588               		.loc 1 1567 0
 1589 05d8 0E94 0000 		call xTaskResumeAll
 1590               	.LVL168:
 1591 05dc 8823      		tst r24
 1592 05de 01F0      		breq .L149
 1593               	.L141:
 1594 05e0 91E0      		ldi r25,lo8(1)
 1595 05e2 00C0      		rjmp .L128
 1596               	.L149:
1569:../../Source/queue.c **** 				}
 1597               		.loc 1 1569 0
 1598 05e4 0E94 0000 		call vPortYield
 1599               	.LVL169:
 1600 05e8 00C0      		rjmp .L141
 1601               	.L139:
1580:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 1602               		.loc 1 1580 0
 1603 05ea C801      		movw r24,r16
 1604 05ec 0E94 0000 		call prvUnlockQueue
 1605               	.LVL170:
1581:../../Source/queue.c **** 			}
 1606               		.loc 1 1581 0
 1607 05f0 0E94 0000 		call xTaskResumeAll
 1608               	.LVL171:
 1609 05f4 00C0      		rjmp .L141
 1610               	.L138:
1587:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 1611               		.loc 1 1587 0
 1612 05f6 C801      		movw r24,r16
 1613 05f8 0E94 0000 		call prvUnlockQueue
 1614               	.LVL172:
1588:../../Source/queue.c **** 
 1615               		.loc 1 1588 0
 1616 05fc 0E94 0000 		call xTaskResumeAll
 1617               	.LVL173:
1594:../../Source/queue.c **** 			{
 1618               		.loc 1 1594 0
 1619 0600 C801      		movw r24,r16
 1620 0602 0E94 0000 		call prvIsQueueEmpty
 1621               	.LVL174:
 1622 0606 8823      		tst r24
 1623 0608 01F0      		breq .L141
 1624               	.LVL175:
 1625               	.L148:
1621:../../Source/queue.c **** 			}
 1626               		.loc 1 1621 0
 1627 060a 80E0      		ldi r24,0
 1628               	.L133:
 1629               	/* epilogue start */
1629:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1630               		.loc 1 1629 0
 1631 060c 0F90      		pop __tmp_reg__
 1632 060e 0F90      		pop __tmp_reg__
 1633 0610 0F90      		pop __tmp_reg__
 1634 0612 0F90      		pop __tmp_reg__
 1635 0614 0F90      		pop __tmp_reg__
 1636 0616 DF91      		pop r29
 1637 0618 CF91      		pop r28
 1638               	.LVL176:
 1639 061a 1F91      		pop r17
 1640               	.LVL177:
 1641 061c 0F91      		pop r16
 1642               	.LVL178:
 1643 061e FF90      		pop r15
 1644               	.LVL179:
 1645 0620 EF90      		pop r14
 1646               	.LVL180:
 1647 0622 0895      		ret
 1648               		.cfi_endproc
 1649               	.LFE11:
 1651               	.global	xQueuePeek
 1653               	xQueuePeek:
 1654               	.LFB12:
1633:../../Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1655               		.loc 1 1633 0
 1656               		.cfi_startproc
 1657               	.LVL181:
 1658 0624 CF92      		push r12
 1659               	.LCFI52:
 1660               		.cfi_def_cfa_offset 4
 1661               		.cfi_offset 12, -3
 1662 0626 DF92      		push r13
 1663               	.LCFI53:
 1664               		.cfi_def_cfa_offset 5
 1665               		.cfi_offset 13, -4
 1666 0628 EF92      		push r14
 1667               	.LCFI54:
 1668               		.cfi_def_cfa_offset 6
 1669               		.cfi_offset 14, -5
 1670 062a FF92      		push r15
 1671               	.LCFI55:
 1672               		.cfi_def_cfa_offset 7
 1673               		.cfi_offset 15, -6
 1674 062c 0F93      		push r16
 1675               	.LCFI56:
 1676               		.cfi_def_cfa_offset 8
 1677               		.cfi_offset 16, -7
 1678 062e 1F93      		push r17
 1679               	.LCFI57:
 1680               		.cfi_def_cfa_offset 9
 1681               		.cfi_offset 17, -8
 1682 0630 CF93      		push r28
 1683               	.LCFI58:
 1684               		.cfi_def_cfa_offset 10
 1685               		.cfi_offset 28, -9
 1686 0632 DF93      		push r29
 1687               	.LCFI59:
 1688               		.cfi_def_cfa_offset 11
 1689               		.cfi_offset 29, -10
 1690 0634 00D0      		rcall .
 1691 0636 1F92      		push __zero_reg__
 1692 0638 1F92      		push __zero_reg__
 1693               	.LCFI60:
 1694               		.cfi_def_cfa_offset 16
 1695 063a CDB7      		in r28,__SP_L__
 1696 063c DEB7      		in r29,__SP_H__
 1697               	.LCFI61:
 1698               		.cfi_def_cfa_register 28
 1699               	/* prologue: function */
 1700               	/* frame size = 5 */
 1701               	/* stack size = 13 */
 1702               	.L__stack_usage = 13
 1703 063e 8C01      		movw r16,r24
 1704 0640 7B01      		movw r14,r22
 1705 0642 5D83      		std Y+5,r21
 1706 0644 4C83      		std Y+4,r20
 1707               	.LVL182:
1634:../../Source/queue.c **** TimeOut_t xTimeOut;
 1708               		.loc 1 1634 0
 1709 0646 80E0      		ldi r24,0
 1710               	.LVL183:
1741:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1711               		.loc 1 1741 0
 1712 0648 6801      		movw r12,r16
 1713 064a 91E1      		ldi r25,17
 1714 064c C90E      		add r12,r25
 1715 064e D11C      		adc r13,__zero_reg__
 1716               	.LVL184:
 1717               	.L151:
1659:../../Source/queue.c **** 		{
 1718               		.loc 1 1659 0
 1719               	/* #APP */
 1720               	 ;  1659 "../../Source/queue.c" 1
 1721 0650 0FB6      		in __tmp_reg__, __SREG__
 1722 0652 F894      		cli
 1723 0654 0F92      		push __tmp_reg__
 1724               		
 1725               	 ;  0 "" 2
 1726               	/* #NOAPP */
 1727               	.LBB17:
1661:../../Source/queue.c **** 
 1728               		.loc 1 1661 0
 1729 0656 F801      		movw r30,r16
 1730 0658 928D      		ldd r25,Z+26
 1731               	.LVL185:
1665:../../Source/queue.c **** 			{
 1732               		.loc 1 1665 0
 1733 065a 9923      		tst r25
 1734 065c 01F0      		breq .L152
1670:../../Source/queue.c **** 
 1735               		.loc 1 1670 0
 1736 065e C680      		ldd r12,Z+6
 1737 0660 D780      		ldd r13,Z+7
 1738               	.LVL186:
1672:../../Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
 1739               		.loc 1 1672 0
 1740 0662 B701      		movw r22,r14
 1741 0664 C801      		movw r24,r16
 1742               	.LVL187:
 1743 0666 0E94 0000 		call prvCopyDataFromQueue
 1744               	.LVL188:
1676:../../Source/queue.c **** 
 1745               		.loc 1 1676 0
 1746 066a F801      		movw r30,r16
 1747 066c D782      		std Z+7,r13
 1748 066e C682      		std Z+6,r12
1680:../../Source/queue.c **** 				{
 1749               		.loc 1 1680 0
 1750 0670 8189      		ldd r24,Z+17
 1751 0672 8823      		tst r24
 1752 0674 01F0      		breq .L154
1682:../../Source/queue.c **** 					{
 1753               		.loc 1 1682 0
 1754 0676 C801      		movw r24,r16
 1755 0678 4196      		adiw r24,17
 1756 067a 0E94 0000 		call xTaskRemoveFromEventList
 1757               	.LVL189:
 1758 067e 8111      		cpse r24,__zero_reg__
1685:../../Source/queue.c **** 					}
 1759               		.loc 1 1685 0
 1760 0680 0E94 0000 		call vPortYield
 1761               	.LVL190:
 1762               	.L154:
1697:../../Source/queue.c **** 				return pdPASS;
 1763               		.loc 1 1697 0
 1764               	/* #APP */
 1765               	 ;  1697 "../../Source/queue.c" 1
 1766 0684 0F90      		pop __tmp_reg__
 1767 0686 0FBE      		out __SREG__, __tmp_reg__
 1768               		
 1769               	 ;  0 "" 2
1698:../../Source/queue.c **** 			}
 1770               		.loc 1 1698 0
 1771               	/* #NOAPP */
 1772 0688 81E0      		ldi r24,lo8(1)
 1773 068a 00C0      		rjmp .L156
 1774               	.LVL191:
 1775               	.L152:
1702:../../Source/queue.c **** 				{
 1776               		.loc 1 1702 0
 1777 068c 2C81      		ldd r18,Y+4
 1778 068e 3D81      		ldd r19,Y+5
 1779 0690 232B      		or r18,r19
 1780 0692 01F4      		brne .L157
1706:../../Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
 1781               		.loc 1 1706 0
 1782               	/* #APP */
 1783               	 ;  1706 "../../Source/queue.c" 1
 1784 0694 0F90      		pop __tmp_reg__
 1785 0696 0FBE      		out __SREG__, __tmp_reg__
 1786               		
 1787               	 ;  0 "" 2
 1788               	/* #NOAPP */
 1789 0698 00C0      		rjmp .L171
 1790               	.L157:
1710:../../Source/queue.c **** 				{
 1791               		.loc 1 1710 0
 1792 069a 8111      		cpse r24,__zero_reg__
 1793 069c 00C0      		rjmp .L158
1715:../../Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1794               		.loc 1 1715 0
 1795 069e CE01      		movw r24,r28
 1796               	.LVL192:
 1797 06a0 0196      		adiw r24,1
 1798 06a2 0E94 0000 		call vTaskInternalSetTimeOutState
 1799               	.LVL193:
 1800               	.L158:
 1801               	.LBE17:
1725:../../Source/queue.c **** 
 1802               		.loc 1 1725 0
 1803               	/* #APP */
 1804               	 ;  1725 "../../Source/queue.c" 1
 1805 06a6 0F90      		pop __tmp_reg__
 1806 06a8 0FBE      		out __SREG__, __tmp_reg__
 1807               		
 1808               	 ;  0 "" 2
1730:../../Source/queue.c **** 		prvLockQueue( pxQueue );
 1809               		.loc 1 1730 0
 1810               	/* #NOAPP */
 1811 06aa 0E94 0000 		call vTaskSuspendAll
 1812               	.LVL194:
1731:../../Source/queue.c **** 
 1813               		.loc 1 1731 0
 1814               	/* #APP */
 1815               	 ;  1731 "../../Source/queue.c" 1
 1816 06ae 0FB6      		in __tmp_reg__, __SREG__
 1817 06b0 F894      		cli
 1818 06b2 0F92      		push __tmp_reg__
 1819               		
 1820               	 ;  0 "" 2
 1821               	/* #NOAPP */
 1822 06b4 F801      		movw r30,r16
 1823 06b6 858D      		ldd r24,Z+29
 1824 06b8 8F3F      		cpi r24,lo8(-1)
 1825 06ba 01F4      		brne .L159
1731:../../Source/queue.c **** 
 1826               		.loc 1 1731 0 is_stmt 0 discriminator 1
 1827 06bc 158E      		std Z+29,__zero_reg__
 1828               	.L159:
1731:../../Source/queue.c **** 
 1829               		.loc 1 1731 0 discriminator 3
 1830 06be F801      		movw r30,r16
 1831 06c0 868D      		ldd r24,Z+30
 1832 06c2 8F3F      		cpi r24,lo8(-1)
 1833 06c4 01F4      		brne .L160
1731:../../Source/queue.c **** 
 1834               		.loc 1 1731 0 discriminator 4
 1835 06c6 168E      		std Z+30,__zero_reg__
 1836               	.L160:
1731:../../Source/queue.c **** 
 1837               		.loc 1 1731 0 discriminator 6
 1838               	/* #APP */
 1839               	 ;  1731 "../../Source/queue.c" 1
 1840 06c8 0F90      		pop __tmp_reg__
 1841 06ca 0FBE      		out __SREG__, __tmp_reg__
 1842               		
 1843               	 ;  0 "" 2
1734:../../Source/queue.c **** 		{
 1844               		.loc 1 1734 0 is_stmt 1 discriminator 6
 1845               	/* #NOAPP */
 1846 06cc BE01      		movw r22,r28
 1847 06ce 6C5F      		subi r22,-4
 1848 06d0 7F4F      		sbci r23,-1
 1849 06d2 CE01      		movw r24,r28
 1850 06d4 0196      		adiw r24,1
 1851 06d6 0E94 0000 		call xTaskCheckForTimeOut
 1852               	.LVL195:
 1853 06da 8111      		cpse r24,__zero_reg__
 1854 06dc 00C0      		rjmp .L161
1738:../../Source/queue.c **** 			{
 1855               		.loc 1 1738 0
 1856 06de C801      		movw r24,r16
 1857 06e0 0E94 0000 		call prvIsQueueEmpty
 1858               	.LVL196:
 1859 06e4 8823      		tst r24
 1860 06e6 01F0      		breq .L162
1741:../../Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1861               		.loc 1 1741 0
 1862 06e8 6C81      		ldd r22,Y+4
 1863 06ea 7D81      		ldd r23,Y+5
 1864 06ec C601      		movw r24,r12
 1865 06ee 0E94 0000 		call vTaskPlaceOnEventList
 1866               	.LVL197:
1742:../../Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1867               		.loc 1 1742 0
 1868 06f2 C801      		movw r24,r16
 1869 06f4 0E94 0000 		call prvUnlockQueue
 1870               	.LVL198:
1743:../../Source/queue.c **** 				{
 1871               		.loc 1 1743 0
 1872 06f8 0E94 0000 		call xTaskResumeAll
 1873               	.LVL199:
 1874 06fc 8823      		tst r24
 1875 06fe 01F0      		breq .L172
 1876               	.L164:
 1877 0700 81E0      		ldi r24,lo8(1)
 1878 0702 00C0      		rjmp .L151
 1879               	.L172:
1745:../../Source/queue.c **** 				}
 1880               		.loc 1 1745 0
 1881 0704 0E94 0000 		call vPortYield
 1882               	.LVL200:
 1883 0708 00C0      		rjmp .L164
 1884               	.L162:
1756:../../Source/queue.c **** 				( void ) xTaskResumeAll();
 1885               		.loc 1 1756 0
 1886 070a C801      		movw r24,r16
 1887 070c 0E94 0000 		call prvUnlockQueue
 1888               	.LVL201:
1757:../../Source/queue.c **** 			}
 1889               		.loc 1 1757 0
 1890 0710 0E94 0000 		call xTaskResumeAll
 1891               	.LVL202:
 1892 0714 00C0      		rjmp .L164
 1893               	.L161:
1764:../../Source/queue.c **** 			( void ) xTaskResumeAll();
 1894               		.loc 1 1764 0
 1895 0716 C801      		movw r24,r16
 1896 0718 0E94 0000 		call prvUnlockQueue
 1897               	.LVL203:
1765:../../Source/queue.c **** 
 1898               		.loc 1 1765 0
 1899 071c 0E94 0000 		call xTaskResumeAll
 1900               	.LVL204:
1767:../../Source/queue.c **** 			{
 1901               		.loc 1 1767 0
 1902 0720 C801      		movw r24,r16
 1903 0722 0E94 0000 		call prvIsQueueEmpty
 1904               	.LVL205:
 1905 0726 8823      		tst r24
 1906 0728 01F0      		breq .L164
 1907               	.LVL206:
 1908               	.L171:
1770:../../Source/queue.c **** 			}
 1909               		.loc 1 1770 0
 1910 072a 80E0      		ldi r24,0
 1911               	.L156:
 1912               	/* epilogue start */
1778:../../Source/queue.c **** /*-----------------------------------------------------------*/
 1913               		.loc 1 1778 0
 1914 072c 0F90      		pop __tmp_reg__
 1915 072e 0F90      		pop __tmp_reg__
 1916 0730 0F90      		pop __tmp_reg__
 1917 0732 0F90      		pop __tmp_reg__
 1918 0734 0F90      		pop __tmp_reg__
 1919 0736 DF91      		pop r29
 1920 0738 CF91      		pop r28
 1921               	.LVL207:
 1922 073a 1F91      		pop r17
 1923               	.LVL208:
 1924 073c 0F91      		pop r16
 1925               	.LVL209:
 1926 073e FF90      		pop r15
 1927               	.LVL210:
 1928 0740 EF90      		pop r14
 1929               	.LVL211:
 1930 0742 DF90      		pop r13
 1931               	.LVL212:
 1932 0744 CF90      		pop r12
 1933               	.LVL213:
 1934 0746 0895      		ret
 1935               		.cfi_endproc
 1936               	.LFE12:
 1938               	.global	xQueueReceiveFromISR
 1940               	xQueueReceiveFromISR:
 1941               	.LFB13:
1782:../../Source/queue.c **** BaseType_t xReturn;
 1942               		.loc 1 1782 0
 1943               		.cfi_startproc
 1944               	.LVL214:
 1945 0748 EF92      		push r14
 1946               	.LCFI62:
 1947               		.cfi_def_cfa_offset 4
 1948               		.cfi_offset 14, -3
 1949 074a FF92      		push r15
 1950               	.LCFI63:
 1951               		.cfi_def_cfa_offset 5
 1952               		.cfi_offset 15, -4
 1953 074c 0F93      		push r16
 1954               	.LCFI64:
 1955               		.cfi_def_cfa_offset 6
 1956               		.cfi_offset 16, -5
 1957 074e 1F93      		push r17
 1958               	.LCFI65:
 1959               		.cfi_def_cfa_offset 7
 1960               		.cfi_offset 17, -6
 1961 0750 CF93      		push r28
 1962               	.LCFI66:
 1963               		.cfi_def_cfa_offset 8
 1964               		.cfi_offset 28, -7
 1965 0752 DF93      		push r29
 1966               	.LCFI67:
 1967               		.cfi_def_cfa_offset 9
 1968               		.cfi_offset 29, -8
 1969               	/* prologue: function */
 1970               	/* frame size = 0 */
 1971               	/* stack size = 6 */
 1972               	.L__stack_usage = 6
 1973               	.LVL215:
 1974               	.LBB18:
1808:../../Source/queue.c **** 
 1975               		.loc 1 1808 0
 1976 0754 FC01      		movw r30,r24
 1977 0756 028D      		ldd r16,Z+26
 1978               	.LVL216:
1811:../../Source/queue.c **** 		{
 1979               		.loc 1 1811 0
 1980 0758 0023      		tst r16
 1981 075a 01F0      		breq .L178
 1982 075c 7A01      		movw r14,r20
 1983 075e EC01      		movw r28,r24
 1984               	.LBB19:
1813:../../Source/queue.c **** 
 1985               		.loc 1 1813 0
 1986 0760 158D      		ldd r17,Z+29
 1987               	.LVL217:
1817:../../Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1988               		.loc 1 1817 0
 1989 0762 0E94 0000 		call prvCopyDataFromQueue
 1990               	.LVL218:
1818:../../Source/queue.c **** 
 1991               		.loc 1 1818 0
 1992 0766 0150      		subi r16,lo8(-(-1))
 1993               	.LVL219:
 1994 0768 0A8F      		std Y+26,r16
1824:../../Source/queue.c **** 			{
 1995               		.loc 1 1824 0
 1996 076a 1F3F      		cpi r17,lo8(-1)
 1997 076c 01F4      		brne .L175
1826:../../Source/queue.c **** 				{
 1998               		.loc 1 1826 0
 1999 076e 8885      		ldd r24,Y+8
 2000 0770 8823      		tst r24
 2001 0772 01F0      		breq .L185
1828:../../Source/queue.c **** 					{
 2002               		.loc 1 1828 0
 2003 0774 CE01      		movw r24,r28
 2004 0776 0896      		adiw r24,8
 2005 0778 0E94 0000 		call xTaskRemoveFromEventList
 2006               	.LVL220:
 2007 077c 8823      		tst r24
 2008 077e 01F0      		breq .L185
1832:../../Source/queue.c **** 						{
 2009               		.loc 1 1832 0
 2010 0780 E114      		cp r14,__zero_reg__
 2011 0782 F104      		cpc r15,__zero_reg__
 2012 0784 01F0      		breq .L185
1834:../../Source/queue.c **** 						}
 2013               		.loc 1 1834 0
 2014 0786 81E0      		ldi r24,lo8(1)
 2015 0788 F701      		movw r30,r14
 2016 078a 8083      		st Z,r24
 2017 078c 00C0      		rjmp .L174
 2018               	.L175:
1855:../../Source/queue.c **** 			}
 2019               		.loc 1 1855 0
 2020 078e 1F5F      		subi r17,lo8(-(1))
 2021               	.LVL221:
 2022 0790 1D8F      		std Y+29,r17
 2023               	.LVL222:
 2024               	.L185:
1858:../../Source/queue.c **** 		}
 2025               		.loc 1 1858 0
 2026 0792 81E0      		ldi r24,lo8(1)
 2027 0794 00C0      		rjmp .L174
 2028               	.LVL223:
 2029               	.L178:
 2030               	.LBE19:
1862:../../Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2031               		.loc 1 1862 0
 2032 0796 80E0      		ldi r24,0
 2033               	.LVL224:
 2034               	.L174:
 2035               	/* epilogue start */
 2036               	.LBE18:
1869:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2037               		.loc 1 1869 0
 2038 0798 DF91      		pop r29
 2039 079a CF91      		pop r28
 2040 079c 1F91      		pop r17
 2041 079e 0F91      		pop r16
 2042 07a0 FF90      		pop r15
 2043 07a2 EF90      		pop r14
 2044 07a4 0895      		ret
 2045               		.cfi_endproc
 2046               	.LFE13:
 2048               	.global	xQueuePeekFromISR
 2050               	xQueuePeekFromISR:
 2051               	.LFB14:
1873:../../Source/queue.c **** BaseType_t xReturn;
 2052               		.loc 1 1873 0
 2053               		.cfi_startproc
 2054               	.LVL225:
 2055 07a6 0F93      		push r16
 2056               	.LCFI68:
 2057               		.cfi_def_cfa_offset 4
 2058               		.cfi_offset 16, -3
 2059 07a8 1F93      		push r17
 2060               	.LCFI69:
 2061               		.cfi_def_cfa_offset 5
 2062               		.cfi_offset 17, -4
 2063 07aa CF93      		push r28
 2064               	.LCFI70:
 2065               		.cfi_def_cfa_offset 6
 2066               		.cfi_offset 28, -5
 2067 07ac DF93      		push r29
 2068               	.LCFI71:
 2069               		.cfi_def_cfa_offset 7
 2070               		.cfi_offset 29, -6
 2071               	/* prologue: function */
 2072               	/* frame size = 0 */
 2073               	/* stack size = 4 */
 2074               	.L__stack_usage = 4
 2075               	.LVL226:
1902:../../Source/queue.c **** 		{
 2076               		.loc 1 1902 0
 2077 07ae FC01      		movw r30,r24
 2078 07b0 228D      		ldd r18,Z+26
 2079 07b2 2223      		tst r18
 2080 07b4 01F0      		breq .L188
 2081 07b6 EC01      		movw r28,r24
1908:../../Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2082               		.loc 1 1908 0
 2083 07b8 0681      		ldd r16,Z+6
 2084 07ba 1781      		ldd r17,Z+7
 2085               	.LVL227:
1909:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2086               		.loc 1 1909 0
 2087 07bc 0E94 0000 		call prvCopyDataFromQueue
 2088               	.LVL228:
1910:../../Source/queue.c **** 
 2089               		.loc 1 1910 0
 2090 07c0 1F83      		std Y+7,r17
 2091 07c2 0E83      		std Y+6,r16
 2092               	.LVL229:
1912:../../Source/queue.c **** 		}
 2093               		.loc 1 1912 0
 2094 07c4 81E0      		ldi r24,lo8(1)
 2095 07c6 00C0      		rjmp .L187
 2096               	.LVL230:
 2097               	.L188:
1916:../../Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 2098               		.loc 1 1916 0
 2099 07c8 80E0      		ldi r24,0
 2100               	.LVL231:
 2101               	.L187:
 2102               	/* epilogue start */
1923:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2103               		.loc 1 1923 0
 2104 07ca DF91      		pop r29
 2105 07cc CF91      		pop r28
 2106 07ce 1F91      		pop r17
 2107 07d0 0F91      		pop r16
 2108 07d2 0895      		ret
 2109               		.cfi_endproc
 2110               	.LFE14:
 2112               	.global	uxQueueMessagesWaiting
 2114               	uxQueueMessagesWaiting:
 2115               	.LFB15:
1927:../../Source/queue.c **** UBaseType_t uxReturn;
 2116               		.loc 1 1927 0
 2117               		.cfi_startproc
 2118               	.LVL232:
 2119               	/* prologue: function */
 2120               	/* frame size = 0 */
 2121               	/* stack size = 0 */
 2122               	.L__stack_usage = 0
1932:../../Source/queue.c **** 	{
 2123               		.loc 1 1932 0
 2124               	/* #APP */
 2125               	 ;  1932 "../../Source/queue.c" 1
 2126 07d4 0FB6      		in __tmp_reg__, __SREG__
 2127 07d6 F894      		cli
 2128 07d8 0F92      		push __tmp_reg__
 2129               		
 2130               	 ;  0 "" 2
1934:../../Source/queue.c **** 	}
 2131               		.loc 1 1934 0
 2132               	/* #NOAPP */
 2133 07da FC01      		movw r30,r24
 2134 07dc 828D      		ldd r24,Z+26
 2135               	.LVL233:
1936:../../Source/queue.c **** 
 2136               		.loc 1 1936 0
 2137               	/* #APP */
 2138               	 ;  1936 "../../Source/queue.c" 1
 2139 07de 0F90      		pop __tmp_reg__
 2140 07e0 0FBE      		out __SREG__, __tmp_reg__
 2141               		
 2142               	 ;  0 "" 2
1939:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2143               		.loc 1 1939 0
 2144               	/* #NOAPP */
 2145 07e2 0895      		ret
 2146               		.cfi_endproc
 2147               	.LFE15:
 2149               	.global	uxQueueSpacesAvailable
 2151               	uxQueueSpacesAvailable:
 2152               	.LFB16:
1943:../../Source/queue.c **** UBaseType_t uxReturn;
 2153               		.loc 1 1943 0
 2154               		.cfi_startproc
 2155               	.LVL234:
 2156               	/* prologue: function */
 2157               	/* frame size = 0 */
 2158               	/* stack size = 0 */
 2159               	.L__stack_usage = 0
1949:../../Source/queue.c **** 	{
 2160               		.loc 1 1949 0
 2161               	/* #APP */
 2162               	 ;  1949 "../../Source/queue.c" 1
 2163 07e4 0FB6      		in __tmp_reg__, __SREG__
 2164 07e6 F894      		cli
 2165 07e8 0F92      		push __tmp_reg__
 2166               		
 2167               	 ;  0 "" 2
1951:../../Source/queue.c **** 	}
 2168               		.loc 1 1951 0
 2169               	/* #NOAPP */
 2170 07ea FC01      		movw r30,r24
 2171 07ec 228D      		ldd r18,Z+26
 2172 07ee 838D      		ldd r24,Z+27
 2173               	.LVL235:
 2174 07f0 821B      		sub r24,r18
 2175               	.LVL236:
1953:../../Source/queue.c **** 
 2176               		.loc 1 1953 0
 2177               	/* #APP */
 2178               	 ;  1953 "../../Source/queue.c" 1
 2179 07f2 0F90      		pop __tmp_reg__
 2180 07f4 0FBE      		out __SREG__, __tmp_reg__
 2181               		
 2182               	 ;  0 "" 2
1956:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2183               		.loc 1 1956 0
 2184               	/* #NOAPP */
 2185 07f6 0895      		ret
 2186               		.cfi_endproc
 2187               	.LFE16:
 2189               	.global	uxQueueMessagesWaitingFromISR
 2191               	uxQueueMessagesWaitingFromISR:
 2192               	.LFB17:
1960:../../Source/queue.c **** UBaseType_t uxReturn;
 2193               		.loc 1 1960 0
 2194               		.cfi_startproc
 2195               	.LVL237:
 2196               	/* prologue: function */
 2197               	/* frame size = 0 */
 2198               	/* stack size = 0 */
 2199               	.L__stack_usage = 0
1965:../../Source/queue.c **** 
 2200               		.loc 1 1965 0
 2201 07f8 FC01      		movw r30,r24
 2202 07fa 828D      		ldd r24,Z+26
 2203               	.LVL238:
1968:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2204               		.loc 1 1968 0
 2205 07fc 0895      		ret
 2206               		.cfi_endproc
 2207               	.LFE17:
 2209               	.global	vQueueDelete
 2211               	vQueueDelete:
 2212               	.LFB18:
1972:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2213               		.loc 1 1972 0
 2214               		.cfi_startproc
 2215               	.LVL239:
 2216               	/* prologue: function */
 2217               	/* frame size = 0 */
 2218               	/* stack size = 0 */
 2219               	.L__stack_usage = 0
1988:../../Source/queue.c **** 	}
 2220               		.loc 1 1988 0
 2221 07fe 0C94 0000 		jmp vPortFree
 2222               	.LVL240:
 2223               		.cfi_endproc
 2224               	.LFE18:
 2226               	.global	xQueueIsQueueEmptyFromISR
 2228               	xQueueIsQueueEmptyFromISR:
 2229               	.LFB23:
2309:../../Source/queue.c **** BaseType_t xReturn;
 2230               		.loc 1 2309 0
 2231               		.cfi_startproc
 2232               	.LVL241:
 2233               	/* prologue: function */
 2234               	/* frame size = 0 */
 2235               	/* stack size = 0 */
 2236               	.L__stack_usage = 0
2314:../../Source/queue.c **** 	{
 2237               		.loc 1 2314 0
 2238 0802 FC01      		movw r30,r24
 2239 0804 928D      		ldd r25,Z+26
 2240               	.LVL242:
2323:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2241               		.loc 1 2323 0
 2242 0806 81E0      		ldi r24,lo8(1)
 2243               	.LVL243:
 2244 0808 9111      		cpse r25,__zero_reg__
 2245 080a 80E0      		ldi r24,0
 2246               	.L194:
2324:../../Source/queue.c **** /*-----------------------------------------------------------*/
 2247               		.loc 1 2324 0
 2248 080c 0895      		ret
 2249               		.cfi_endproc
 2250               	.LFE23:
 2252               	.global	xQueueIsQueueFullFromISR
 2254               	xQueueIsQueueFullFromISR:
 2255               	.LFB25:
2343:../../Source/queue.c **** 
2344:../../Source/queue.c **** 	return xReturn;
2345:../../Source/queue.c **** }
2346:../../Source/queue.c **** /*-----------------------------------------------------------*/
2347:../../Source/queue.c **** 
2348:../../Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2349:../../Source/queue.c **** {
 2256               		.loc 1 2349 0
 2257               		.cfi_startproc
 2258               	.LVL244:
 2259               	/* prologue: function */
 2260               	/* frame size = 0 */
 2261               	/* stack size = 0 */
 2262               	.L__stack_usage = 0
 2263 080e FC01      		movw r30,r24
 2264               	.LVL245:
2350:../../Source/queue.c **** BaseType_t xReturn;
2351:../../Source/queue.c **** Queue_t * const pxQueue = xQueue;
2352:../../Source/queue.c **** 
2353:../../Source/queue.c **** 	configASSERT( pxQueue );
2354:../../Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2265               		.loc 1 2354 0
 2266 0810 928D      		ldd r25,Z+26
 2267               	.LVL246:
2355:../../Source/queue.c **** 	{
2356:../../Source/queue.c **** 		xReturn = pdTRUE;
2357:../../Source/queue.c **** 	}
2358:../../Source/queue.c **** 	else
2359:../../Source/queue.c **** 	{
2360:../../Source/queue.c **** 		xReturn = pdFALSE;
2361:../../Source/queue.c **** 	}
2362:../../Source/queue.c **** 
2363:../../Source/queue.c **** 	return xReturn;
 2268               		.loc 1 2363 0
 2269 0812 81E0      		ldi r24,lo8(1)
 2270               	.LVL247:
 2271 0814 238D      		ldd r18,Z+27
 2272 0816 2913      		cpse r18,r25
 2273 0818 80E0      		ldi r24,0
 2274               	.L199:
2364:../../Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2275               		.loc 1 2364 0
 2276 081a 0895      		ret
 2277               		.cfi_endproc
 2278               	.LFE25:
 2280               	.global	xQueueCRSend
 2282               	xQueueCRSend:
 2283               	.LFB26:
2365:../../Source/queue.c **** /*-----------------------------------------------------------*/
2366:../../Source/queue.c **** 
2367:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2368:../../Source/queue.c **** 
2369:../../Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2370:../../Source/queue.c **** 	{
 2284               		.loc 1 2370 0
 2285               		.cfi_startproc
 2286               	.LVL248:
 2287 081c CF93      		push r28
 2288               	.LCFI72:
 2289               		.cfi_def_cfa_offset 4
 2290               		.cfi_offset 28, -3
 2291 081e DF93      		push r29
 2292               	.LCFI73:
 2293               		.cfi_def_cfa_offset 5
 2294               		.cfi_offset 29, -4
 2295               	/* prologue: function */
 2296               	/* frame size = 0 */
 2297               	/* stack size = 2 */
 2298               	.L__stack_usage = 2
 2299 0820 EC01      		movw r28,r24
 2300 0822 CA01      		movw r24,r20
 2301               	.LVL249:
2371:../../Source/queue.c **** 	BaseType_t xReturn;
2372:../../Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2373:../../Source/queue.c **** 
2374:../../Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2375:../../Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2376:../../Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2377:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2302               		.loc 1 2377 0
 2303               	/* #APP */
 2304               	 ;  2377 "../../Source/queue.c" 1
 2305 0824 F894      		cli
 2306               	 ;  0 "" 2
 2307               	.LVL250:
 2308               	/* #NOAPP */
 2309               	.LBB22:
 2310               	.LBB23:
2331:../../Source/queue.c **** 	{
 2311               		.loc 1 2331 0
 2312               	/* #APP */
 2313               	 ;  2331 "../../Source/queue.c" 1
 2314 0826 0FB6      		in __tmp_reg__, __SREG__
 2315 0828 F894      		cli
 2316 082a 0F92      		push __tmp_reg__
 2317               		
 2318               	 ;  0 "" 2
2333:../../Source/queue.c **** 		{
 2319               		.loc 1 2333 0
 2320               	/* #NOAPP */
 2321 082c 3A8D      		ldd r19,Y+26
 2322 082e 2B8D      		ldd r18,Y+27
 2323               	.LVL251:
2342:../../Source/queue.c **** 
 2324               		.loc 1 2342 0
 2325               	/* #APP */
 2326               	 ;  2342 "../../Source/queue.c" 1
 2327 0830 0F90      		pop __tmp_reg__
 2328 0832 0FBE      		out __SREG__, __tmp_reg__
 2329               		
 2330               	 ;  0 "" 2
 2331               	.LVL252:
 2332               	/* #NOAPP */
 2333               	.LBE23:
 2334               	.LBE22:
2378:../../Source/queue.c **** 		{
2379:../../Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 2335               		.loc 1 2379 0
 2336 0834 3213      		cpse r19,r18
 2337 0836 00C0      		rjmp .L201
2380:../../Source/queue.c **** 			{
2381:../../Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2382:../../Source/queue.c **** 				posting? */
2383:../../Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2338               		.loc 1 2383 0
 2339 0838 0097      		sbiw r24,0
 2340 083a 01F0      		breq .L202
2384:../../Source/queue.c **** 				{
2385:../../Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2386:../../Source/queue.c **** 					return indicating that we need to block. */
2387:../../Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 2341               		.loc 1 2387 0
 2342 083c BE01      		movw r22,r28
 2343               	.LVL253:
 2344 083e 685F      		subi r22,-8
 2345 0840 7F4F      		sbci r23,-1
 2346 0842 0E94 0000 		call vCoRoutineAddToDelayedList
 2347               	.LVL254:
2388:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2348               		.loc 1 2388 0
 2349               	/* #APP */
 2350               	 ;  2388 "../../Source/queue.c" 1
 2351 0846 7894      		sei
 2352               	 ;  0 "" 2
2389:../../Source/queue.c **** 					return errQUEUE_BLOCKED;
 2353               		.loc 1 2389 0
 2354               	/* #NOAPP */
 2355 0848 8CEF      		ldi r24,lo8(-4)
 2356 084a 00C0      		rjmp .L203
 2357               	.LVL255:
 2358               	.L202:
2390:../../Source/queue.c **** 				}
2391:../../Source/queue.c **** 				else
2392:../../Source/queue.c **** 				{
2393:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2359               		.loc 1 2393 0
 2360               	/* #APP */
 2361               	 ;  2393 "../../Source/queue.c" 1
 2362 084c 7894      		sei
 2363               	 ;  0 "" 2
2394:../../Source/queue.c **** 					return errQUEUE_FULL;
 2364               		.loc 1 2394 0
 2365               	/* #NOAPP */
 2366 084e 80E0      		ldi r24,0
 2367 0850 00C0      		rjmp .L203
 2368               	.L201:
2395:../../Source/queue.c **** 				}
2396:../../Source/queue.c **** 			}
2397:../../Source/queue.c **** 		}
2398:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2369               		.loc 1 2398 0
 2370               	/* #APP */
 2371               	 ;  2398 "../../Source/queue.c" 1
 2372 0852 7894      		sei
 2373               	 ;  0 "" 2
2399:../../Source/queue.c **** 
2400:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2374               		.loc 1 2400 0
 2375               	 ;  2400 "../../Source/queue.c" 1
 2376 0854 F894      		cli
 2377               	 ;  0 "" 2
2401:../../Source/queue.c **** 		{
2402:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2378               		.loc 1 2402 0
 2379               	/* #NOAPP */
 2380 0856 9A8D      		ldd r25,Y+26
 2381 0858 8B8D      		ldd r24,Y+27
 2382 085a 9817      		cp r25,r24
 2383 085c 00F4      		brsh .L207
2403:../../Source/queue.c **** 			{
2404:../../Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2405:../../Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2384               		.loc 1 2405 0
 2385 085e 40E0      		ldi r20,0
 2386               	.LVL256:
 2387 0860 CE01      		movw r24,r28
 2388 0862 0E94 0000 		call prvCopyDataToQueue
 2389               	.LVL257:
2406:../../Source/queue.c **** 				xReturn = pdPASS;
2407:../../Source/queue.c **** 
2408:../../Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2409:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2390               		.loc 1 2409 0
 2391 0866 8989      		ldd r24,Y+17
 2392 0868 8111      		cpse r24,__zero_reg__
 2393 086a 00C0      		rjmp .L205
 2394               	.L206:
2406:../../Source/queue.c **** 				xReturn = pdPASS;
 2395               		.loc 1 2406 0
 2396 086c 81E0      		ldi r24,lo8(1)
 2397 086e 00C0      		rjmp .L204
 2398               	.L205:
2410:../../Source/queue.c **** 				{
2411:../../Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2412:../../Source/queue.c **** 					into the ready list as we are within a critical section.
2413:../../Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2414:../../Source/queue.c **** 					the event were caused from within an interrupt. */
2415:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2399               		.loc 1 2415 0
 2400 0870 CE01      		movw r24,r28
 2401 0872 4196      		adiw r24,17
 2402 0874 0E94 0000 		call xCoRoutineRemoveFromEventList
 2403               	.LVL258:
 2404 0878 8823      		tst r24
 2405 087a 01F0      		breq .L206
2416:../../Source/queue.c **** 					{
2417:../../Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2418:../../Source/queue.c **** 						that a yield might be appropriate. */
2419:../../Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2406               		.loc 1 2419 0
 2407 087c 8BEF      		ldi r24,lo8(-5)
 2408 087e 00C0      		rjmp .L204
 2409               	.LVL259:
 2410               	.L207:
2420:../../Source/queue.c **** 					}
2421:../../Source/queue.c **** 					else
2422:../../Source/queue.c **** 					{
2423:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2424:../../Source/queue.c **** 					}
2425:../../Source/queue.c **** 				}
2426:../../Source/queue.c **** 				else
2427:../../Source/queue.c **** 				{
2428:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2429:../../Source/queue.c **** 				}
2430:../../Source/queue.c **** 			}
2431:../../Source/queue.c **** 			else
2432:../../Source/queue.c **** 			{
2433:../../Source/queue.c **** 				xReturn = errQUEUE_FULL;
 2411               		.loc 1 2433 0
 2412 0880 80E0      		ldi r24,0
 2413               	.LVL260:
 2414               	.L204:
2434:../../Source/queue.c **** 			}
2435:../../Source/queue.c **** 		}
2436:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2415               		.loc 1 2436 0
 2416               	/* #APP */
 2417               	 ;  2436 "../../Source/queue.c" 1
 2418 0882 7894      		sei
 2419               	 ;  0 "" 2
 2420               	.LVL261:
 2421               	/* #NOAPP */
 2422               	.L203:
 2423               	/* epilogue start */
2437:../../Source/queue.c **** 
2438:../../Source/queue.c **** 		return xReturn;
2439:../../Source/queue.c **** 	}
 2424               		.loc 1 2439 0
 2425 0884 DF91      		pop r29
 2426 0886 CF91      		pop r28
 2427               	.LVL262:
 2428 0888 0895      		ret
 2429               		.cfi_endproc
 2430               	.LFE26:
 2432               	.global	xQueueCRReceive
 2434               	xQueueCRReceive:
 2435               	.LFB27:
2440:../../Source/queue.c **** 
2441:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2442:../../Source/queue.c **** /*-----------------------------------------------------------*/
2443:../../Source/queue.c **** 
2444:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2445:../../Source/queue.c **** 
2446:../../Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2447:../../Source/queue.c **** 	{
 2436               		.loc 1 2447 0
 2437               		.cfi_startproc
 2438               	.LVL263:
 2439 088a CF93      		push r28
 2440               	.LCFI74:
 2441               		.cfi_def_cfa_offset 4
 2442               		.cfi_offset 28, -3
 2443 088c DF93      		push r29
 2444               	.LCFI75:
 2445               		.cfi_def_cfa_offset 5
 2446               		.cfi_offset 29, -4
 2447               	/* prologue: function */
 2448               	/* frame size = 0 */
 2449               	/* stack size = 2 */
 2450               	.L__stack_usage = 2
 2451 088e EC01      		movw r28,r24
 2452 0890 FB01      		movw r30,r22
 2453               	.LVL264:
2448:../../Source/queue.c **** 	BaseType_t xReturn;
2449:../../Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2450:../../Source/queue.c **** 
2451:../../Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2452:../../Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2453:../../Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2454:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2454               		.loc 1 2454 0
 2455               	/* #APP */
 2456               	 ;  2454 "../../Source/queue.c" 1
 2457 0892 F894      		cli
 2458               	 ;  0 "" 2
2455:../../Source/queue.c **** 		{
2456:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2459               		.loc 1 2456 0
 2460               	/* #NOAPP */
 2461 0894 8A8D      		ldd r24,Y+26
 2462               	.LVL265:
 2463 0896 8111      		cpse r24,__zero_reg__
 2464 0898 00C0      		rjmp .L212
2457:../../Source/queue.c **** 			{
2458:../../Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2459:../../Source/queue.c **** 				leave with nothing? */
2460:../../Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2465               		.loc 1 2460 0
 2466 089a 4115      		cp r20,__zero_reg__
 2467 089c 5105      		cpc r21,__zero_reg__
 2468 089e 01F0      		breq .L213
2461:../../Source/queue.c **** 				{
2462:../../Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2463:../../Source/queue.c **** 					indicating that we need to block. */
2464:../../Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 2469               		.loc 1 2464 0
 2470 08a0 BE01      		movw r22,r28
 2471               	.LVL266:
 2472 08a2 6F5E      		subi r22,-17
 2473 08a4 7F4F      		sbci r23,-1
 2474 08a6 CA01      		movw r24,r20
 2475 08a8 0E94 0000 		call vCoRoutineAddToDelayedList
 2476               	.LVL267:
2465:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2477               		.loc 1 2465 0
 2478               	/* #APP */
 2479               	 ;  2465 "../../Source/queue.c" 1
 2480 08ac 7894      		sei
 2481               	 ;  0 "" 2
2466:../../Source/queue.c **** 					return errQUEUE_BLOCKED;
 2482               		.loc 1 2466 0
 2483               	/* #NOAPP */
 2484 08ae 8CEF      		ldi r24,lo8(-4)
 2485 08b0 00C0      		rjmp .L214
 2486               	.LVL268:
 2487               	.L213:
2467:../../Source/queue.c **** 				}
2468:../../Source/queue.c **** 				else
2469:../../Source/queue.c **** 				{
2470:../../Source/queue.c **** 					portENABLE_INTERRUPTS();
 2488               		.loc 1 2470 0
 2489               	/* #APP */
 2490               	 ;  2470 "../../Source/queue.c" 1
 2491 08b2 7894      		sei
 2492               	 ;  0 "" 2
2471:../../Source/queue.c **** 					return errQUEUE_FULL;
 2493               		.loc 1 2471 0
 2494               	/* #NOAPP */
 2495 08b4 80E0      		ldi r24,0
 2496 08b6 00C0      		rjmp .L214
 2497               	.L212:
2472:../../Source/queue.c **** 				}
2473:../../Source/queue.c **** 			}
2474:../../Source/queue.c **** 			else
2475:../../Source/queue.c **** 			{
2476:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2477:../../Source/queue.c **** 			}
2478:../../Source/queue.c **** 		}
2479:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2498               		.loc 1 2479 0
 2499               	/* #APP */
 2500               	 ;  2479 "../../Source/queue.c" 1
 2501 08b8 7894      		sei
 2502               	 ;  0 "" 2
2480:../../Source/queue.c **** 
2481:../../Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2503               		.loc 1 2481 0
 2504               	 ;  2481 "../../Source/queue.c" 1
 2505 08ba F894      		cli
 2506               	 ;  0 "" 2
2482:../../Source/queue.c **** 		{
2483:../../Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2507               		.loc 1 2483 0
 2508               	/* #NOAPP */
 2509 08bc 8A8D      		ldd r24,Y+26
 2510 08be 8823      		tst r24
 2511 08c0 01F0      		breq .L219
2484:../../Source/queue.c **** 			{
2485:../../Source/queue.c **** 				/* Data is available from the queue. */
2486:../../Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 2512               		.loc 1 2486 0
 2513 08c2 4C8D      		ldd r20,Y+28
 2514               	.LVL269:
 2515 08c4 50E0      		ldi r21,0
 2516 08c6 2E81      		ldd r18,Y+6
 2517 08c8 3F81      		ldd r19,Y+7
 2518 08ca 240F      		add r18,r20
 2519 08cc 351F      		adc r19,r21
 2520 08ce 3F83      		std Y+7,r19
 2521 08d0 2E83      		std Y+6,r18
2487:../../Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 2522               		.loc 1 2487 0
 2523 08d2 8C81      		ldd r24,Y+4
 2524 08d4 9D81      		ldd r25,Y+5
 2525 08d6 2817      		cp r18,r24
 2526 08d8 3907      		cpc r19,r25
 2527 08da 00F0      		brlo .L216
2488:../../Source/queue.c **** 				{
2489:../../Source/queue.c **** 					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2528               		.loc 1 2489 0
 2529 08dc 8881      		ld r24,Y
 2530 08de 9981      		ldd r25,Y+1
 2531 08e0 9F83      		std Y+7,r25
 2532 08e2 8E83      		std Y+6,r24
 2533               	.L216:
2490:../../Source/queue.c **** 				}
2491:../../Source/queue.c **** 				else
2492:../../Source/queue.c **** 				{
2493:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2494:../../Source/queue.c **** 				}
2495:../../Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 2534               		.loc 1 2495 0
 2535 08e4 9A8D      		ldd r25,Y+26
 2536 08e6 9150      		subi r25,lo8(-(-1))
 2537 08e8 9A8F      		std Y+26,r25
2496:../../Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
 2538               		.loc 1 2496 0
 2539 08ea 6E81      		ldd r22,Y+6
 2540 08ec 7F81      		ldd r23,Y+7
 2541               	.LVL270:
 2542 08ee CF01      		movw r24,r30
 2543 08f0 0E94 0000 		call memcpy
 2544               	.LVL271:
2497:../../Source/queue.c **** 
2498:../../Source/queue.c **** 				xReturn = pdPASS;
2499:../../Source/queue.c **** 
2500:../../Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2501:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2545               		.loc 1 2501 0
 2546 08f4 8885      		ldd r24,Y+8
 2547 08f6 8111      		cpse r24,__zero_reg__
 2548 08f8 00C0      		rjmp .L217
 2549               	.L218:
2498:../../Source/queue.c **** 
 2550               		.loc 1 2498 0
 2551 08fa 81E0      		ldi r24,lo8(1)
 2552 08fc 00C0      		rjmp .L215
 2553               	.L217:
2502:../../Source/queue.c **** 				{
2503:../../Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2504:../../Source/queue.c **** 					into the ready list as we are within a critical section.
2505:../../Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2506:../../Source/queue.c **** 					the event were caused from within an interrupt. */
2507:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2554               		.loc 1 2507 0
 2555 08fe CE01      		movw r24,r28
 2556 0900 0896      		adiw r24,8
 2557 0902 0E94 0000 		call xCoRoutineRemoveFromEventList
 2558               	.LVL272:
 2559 0906 8823      		tst r24
 2560 0908 01F0      		breq .L218
2508:../../Source/queue.c **** 					{
2509:../../Source/queue.c **** 						xReturn = errQUEUE_YIELD;
 2561               		.loc 1 2509 0
 2562 090a 8BEF      		ldi r24,lo8(-5)
 2563 090c 00C0      		rjmp .L215
 2564               	.LVL273:
 2565               	.L219:
2510:../../Source/queue.c **** 					}
2511:../../Source/queue.c **** 					else
2512:../../Source/queue.c **** 					{
2513:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2514:../../Source/queue.c **** 					}
2515:../../Source/queue.c **** 				}
2516:../../Source/queue.c **** 				else
2517:../../Source/queue.c **** 				{
2518:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2519:../../Source/queue.c **** 				}
2520:../../Source/queue.c **** 			}
2521:../../Source/queue.c **** 			else
2522:../../Source/queue.c **** 			{
2523:../../Source/queue.c **** 				xReturn = pdFAIL;
 2566               		.loc 1 2523 0
 2567 090e 80E0      		ldi r24,0
 2568               	.LVL274:
 2569               	.L215:
2524:../../Source/queue.c **** 			}
2525:../../Source/queue.c **** 		}
2526:../../Source/queue.c **** 		portENABLE_INTERRUPTS();
 2570               		.loc 1 2526 0
 2571               	/* #APP */
 2572               	 ;  2526 "../../Source/queue.c" 1
 2573 0910 7894      		sei
 2574               	 ;  0 "" 2
 2575               	.LVL275:
 2576               	/* #NOAPP */
 2577               	.L214:
 2578               	/* epilogue start */
2527:../../Source/queue.c **** 
2528:../../Source/queue.c **** 		return xReturn;
2529:../../Source/queue.c **** 	}
 2579               		.loc 1 2529 0
 2580 0912 DF91      		pop r29
 2581 0914 CF91      		pop r28
 2582               	.LVL276:
 2583 0916 0895      		ret
 2584               		.cfi_endproc
 2585               	.LFE27:
 2587               	.global	xQueueCRSendFromISR
 2589               	xQueueCRSendFromISR:
 2590               	.LFB28:
2530:../../Source/queue.c **** 
2531:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2532:../../Source/queue.c **** /*-----------------------------------------------------------*/
2533:../../Source/queue.c **** 
2534:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2535:../../Source/queue.c **** 
2536:../../Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2537:../../Source/queue.c **** 	{
 2591               		.loc 1 2537 0
 2592               		.cfi_startproc
 2593               	.LVL277:
 2594 0918 0F93      		push r16
 2595               	.LCFI76:
 2596               		.cfi_def_cfa_offset 4
 2597               		.cfi_offset 16, -3
 2598 091a 1F93      		push r17
 2599               	.LCFI77:
 2600               		.cfi_def_cfa_offset 5
 2601               		.cfi_offset 17, -4
 2602 091c CF93      		push r28
 2603               	.LCFI78:
 2604               		.cfi_def_cfa_offset 6
 2605               		.cfi_offset 28, -5
 2606               	/* prologue: function */
 2607               	/* frame size = 0 */
 2608               	/* stack size = 3 */
 2609               	.L__stack_usage = 3
 2610 091e 8C01      		movw r16,r24
 2611 0920 C42F      		mov r28,r20
 2612               	.LVL278:
2538:../../Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2539:../../Source/queue.c **** 
2540:../../Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2541:../../Source/queue.c **** 		exit without doing anything. */
2542:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 2613               		.loc 1 2542 0
 2614 0922 FC01      		movw r30,r24
 2615 0924 928D      		ldd r25,Z+26
 2616 0926 838D      		ldd r24,Z+27
 2617               	.LVL279:
 2618 0928 9817      		cp r25,r24
 2619 092a 00F0      		brlo .L224
 2620               	.LVL280:
 2621               	.L226:
 2622 092c 4C2F      		mov r20,r28
 2623 092e 00C0      		rjmp .L225
 2624               	.LVL281:
 2625               	.L224:
2543:../../Source/queue.c **** 		{
2544:../../Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 2626               		.loc 1 2544 0
 2627 0930 40E0      		ldi r20,0
 2628               	.LVL282:
 2629 0932 C801      		movw r24,r16
 2630 0934 0E94 0000 		call prvCopyDataToQueue
 2631               	.LVL283:
2545:../../Source/queue.c **** 
2546:../../Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2547:../../Source/queue.c **** 			co-routine has not already been woken. */
2548:../../Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
 2632               		.loc 1 2548 0
 2633 0938 C111      		cpse r28,__zero_reg__
 2634 093a 00C0      		rjmp .L226
2549:../../Source/queue.c **** 			{
2550:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2635               		.loc 1 2550 0
 2636 093c F801      		movw r30,r16
 2637 093e 8189      		ldd r24,Z+17
 2638 0940 8823      		tst r24
 2639 0942 01F0      		breq .L228
2551:../../Source/queue.c **** 				{
2552:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2640               		.loc 1 2552 0
 2641 0944 C801      		movw r24,r16
 2642 0946 4196      		adiw r24,17
 2643 0948 0E94 0000 		call xCoRoutineRemoveFromEventList
 2644               	.LVL284:
2553:../../Source/queue.c **** 					{
2554:../../Source/queue.c **** 						return pdTRUE;
 2645               		.loc 1 2554 0
 2646 094c 41E0      		ldi r20,lo8(1)
 2647 094e 8111      		cpse r24,__zero_reg__
 2648 0950 00C0      		rjmp .L225
 2649               	.L228:
 2650 0952 40E0      		ldi r20,0
 2651               	.L225:
2555:../../Source/queue.c **** 					}
2556:../../Source/queue.c **** 					else
2557:../../Source/queue.c **** 					{
2558:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2559:../../Source/queue.c **** 					}
2560:../../Source/queue.c **** 				}
2561:../../Source/queue.c **** 				else
2562:../../Source/queue.c **** 				{
2563:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2564:../../Source/queue.c **** 				}
2565:../../Source/queue.c **** 			}
2566:../../Source/queue.c **** 			else
2567:../../Source/queue.c **** 			{
2568:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2569:../../Source/queue.c **** 			}
2570:../../Source/queue.c **** 		}
2571:../../Source/queue.c **** 		else
2572:../../Source/queue.c **** 		{
2573:../../Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2574:../../Source/queue.c **** 		}
2575:../../Source/queue.c **** 
2576:../../Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2577:../../Source/queue.c **** 	}
 2652               		.loc 1 2577 0
 2653 0954 842F      		mov r24,r20
 2654               	/* epilogue start */
 2655 0956 CF91      		pop r28
 2656               	.LVL285:
 2657 0958 1F91      		pop r17
 2658 095a 0F91      		pop r16
 2659               	.LVL286:
 2660 095c 0895      		ret
 2661               		.cfi_endproc
 2662               	.LFE28:
 2664               	.global	xQueueCRReceiveFromISR
 2666               	xQueueCRReceiveFromISR:
 2667               	.LFB29:
2578:../../Source/queue.c **** 
2579:../../Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2580:../../Source/queue.c **** /*-----------------------------------------------------------*/
2581:../../Source/queue.c **** 
2582:../../Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2583:../../Source/queue.c **** 
2584:../../Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2585:../../Source/queue.c **** 	{
 2668               		.loc 1 2585 0
 2669               		.cfi_startproc
 2670               	.LVL287:
 2671 095e 0F93      		push r16
 2672               	.LCFI79:
 2673               		.cfi_def_cfa_offset 4
 2674               		.cfi_offset 16, -3
 2675 0960 1F93      		push r17
 2676               	.LCFI80:
 2677               		.cfi_def_cfa_offset 5
 2678               		.cfi_offset 17, -4
 2679 0962 CF93      		push r28
 2680               	.LCFI81:
 2681               		.cfi_def_cfa_offset 6
 2682               		.cfi_offset 28, -5
 2683 0964 DF93      		push r29
 2684               	.LCFI82:
 2685               		.cfi_def_cfa_offset 7
 2686               		.cfi_offset 29, -6
 2687               	/* prologue: function */
 2688               	/* frame size = 0 */
 2689               	/* stack size = 4 */
 2690               	.L__stack_usage = 4
 2691 0966 FC01      		movw r30,r24
 2692               	.LVL288:
2586:../../Source/queue.c **** 	BaseType_t xReturn;
2587:../../Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2588:../../Source/queue.c **** 
2589:../../Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2590:../../Source/queue.c **** 		not then just leave without doing anything. */
2591:../../Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2693               		.loc 1 2591 0
 2694 0968 828D      		ldd r24,Z+26
 2695               	.LVL289:
 2696 096a 8823      		tst r24
 2697 096c 01F0      		breq .L234
2592:../../Source/queue.c **** 		{
2593:../../Source/queue.c **** 			/* Copy the data from the queue. */
2594:../../Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 2698               		.loc 1 2594 0
 2699 096e 248D      		ldd r18,Z+28
 2700 0970 30E0      		ldi r19,0
 2701 0972 A681      		ldd r26,Z+6
 2702 0974 B781      		ldd r27,Z+7
 2703 0976 A20F      		add r26,r18
 2704 0978 B31F      		adc r27,r19
 2705 097a B783      		std Z+7,r27
 2706 097c A683      		std Z+6,r26
2595:../../Source/queue.c **** 			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 2707               		.loc 1 2595 0
 2708 097e 8481      		ldd r24,Z+4
 2709 0980 9581      		ldd r25,Z+5
 2710 0982 A817      		cp r26,r24
 2711 0984 B907      		cpc r27,r25
 2712 0986 00F0      		brlo .L231
2596:../../Source/queue.c **** 			{
2597:../../Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2713               		.loc 1 2597 0
 2714 0988 8081      		ld r24,Z
 2715 098a 9181      		ldd r25,Z+1
 2716 098c 9783      		std Z+7,r25
 2717 098e 8683      		std Z+6,r24
 2718               	.L231:
 2719 0990 8A01      		movw r16,r20
 2720 0992 CB01      		movw r24,r22
 2721 0994 EF01      		movw r28,r30
2598:../../Source/queue.c **** 			}
2599:../../Source/queue.c **** 			else
2600:../../Source/queue.c **** 			{
2601:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2602:../../Source/queue.c **** 			}
2603:../../Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 2722               		.loc 1 2603 0
 2723 0996 428D      		ldd r20,Z+26
 2724               	.LVL290:
 2725 0998 4150      		subi r20,lo8(-(-1))
 2726 099a 428F      		std Z+26,r20
2604:../../Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQu
 2727               		.loc 1 2604 0
 2728 099c 6681      		ldd r22,Z+6
 2729 099e 7781      		ldd r23,Z+7
 2730               	.LVL291:
 2731 09a0 A901      		movw r20,r18
 2732 09a2 0E94 0000 		call memcpy
 2733               	.LVL292:
2605:../../Source/queue.c **** 
2606:../../Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
 2734               		.loc 1 2606 0
 2735 09a6 F801      		movw r30,r16
 2736 09a8 8081      		ld r24,Z
 2737 09aa 8823      		tst r24
 2738 09ac 01F0      		breq .L232
 2739               	.L233:
2607:../../Source/queue.c **** 			{
2608:../../Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2609:../../Source/queue.c **** 				{
2610:../../Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2611:../../Source/queue.c **** 					{
2612:../../Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2613:../../Source/queue.c **** 					}
2614:../../Source/queue.c **** 					else
2615:../../Source/queue.c **** 					{
2616:../../Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2617:../../Source/queue.c **** 					}
2618:../../Source/queue.c **** 				}
2619:../../Source/queue.c **** 				else
2620:../../Source/queue.c **** 				{
2621:../../Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2622:../../Source/queue.c **** 				}
2623:../../Source/queue.c **** 			}
2624:../../Source/queue.c **** 			else
2625:../../Source/queue.c **** 			{
2626:../../Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2627:../../Source/queue.c **** 			}
2628:../../Source/queue.c **** 
2629:../../Source/queue.c **** 			xReturn = pdPASS;
 2740               		.loc 1 2629 0
 2741 09ae 81E0      		ldi r24,lo8(1)
 2742 09b0 00C0      		rjmp .L230
 2743               	.L232:
2608:../../Source/queue.c **** 				{
 2744               		.loc 1 2608 0
 2745 09b2 8885      		ldd r24,Y+8
 2746 09b4 8823      		tst r24
 2747 09b6 01F0      		breq .L233
2610:../../Source/queue.c **** 					{
 2748               		.loc 1 2610 0
 2749 09b8 CE01      		movw r24,r28
 2750 09ba 0896      		adiw r24,8
 2751 09bc 0E94 0000 		call xCoRoutineRemoveFromEventList
 2752               	.LVL293:
 2753 09c0 8823      		tst r24
 2754 09c2 01F0      		breq .L233
2612:../../Source/queue.c **** 					}
 2755               		.loc 1 2612 0
 2756 09c4 81E0      		ldi r24,lo8(1)
 2757 09c6 F801      		movw r30,r16
 2758 09c8 8083      		st Z,r24
 2759 09ca 00C0      		rjmp .L230
 2760               	.LVL294:
 2761               	.L234:
2630:../../Source/queue.c **** 		}
2631:../../Source/queue.c **** 		else
2632:../../Source/queue.c **** 		{
2633:../../Source/queue.c **** 			xReturn = pdFAIL;
 2762               		.loc 1 2633 0
 2763 09cc 80E0      		ldi r24,0
 2764               	.LVL295:
 2765               	.L230:
 2766               	/* epilogue start */
2634:../../Source/queue.c **** 		}
2635:../../Source/queue.c **** 
2636:../../Source/queue.c **** 		return xReturn;
2637:../../Source/queue.c **** 	}
 2767               		.loc 1 2637 0
 2768 09ce DF91      		pop r29
 2769 09d0 CF91      		pop r28
 2770 09d2 1F91      		pop r17
 2771 09d4 0F91      		pop r16
 2772 09d6 0895      		ret
 2773               		.cfi_endproc
 2774               	.LFE29:
 2776               	.Letext0:
 2777               		.file 2 "/home/link/avr8-gnu-toolchain/lib/gcc/avr/5.4.0/include/stddef.h"
 2778               		.file 3 "/home/link/avr8-gnu-toolchain/avr/include/stdint.h"
 2779               		.file 4 "../../Source/include/../portable/GCC/ATMega323/portmacro.h"
 2780               		.file 5 "../../Source/include/list.h"
 2781               		.file 6 "../../Source/include/task.h"
 2782               		.file 7 "../../Source/include/queue.h"
 2783               		.file 8 "../../Source/include/portable.h"
 2784               		.file 9 "../../Source/include/croutine.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/ccVfIrX3.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccVfIrX3.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccVfIrX3.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccVfIrX3.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccVfIrX3.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccVfIrX3.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccVfIrX3.s:12     .text:0000000000000000 prvIsQueueEmpty
     /tmp/ccVfIrX3.s:55     .text:0000000000000016 prvCopyDataToQueue
     /tmp/ccVfIrX3.s:183    .text:00000000000000a6 prvCopyDataFromQueue
     /tmp/ccVfIrX3.s:231    .text:00000000000000da prvUnlockQueue
     /tmp/ccVfIrX3.s:378    .text:0000000000000156 xQueueGenericReset
     /tmp/ccVfIrX3.s:493    .text:00000000000001d4 xQueueGenericCreate
     /tmp/ccVfIrX3.s:594    .text:0000000000000224 xQueueGenericSend
     /tmp/ccVfIrX3.s:904    .text:0000000000000350 xQueueGenericSendFromISR
     /tmp/ccVfIrX3.s:1010   .text:00000000000003ae xQueueGiveFromISR
     /tmp/ccVfIrX3.s:1098   .text:00000000000003f4 xQueueReceive
     /tmp/ccVfIrX3.s:1389   .text:0000000000000518 xQueueSemaphoreTake
     /tmp/ccVfIrX3.s:1653   .text:0000000000000624 xQueuePeek
     /tmp/ccVfIrX3.s:1940   .text:0000000000000748 xQueueReceiveFromISR
     /tmp/ccVfIrX3.s:2050   .text:00000000000007a6 xQueuePeekFromISR
     /tmp/ccVfIrX3.s:2114   .text:00000000000007d4 uxQueueMessagesWaiting
     /tmp/ccVfIrX3.s:2151   .text:00000000000007e4 uxQueueSpacesAvailable
     /tmp/ccVfIrX3.s:2191   .text:00000000000007f8 uxQueueMessagesWaitingFromISR
     /tmp/ccVfIrX3.s:2211   .text:00000000000007fe vQueueDelete
     /tmp/ccVfIrX3.s:2228   .text:0000000000000802 xQueueIsQueueEmptyFromISR
     /tmp/ccVfIrX3.s:2254   .text:000000000000080e xQueueIsQueueFullFromISR
     /tmp/ccVfIrX3.s:2282   .text:000000000000081c xQueueCRSend
     /tmp/ccVfIrX3.s:2434   .text:000000000000088a xQueueCRReceive
     /tmp/ccVfIrX3.s:2589   .text:0000000000000918 xQueueCRSendFromISR
     /tmp/ccVfIrX3.s:2666   .text:000000000000095e xQueueCRReceiveFromISR

UNDEFINED SYMBOLS
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vPortYield
vListInitialise
pvPortMalloc
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortFree
vCoRoutineAddToDelayedList
xCoRoutineRemoveFromEventList
