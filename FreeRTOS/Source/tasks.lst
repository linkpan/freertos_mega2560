   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	prvResetNextTaskUnblockTime:
  13               	.LFB32:
  14               		.file 1 "../../Source/tasks.c"
   1:../../Source/tasks.c **** /*
   2:../../Source/tasks.c ****  * FreeRTOS Kernel V10.1.1
   3:../../Source/tasks.c ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../../Source/tasks.c ****  *
   5:../../Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../../Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../../Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:../../Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../../Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../../Source/tasks.c ****  * subject to the following conditions:
  11:../../Source/tasks.c ****  *
  12:../../Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../../Source/tasks.c ****  * copies or substantial portions of the Software.
  14:../../Source/tasks.c ****  *
  15:../../Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../../Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../../Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../../Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../../Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../../Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../../Source/tasks.c ****  *
  22:../../Source/tasks.c ****  * http://www.FreeRTOS.org
  23:../../Source/tasks.c ****  * http://aws.amazon.com/freertos
  24:../../Source/tasks.c ****  *
  25:../../Source/tasks.c ****  * 1 tab == 4 spaces!
  26:../../Source/tasks.c ****  */
  27:../../Source/tasks.c **** 
  28:../../Source/tasks.c **** /* Standard includes. */
  29:../../Source/tasks.c **** #include <stdlib.h>
  30:../../Source/tasks.c **** #include <string.h>
  31:../../Source/tasks.c **** 
  32:../../Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:../../Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:../../Source/tasks.c **** task.h is included from an application file. */
  35:../../Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:../../Source/tasks.c **** 
  37:../../Source/tasks.c **** /* FreeRTOS includes. */
  38:../../Source/tasks.c **** #include "FreeRTOS.h"
  39:../../Source/tasks.c **** #include "task.h"
  40:../../Source/tasks.c **** #include "timers.h"
  41:../../Source/tasks.c **** #include "stack_macros.h"
  42:../../Source/tasks.c **** 
  43:../../Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:../../Source/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:../../Source/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:../../Source/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:../../Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:../../Source/tasks.c **** 
  49:../../Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:../../Source/tasks.c **** functions but without including stdio.h here. */
  51:../../Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:../../Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:../../Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:../../Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:../../Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:../../Source/tasks.c **** 	#include <stdio.h>
  57:../../Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:../../Source/tasks.c **** 
  59:../../Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:../../Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:../../Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:../../Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:../../Source/tasks.c **** #else
  64:../../Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:../../Source/tasks.c **** #endif
  66:../../Source/tasks.c **** 
  67:../../Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:../../Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:../../Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:../../Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:../../Source/tasks.c **** 
  72:../../Source/tasks.c **** /*
  73:../../Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:../../Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:../../Source/tasks.c ****  */
  76:../../Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:../../Source/tasks.c **** 
  78:../../Source/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
  79:../../Source/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
  80:../../Source/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
  81:../../Source/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
  82:../../Source/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
  83:../../Source/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
  84:../../Source/tasks.c **** settings allow a task to be created using either statically or dynamically
  85:../../Source/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
  86:../../Source/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
  87:../../Source/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
  88:../../Source/tasks.c **** made to free the RAM that was allocated statically.
  89:../../Source/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
  90:../../Source/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
  91:../../Source/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
  92:../../Source/tasks.c **** a statically allocated stack and a dynamically allocated TCB.
  93:../../Source/tasks.c **** !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
  94:../../Source/tasks.c **** changed then the definition of StaticTask_t must also be updated. */
  95:../../Source/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( c
  96:../../Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  97:../../Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  98:../../Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  99:../../Source/tasks.c **** 
 100:../../Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
 101:../../Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
 102:../../Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
 103:../../Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
 104:../../Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
 105:../../Source/tasks.c **** #else
 106:../../Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
 107:../../Source/tasks.c **** #endif
 108:../../Source/tasks.c **** 
 109:../../Source/tasks.c **** /*
 110:../../Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 111:../../Source/tasks.c ****  */
 112:../../Source/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
 113:../../Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 114:../../Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 115:../../Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 116:../../Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 117:../../Source/tasks.c **** 
 118:../../Source/tasks.c **** /*
 119:../../Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 120:../../Source/tasks.c ****  * global, rather than file scope.
 121:../../Source/tasks.c ****  */
 122:../../Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 123:../../Source/tasks.c **** 	#define static
 124:../../Source/tasks.c **** #endif
 125:../../Source/tasks.c **** 
 126:../../Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 127:../../Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 128:../../Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 129:../../Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 130:../../Source/tasks.c **** #endif
 131:../../Source/tasks.c **** 
 132:../../Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 133:../../Source/tasks.c **** 
 134:../../Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 135:../../Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 136:../../Source/tasks.c **** 	microcontroller architecture. */
 137:../../Source/tasks.c **** 
 138:../../Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 139:../../Source/tasks.c **** 	state task. */
 140:../../Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 141:../../Source/tasks.c **** 	{																									\
 142:../../Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 143:../../Source/tasks.c **** 		{																								\
 144:../../Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 145:../../Source/tasks.c **** 		}																								\
 146:../../Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 147:../../Source/tasks.c **** 
 148:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 149:../../Source/tasks.c **** 
 150:../../Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 151:../../Source/tasks.c **** 	{																									\
 152:../../Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 153:../../Source/tasks.c **** 																										\
 154:../../Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 155:../../Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 156:../../Source/tasks.c **** 		{																								\
 157:../../Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 158:../../Source/tasks.c **** 			--uxTopPriority;																			\
 159:../../Source/tasks.c **** 		}																								\
 160:../../Source/tasks.c **** 																										\
 161:../../Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 162:../../Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 163:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 164:../../Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 165:../../Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 166:../../Source/tasks.c **** 
 167:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:../../Source/tasks.c **** 
 169:../../Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 170:../../Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 171:../../Source/tasks.c **** 	being used. */
 172:../../Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 173:../../Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 174:../../Source/tasks.c **** 
 175:../../Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 176:../../Source/tasks.c **** 
 177:../../Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 178:../../Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 179:../../Source/tasks.c **** 	architecture being used. */
 180:../../Source/tasks.c **** 
 181:../../Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 182:../../Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 183:../../Source/tasks.c **** 
 184:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 185:../../Source/tasks.c **** 
 186:../../Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 187:../../Source/tasks.c **** 	{																								\
 188:../../Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 189:../../Source/tasks.c **** 																									\
 190:../../Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 191:../../Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 192:../../Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 193:../../Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 194:../../Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 195:../../Source/tasks.c **** 
 196:../../Source/tasks.c **** 	/*-----------------------------------------------------------*/
 197:../../Source/tasks.c **** 
 198:../../Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 199:../../Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 200:../../Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 201:../../Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 202:../../Source/tasks.c **** 	{																									\
 203:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 204:../../Source/tasks.c **** 		{																								\
 205:../../Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 206:../../Source/tasks.c **** 		}																								\
 207:../../Source/tasks.c **** 	}
 208:../../Source/tasks.c **** 
 209:../../Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 210:../../Source/tasks.c **** 
 211:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 212:../../Source/tasks.c **** 
 213:../../Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 214:../../Source/tasks.c **** count overflows. */
 215:../../Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 216:../../Source/tasks.c **** {																									\
 217:../../Source/tasks.c **** 	List_t *pxTemp;																					\
 218:../../Source/tasks.c **** 																									\
 219:../../Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 220:../../Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 221:../../Source/tasks.c **** 																									\
 222:../../Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 223:../../Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 224:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 225:../../Source/tasks.c **** 	xNumOfOverflows++;																				\
 226:../../Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 227:../../Source/tasks.c **** }
 228:../../Source/tasks.c **** 
 229:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 230:../../Source/tasks.c **** 
 231:../../Source/tasks.c **** /*
 232:../../Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 233:../../Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 234:../../Source/tasks.c ****  */
 235:../../Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 236:../../Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 237:../../Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 238:../../Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 239:../../Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 240:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 241:../../Source/tasks.c **** 
 242:../../Source/tasks.c **** /*
 243:../../Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 244:../../Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 245:../../Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 246:../../Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 247:../../Source/tasks.c ****  */
 248:../../Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 249:../../Source/tasks.c **** 
 250:../../Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 251:../../Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 252:../../Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 253:../../Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 254:../../Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 255:../../Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 256:../../Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 257:../../Source/tasks.c **** to its original value when it is released. */
 258:../../Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 259:../../Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 260:../../Source/tasks.c **** #else
 261:../../Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 262:../../Source/tasks.c **** #endif
 263:../../Source/tasks.c **** 
 264:../../Source/tasks.c **** /*
 265:../../Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 266:../../Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 267:../../Source/tasks.c ****  * (the task's run time environment, including register values)
 268:../../Source/tasks.c ****  */
 269:../../Source/tasks.c **** typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel 
 270:../../Source/tasks.c **** {
 271:../../Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 272:../../Source/tasks.c **** 
 273:../../Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 274:../../Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 275:../../Source/tasks.c **** 	#endif
 276:../../Source/tasks.c **** 
 277:../../Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 278:../../Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 279:../../Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 280:../../Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 281:../../Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 282:../../Source/tasks.c **** 
 283:../../Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 284:../../Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 285:../../Source/tasks.c **** 	#endif
 286:../../Source/tasks.c **** 
 287:../../Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 288:../../Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 289:../../Source/tasks.c **** 	#endif
 290:../../Source/tasks.c **** 
 291:../../Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 292:../../Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 293:../../Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 294:../../Source/tasks.c **** 	#endif
 295:../../Source/tasks.c **** 
 296:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 297:../../Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 298:../../Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 299:../../Source/tasks.c **** 	#endif
 300:../../Source/tasks.c **** 
 301:../../Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 302:../../Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 303:../../Source/tasks.c **** 	#endif
 304:../../Source/tasks.c **** 
 305:../../Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 306:../../Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 307:../../Source/tasks.c **** 	#endif
 308:../../Source/tasks.c **** 
 309:../../Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 310:../../Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 311:../../Source/tasks.c **** 	#endif
 312:../../Source/tasks.c **** 
 313:../../Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 314:../../Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 315:../../Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 316:../../Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 317:../../Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 318:../../Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 319:../../Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 320:../../Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 321:../../Source/tasks.c **** 		struct	_reent xNewLib_reent;
 322:../../Source/tasks.c **** 	#endif
 323:../../Source/tasks.c **** 
 324:../../Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 325:../../Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 326:../../Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 327:../../Source/tasks.c **** 	#endif
 328:../../Source/tasks.c **** 
 329:../../Source/tasks.c **** 	/* See the comments above the definition of
 330:../../Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 331:../../Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 332:../../Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 333:../../Source/tasks.c **** 	#endif
 334:../../Source/tasks.c **** 
 335:../../Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 336:../../Source/tasks.c **** 		uint8_t ucDelayAborted;
 337:../../Source/tasks.c **** 	#endif
 338:../../Source/tasks.c **** 
 339:../../Source/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 340:../../Source/tasks.c **** 		int iTaskErrno;
 341:../../Source/tasks.c **** 	#endif
 342:../../Source/tasks.c **** 
 343:../../Source/tasks.c **** } tskTCB;
 344:../../Source/tasks.c **** 
 345:../../Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 346:../../Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 347:../../Source/tasks.c **** typedef tskTCB TCB_t;
 348:../../Source/tasks.c **** 
 349:../../Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 350:../../Source/tasks.c **** which static variables must be declared volatile. */
 351:../../Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 352:../../Source/tasks.c **** 
 353:../../Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 354:../../Source/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 355:../../Source/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 356:../../Source/tasks.c **** the static qualifier. */
 357:../../Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 358:../../Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 359:../../Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 360:../../Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 361:../../Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 362:../../Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 363:../../Source/tasks.c **** 
 364:../../Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 365:../../Source/tasks.c **** 
 366:../../Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 367:../../Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 368:../../Source/tasks.c **** 
 369:../../Source/tasks.c **** #endif
 370:../../Source/tasks.c **** 
 371:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 372:../../Source/tasks.c **** 
 373:../../Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 374:../../Source/tasks.c **** 
 375:../../Source/tasks.c **** #endif
 376:../../Source/tasks.c **** 
 377:../../Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 378:../../Source/tasks.c **** the errno of the currently running task. */
 379:../../Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 380:../../Source/tasks.c **** 	int FreeRTOS_errno = 0;
 381:../../Source/tasks.c **** #endif
 382:../../Source/tasks.c **** 
 383:../../Source/tasks.c **** /* Other file private variables. --------------------------------*/
 384:../../Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 385:../../Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 386:../../Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 387:../../Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 388:../../Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 389:../../Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 390:../../Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 391:../../Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 392:../../Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 393:../../Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 394:../../Source/tasks.c **** 
 395:../../Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 396:../../Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 397:../../Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 398:../../Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 399:../../Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 400:../../Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 401:../../Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 402:../../Source/tasks.c **** accessed from a critical section. */
 403:../../Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 404:../../Source/tasks.c **** 
 405:../../Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 406:../../Source/tasks.c **** 
 407:../../Source/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
 408:../../Source/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 409:../../Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 410:../../Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 411:../../Source/tasks.c **** 
 412:../../Source/tasks.c **** #endif
 413:../../Source/tasks.c **** 
 414:../../Source/tasks.c **** /*lint -restore */
 415:../../Source/tasks.c **** 
 416:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 417:../../Source/tasks.c **** 
 418:../../Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 419:../../Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 420:../../Source/tasks.c **** 
 421:../../Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 422:../../Source/tasks.c **** 
 423:../../Source/tasks.c **** #endif
 424:../../Source/tasks.c **** 
 425:../../Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 426:../../Source/tasks.c **** 
 427:../../Source/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 428:../../Source/tasks.c **** 
 429:../../Source/tasks.c **** #endif
 430:../../Source/tasks.c **** 
 431:../../Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 432:../../Source/tasks.c **** 
 433:../../Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 434:../../Source/tasks.c **** 
 435:../../Source/tasks.c **** #endif
 436:../../Source/tasks.c **** 
 437:../../Source/tasks.c **** /* File private functions. --------------------------------*/
 438:../../Source/tasks.c **** 
 439:../../Source/tasks.c **** /**
 440:../../Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 441:../../Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 442:../../Source/tasks.c ****  * is in any other state.
 443:../../Source/tasks.c ****  */
 444:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 445:../../Source/tasks.c **** 
 446:../../Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 447:../../Source/tasks.c **** 
 448:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 449:../../Source/tasks.c **** 
 450:../../Source/tasks.c **** /*
 451:../../Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 452:../../Source/tasks.c ****  * automatically upon the creation of the first task.
 453:../../Source/tasks.c ****  */
 454:../../Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 455:../../Source/tasks.c **** 
 456:../../Source/tasks.c **** /*
 457:../../Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 458:../../Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 459:../../Source/tasks.c ****  * creation of the first user task.
 460:../../Source/tasks.c ****  *
 461:../../Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 462:../../Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 463:../../Source/tasks.c ****  *
 464:../../Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 465:../../Source/tasks.c ****  *
 466:../../Source/tasks.c ****  */
 467:../../Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 468:../../Source/tasks.c **** 
 469:../../Source/tasks.c **** /*
 470:../../Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 471:../../Source/tasks.c ****  * including the stack pointed to by the TCB.
 472:../../Source/tasks.c ****  *
 473:../../Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 474:../../Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 475:../../Source/tasks.c ****  */
 476:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 477:../../Source/tasks.c **** 
 478:../../Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 479:../../Source/tasks.c **** 
 480:../../Source/tasks.c **** #endif
 481:../../Source/tasks.c **** 
 482:../../Source/tasks.c **** /*
 483:../../Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 484:../../Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 485:../../Source/tasks.c ****  * and its TCB deleted.
 486:../../Source/tasks.c ****  */
 487:../../Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 488:../../Source/tasks.c **** 
 489:../../Source/tasks.c **** /*
 490:../../Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 491:../../Source/tasks.c ****  * either the current or the overflow delayed task list.
 492:../../Source/tasks.c ****  */
 493:../../Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 494:../../Source/tasks.c **** 
 495:../../Source/tasks.c **** /*
 496:../../Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 497:../../Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 498:../../Source/tasks.c ****  * a suspended list, etc.).
 499:../../Source/tasks.c ****  *
 500:../../Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 501:../../Source/tasks.c ****  * NORMAL APPLICATION CODE.
 502:../../Source/tasks.c ****  */
 503:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 504:../../Source/tasks.c **** 
 505:../../Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 506:../../Source/tasks.c **** 
 507:../../Source/tasks.c **** #endif
 508:../../Source/tasks.c **** 
 509:../../Source/tasks.c **** /*
 510:../../Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 511:../../Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 512:../../Source/tasks.c ****  */
 513:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 514:../../Source/tasks.c **** 
 515:../../Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 516:../../Source/tasks.c **** 
 517:../../Source/tasks.c **** #endif
 518:../../Source/tasks.c **** 
 519:../../Source/tasks.c **** /*
 520:../../Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 521:../../Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 522:../../Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 523:../../Source/tasks.c ****  */
 524:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 525:../../Source/tasks.c **** 
 526:../../Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 527:../../Source/tasks.c **** 
 528:../../Source/tasks.c **** #endif
 529:../../Source/tasks.c **** 
 530:../../Source/tasks.c **** /*
 531:../../Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 532:../../Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 533:../../Source/tasks.c ****  *
 534:../../Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 535:../../Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 536:../../Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 537:../../Source/tasks.c ****  * set to a value other than 1.
 538:../../Source/tasks.c ****  */
 539:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 540:../../Source/tasks.c **** 
 541:../../Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 542:../../Source/tasks.c **** 
 543:../../Source/tasks.c **** #endif
 544:../../Source/tasks.c **** 
 545:../../Source/tasks.c **** /*
 546:../../Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 547:../../Source/tasks.c ****  * will exit the Blocked state.
 548:../../Source/tasks.c ****  */
 549:../../Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 550:../../Source/tasks.c **** 
 551:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 552:../../Source/tasks.c **** 
 553:../../Source/tasks.c **** 	/*
 554:../../Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 555:../../Source/tasks.c **** 	 * human readable tables of task information.
 556:../../Source/tasks.c **** 	 */
 557:../../Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 558:../../Source/tasks.c **** 
 559:../../Source/tasks.c **** #endif
 560:../../Source/tasks.c **** 
 561:../../Source/tasks.c **** /*
 562:../../Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 563:../../Source/tasks.c ****  * dynamically to fill in the structure's members.
 564:../../Source/tasks.c ****  */
 565:../../Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 566:../../Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 567:../../Source/tasks.c **** 									const uint32_t ulStackDepth,
 568:../../Source/tasks.c **** 									void * const pvParameters,
 569:../../Source/tasks.c **** 									UBaseType_t uxPriority,
 570:../../Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 571:../../Source/tasks.c **** 									TCB_t *pxNewTCB,
 572:../../Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 573:../../Source/tasks.c **** 
 574:../../Source/tasks.c **** /*
 575:../../Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 576:../../Source/tasks.c ****  * under the control of the scheduler.
 577:../../Source/tasks.c ****  */
 578:../../Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 579:../../Source/tasks.c **** 
 580:../../Source/tasks.c **** /*
 581:../../Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 582:../../Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 583:../../Source/tasks.c ****  * called by the function.
 584:../../Source/tasks.c ****  */
 585:../../Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 586:../../Source/tasks.c **** 
 587:../../Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 588:../../Source/tasks.c **** 
 589:../../Source/tasks.c **** #endif
 590:../../Source/tasks.c **** 
 591:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 592:../../Source/tasks.c **** 
 593:../../Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 594:../../Source/tasks.c **** 
 595:../../Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 596:../../Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 597:../../Source/tasks.c **** 									const uint32_t ulStackDepth,
 598:../../Source/tasks.c **** 									void * const pvParameters,
 599:../../Source/tasks.c **** 									UBaseType_t uxPriority,
 600:../../Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 601:../../Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 602:../../Source/tasks.c **** 	{
 603:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 604:../../Source/tasks.c **** 	TaskHandle_t xReturn;
 605:../../Source/tasks.c **** 
 606:../../Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 607:../../Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 608:../../Source/tasks.c **** 
 609:../../Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 610:../../Source/tasks.c **** 		{
 611:../../Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 612:../../Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 613:../../Source/tasks.c **** 			structure. */
 614:../../Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 615:../../Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 616:../../Source/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 617:../../Source/tasks.c **** 		}
 618:../../Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 619:../../Source/tasks.c **** 
 620:../../Source/tasks.c **** 
 621:../../Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 622:../../Source/tasks.c **** 		{
 623:../../Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 624:../../Source/tasks.c **** 			function - use them. */
 625:../../Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 626:../../Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 627:../../Source/tasks.c **** 
 628:../../Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 629:../../Source/tasks.c **** 			{
 630:../../Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 631:../../Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 632:../../Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 633:../../Source/tasks.c **** 			}
 634:../../Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 635:../../Source/tasks.c **** 
 636:../../Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 637:../../Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 638:../../Source/tasks.c **** 		}
 639:../../Source/tasks.c **** 		else
 640:../../Source/tasks.c **** 		{
 641:../../Source/tasks.c **** 			xReturn = NULL;
 642:../../Source/tasks.c **** 		}
 643:../../Source/tasks.c **** 
 644:../../Source/tasks.c **** 		return xReturn;
 645:../../Source/tasks.c **** 	}
 646:../../Source/tasks.c **** 
 647:../../Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 648:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 649:../../Source/tasks.c **** 
 650:../../Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 651:../../Source/tasks.c **** 
 652:../../Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 653:../../Source/tasks.c **** 	{
 654:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 655:../../Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 656:../../Source/tasks.c **** 
 657:../../Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 658:../../Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 659:../../Source/tasks.c **** 
 660:../../Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 661:../../Source/tasks.c **** 		{
 662:../../Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 663:../../Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 664:../../Source/tasks.c **** 			not static allocation is being used. */
 665:../../Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 666:../../Source/tasks.c **** 
 667:../../Source/tasks.c **** 			/* Store the stack location in the TCB. */
 668:../../Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 669:../../Source/tasks.c **** 
 670:../../Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 671:../../Source/tasks.c **** 			{
 672:../../Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 673:../../Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 674:../../Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 675:../../Source/tasks.c **** 			}
 676:../../Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 677:../../Source/tasks.c **** 
 678:../../Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 679:../../Source/tasks.c **** 									pxTaskDefinition->pcName,
 680:../../Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 681:../../Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 682:../../Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 683:../../Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 684:../../Source/tasks.c **** 									pxTaskDefinition->xRegions );
 685:../../Source/tasks.c **** 
 686:../../Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 687:../../Source/tasks.c **** 			xReturn = pdPASS;
 688:../../Source/tasks.c **** 		}
 689:../../Source/tasks.c **** 
 690:../../Source/tasks.c **** 		return xReturn;
 691:../../Source/tasks.c **** 	}
 692:../../Source/tasks.c **** 
 693:../../Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 694:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 695:../../Source/tasks.c **** 
 696:../../Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 697:../../Source/tasks.c **** 
 698:../../Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 699:../../Source/tasks.c **** 	{
 700:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 701:../../Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 702:../../Source/tasks.c **** 
 703:../../Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 704:../../Source/tasks.c **** 
 705:../../Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 706:../../Source/tasks.c **** 		{
 707:../../Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 708:../../Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 709:../../Source/tasks.c **** 			not static allocation is being used. */
 710:../../Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 711:../../Source/tasks.c **** 
 712:../../Source/tasks.c **** 			if( pxNewTCB != NULL )
 713:../../Source/tasks.c **** 			{
 714:../../Source/tasks.c **** 				/* Store the stack location in the TCB. */
 715:../../Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 716:../../Source/tasks.c **** 
 717:../../Source/tasks.c **** 				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 718:../../Source/tasks.c **** 				{
 719:../../Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 720:../../Source/tasks.c **** 					this task had a statically allocated stack in case it is
 721:../../Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 722:../../Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 723:../../Source/tasks.c **** 				}
 724:../../Source/tasks.c **** 				#endif
 725:../../Source/tasks.c **** 
 726:../../Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 727:../../Source/tasks.c **** 										pxTaskDefinition->pcName,
 728:../../Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 729:../../Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 730:../../Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 731:../../Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 732:../../Source/tasks.c **** 										pxTaskDefinition->xRegions );
 733:../../Source/tasks.c **** 
 734:../../Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 735:../../Source/tasks.c **** 				xReturn = pdPASS;
 736:../../Source/tasks.c **** 			}
 737:../../Source/tasks.c **** 		}
 738:../../Source/tasks.c **** 
 739:../../Source/tasks.c **** 		return xReturn;
 740:../../Source/tasks.c **** 	}
 741:../../Source/tasks.c **** 
 742:../../Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 743:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 744:../../Source/tasks.c **** 
 745:../../Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 746:../../Source/tasks.c **** 
 747:../../Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 748:../../Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 749:../../Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 750:../../Source/tasks.c **** 							void * const pvParameters,
 751:../../Source/tasks.c **** 							UBaseType_t uxPriority,
 752:../../Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 753:../../Source/tasks.c **** 	{
 754:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 755:../../Source/tasks.c **** 	BaseType_t xReturn;
 756:../../Source/tasks.c **** 
 757:../../Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 758:../../Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 759:../../Source/tasks.c **** 		the TCB then the stack. */
 760:../../Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 761:../../Source/tasks.c **** 		{
 762:../../Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 763:../../Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 764:../../Source/tasks.c **** 			allocation is being used. */
 765:../../Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 766:../../Source/tasks.c **** 
 767:../../Source/tasks.c **** 			if( pxNewTCB != NULL )
 768:../../Source/tasks.c **** 			{
 769:../../Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 770:../../Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 771:../../Source/tasks.c **** 				be deleted later if required. */
 772:../../Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 773:../../Source/tasks.c **** 
 774:../../Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 775:../../Source/tasks.c **** 				{
 776:../../Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 777:../../Source/tasks.c **** 					vPortFree( pxNewTCB );
 778:../../Source/tasks.c **** 					pxNewTCB = NULL;
 779:../../Source/tasks.c **** 				}
 780:../../Source/tasks.c **** 			}
 781:../../Source/tasks.c **** 		}
 782:../../Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 783:../../Source/tasks.c **** 		{
 784:../../Source/tasks.c **** 		StackType_t *pxStack;
 785:../../Source/tasks.c **** 
 786:../../Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 787:../../Source/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 788:../../Source/tasks.c **** 
 789:../../Source/tasks.c **** 			if( pxStack != NULL )
 790:../../Source/tasks.c **** 			{
 791:../../Source/tasks.c **** 				/* Allocate space for the TCB. */
 792:../../Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 793:../../Source/tasks.c **** 
 794:../../Source/tasks.c **** 				if( pxNewTCB != NULL )
 795:../../Source/tasks.c **** 				{
 796:../../Source/tasks.c **** 					/* Store the stack location in the TCB. */
 797:../../Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 798:../../Source/tasks.c **** 				}
 799:../../Source/tasks.c **** 				else
 800:../../Source/tasks.c **** 				{
 801:../../Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 802:../../Source/tasks.c **** 					it again. */
 803:../../Source/tasks.c **** 					vPortFree( pxStack );
 804:../../Source/tasks.c **** 				}
 805:../../Source/tasks.c **** 			}
 806:../../Source/tasks.c **** 			else
 807:../../Source/tasks.c **** 			{
 808:../../Source/tasks.c **** 				pxNewTCB = NULL;
 809:../../Source/tasks.c **** 			}
 810:../../Source/tasks.c **** 		}
 811:../../Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 812:../../Source/tasks.c **** 
 813:../../Source/tasks.c **** 		if( pxNewTCB != NULL )
 814:../../Source/tasks.c **** 		{
 815:../../Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 816:../../Source/tasks.c **** 			{
 817:../../Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 818:../../Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 819:../../Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 820:../../Source/tasks.c **** 			}
 821:../../Source/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 822:../../Source/tasks.c **** 
 823:../../Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 824:../../Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 825:../../Source/tasks.c **** 			xReturn = pdPASS;
 826:../../Source/tasks.c **** 		}
 827:../../Source/tasks.c **** 		else
 828:../../Source/tasks.c **** 		{
 829:../../Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 830:../../Source/tasks.c **** 		}
 831:../../Source/tasks.c **** 
 832:../../Source/tasks.c **** 		return xReturn;
 833:../../Source/tasks.c **** 	}
 834:../../Source/tasks.c **** 
 835:../../Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 836:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 837:../../Source/tasks.c **** 
 838:../../Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 839:../../Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 840:../../Source/tasks.c **** 									const uint32_t ulStackDepth,
 841:../../Source/tasks.c **** 									void * const pvParameters,
 842:../../Source/tasks.c **** 									UBaseType_t uxPriority,
 843:../../Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 844:../../Source/tasks.c **** 									TCB_t *pxNewTCB,
 845:../../Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 846:../../Source/tasks.c **** {
 847:../../Source/tasks.c **** StackType_t *pxTopOfStack;
 848:../../Source/tasks.c **** UBaseType_t x;
 849:../../Source/tasks.c **** 
 850:../../Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 851:../../Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 852:../../Source/tasks.c **** 		BaseType_t xRunPrivileged;
 853:../../Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 854:../../Source/tasks.c **** 		{
 855:../../Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 856:../../Source/tasks.c **** 		}
 857:../../Source/tasks.c **** 		else
 858:../../Source/tasks.c **** 		{
 859:../../Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 860:../../Source/tasks.c **** 		}
 861:../../Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 862:../../Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 863:../../Source/tasks.c **** 
 864:../../Source/tasks.c **** 	configASSERT( pcName );
 865:../../Source/tasks.c **** 
 866:../../Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 867:../../Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 868:../../Source/tasks.c **** 	{
 869:../../Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 870:../../Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 871:../../Source/tasks.c **** 	}
 872:../../Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 873:../../Source/tasks.c **** 
 874:../../Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 875:../../Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 876:../../Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 877:../../Source/tasks.c **** 	by the port. */
 878:../../Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 879:../../Source/tasks.c **** 	{
 880:../../Source/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 881:../../Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 882:../../Source/tasks.c **** 
 883:../../Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 884:../../Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 885:../../Source/tasks.c **** 
 886:../../Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 887:../../Source/tasks.c **** 		{
 888:../../Source/tasks.c **** 			/* Also record the stack's high address, which may assist
 889:../../Source/tasks.c **** 			debugging. */
 890:../../Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 891:../../Source/tasks.c **** 		}
 892:../../Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 893:../../Source/tasks.c **** 	}
 894:../../Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 895:../../Source/tasks.c **** 	{
 896:../../Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 897:../../Source/tasks.c **** 
 898:../../Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 899:../../Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 900:../../Source/tasks.c **** 
 901:../../Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 902:../../Source/tasks.c **** 		performed. */
 903:../../Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 904:../../Source/tasks.c **** 	}
 905:../../Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 906:../../Source/tasks.c **** 
 907:../../Source/tasks.c **** 	/* Store the task name in the TCB. */
 908:../../Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 909:../../Source/tasks.c **** 	{
 910:../../Source/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 911:../../Source/tasks.c **** 
 912:../../Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 913:../../Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 914:../../Source/tasks.c **** 		string is not accessible (extremely unlikely). */
 915:../../Source/tasks.c **** 		if( pcName[ x ] == ( char ) 0x00 )
 916:../../Source/tasks.c **** 		{
 917:../../Source/tasks.c **** 			break;
 918:../../Source/tasks.c **** 		}
 919:../../Source/tasks.c **** 		else
 920:../../Source/tasks.c **** 		{
 921:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 922:../../Source/tasks.c **** 		}
 923:../../Source/tasks.c **** 	}
 924:../../Source/tasks.c **** 
 925:../../Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 926:../../Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 927:../../Source/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 928:../../Source/tasks.c **** 
 929:../../Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 930:../../Source/tasks.c **** 	remove the privilege bit if one is present. */
 931:../../Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 932:../../Source/tasks.c **** 	{
 933:../../Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 934:../../Source/tasks.c **** 	}
 935:../../Source/tasks.c **** 	else
 936:../../Source/tasks.c **** 	{
 937:../../Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 938:../../Source/tasks.c **** 	}
 939:../../Source/tasks.c **** 
 940:../../Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 941:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 942:../../Source/tasks.c **** 	{
 943:../../Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 944:../../Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 945:../../Source/tasks.c **** 	}
 946:../../Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 947:../../Source/tasks.c **** 
 948:../../Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 949:../../Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 950:../../Source/tasks.c **** 
 951:../../Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 952:../../Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 953:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 954:../../Source/tasks.c **** 
 955:../../Source/tasks.c **** 	/* Event lists are always in priority order. */
 956:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 957:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 958:../../Source/tasks.c **** 
 959:../../Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 960:../../Source/tasks.c **** 	{
 961:../../Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 962:../../Source/tasks.c **** 	}
 963:../../Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 964:../../Source/tasks.c **** 
 965:../../Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 966:../../Source/tasks.c **** 	{
 967:../../Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 968:../../Source/tasks.c **** 	}
 969:../../Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 970:../../Source/tasks.c **** 
 971:../../Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 972:../../Source/tasks.c **** 	{
 973:../../Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 974:../../Source/tasks.c **** 	}
 975:../../Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 976:../../Source/tasks.c **** 
 977:../../Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 978:../../Source/tasks.c **** 	{
 979:../../Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 980:../../Source/tasks.c **** 	}
 981:../../Source/tasks.c **** 	#else
 982:../../Source/tasks.c **** 	{
 983:../../Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 984:../../Source/tasks.c **** 		( void ) xRegions;
 985:../../Source/tasks.c **** 	}
 986:../../Source/tasks.c **** 	#endif
 987:../../Source/tasks.c **** 
 988:../../Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 989:../../Source/tasks.c **** 	{
 990:../../Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 991:../../Source/tasks.c **** 		{
 992:../../Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 993:../../Source/tasks.c **** 		}
 994:../../Source/tasks.c **** 	}
 995:../../Source/tasks.c **** 	#endif
 996:../../Source/tasks.c **** 
 997:../../Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 998:../../Source/tasks.c **** 	{
 999:../../Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
1000:../../Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1001:../../Source/tasks.c **** 	}
1002:../../Source/tasks.c **** 	#endif
1003:../../Source/tasks.c **** 
1004:../../Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
1005:../../Source/tasks.c **** 	{
1006:../../Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
1007:../../Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1008:../../Source/tasks.c **** 	}
1009:../../Source/tasks.c **** 	#endif
1010:../../Source/tasks.c **** 
1011:../../Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1012:../../Source/tasks.c **** 	{
1013:../../Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1014:../../Source/tasks.c **** 	}
1015:../../Source/tasks.c **** 	#endif
1016:../../Source/tasks.c **** 
1017:../../Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1018:../../Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1019:../../Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1020:../../Source/tasks.c **** 	the top of stack variable is updated. */
1021:../../Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1022:../../Source/tasks.c **** 	{
1023:../../Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
1024:../../Source/tasks.c **** 	}
1025:../../Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1026:../../Source/tasks.c **** 	{
1027:../../Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1028:../../Source/tasks.c **** 	}
1029:../../Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1030:../../Source/tasks.c **** 
1031:../../Source/tasks.c **** 	if( pxCreatedTask != NULL )
1032:../../Source/tasks.c **** 	{
1033:../../Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1034:../../Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1035:../../Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1036:../../Source/tasks.c **** 	}
1037:../../Source/tasks.c **** 	else
1038:../../Source/tasks.c **** 	{
1039:../../Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1040:../../Source/tasks.c **** 	}
1041:../../Source/tasks.c **** }
1042:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1043:../../Source/tasks.c **** 
1044:../../Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1045:../../Source/tasks.c **** {
1046:../../Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1047:../../Source/tasks.c **** 	updated. */
1048:../../Source/tasks.c **** 	taskENTER_CRITICAL();
1049:../../Source/tasks.c **** 	{
1050:../../Source/tasks.c **** 		uxCurrentNumberOfTasks++;
1051:../../Source/tasks.c **** 		if( pxCurrentTCB == NULL )
1052:../../Source/tasks.c **** 		{
1053:../../Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1054:../../Source/tasks.c **** 			the suspended state - make this the current task. */
1055:../../Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1056:../../Source/tasks.c **** 
1057:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1058:../../Source/tasks.c **** 			{
1059:../../Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1060:../../Source/tasks.c **** 				initialisation required.  We will not recover if this call
1061:../../Source/tasks.c **** 				fails, but we will report the failure. */
1062:../../Source/tasks.c **** 				prvInitialiseTaskLists();
1063:../../Source/tasks.c **** 			}
1064:../../Source/tasks.c **** 			else
1065:../../Source/tasks.c **** 			{
1066:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1067:../../Source/tasks.c **** 			}
1068:../../Source/tasks.c **** 		}
1069:../../Source/tasks.c **** 		else
1070:../../Source/tasks.c **** 		{
1071:../../Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1072:../../Source/tasks.c **** 			current task if it is the highest priority task to be created
1073:../../Source/tasks.c **** 			so far. */
1074:../../Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1075:../../Source/tasks.c **** 			{
1076:../../Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1077:../../Source/tasks.c **** 				{
1078:../../Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1079:../../Source/tasks.c **** 				}
1080:../../Source/tasks.c **** 				else
1081:../../Source/tasks.c **** 				{
1082:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1083:../../Source/tasks.c **** 				}
1084:../../Source/tasks.c **** 			}
1085:../../Source/tasks.c **** 			else
1086:../../Source/tasks.c **** 			{
1087:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1088:../../Source/tasks.c **** 			}
1089:../../Source/tasks.c **** 		}
1090:../../Source/tasks.c **** 
1091:../../Source/tasks.c **** 		uxTaskNumber++;
1092:../../Source/tasks.c **** 
1093:../../Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1094:../../Source/tasks.c **** 		{
1095:../../Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1096:../../Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1097:../../Source/tasks.c **** 		}
1098:../../Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1099:../../Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1100:../../Source/tasks.c **** 
1101:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1102:../../Source/tasks.c **** 
1103:../../Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1104:../../Source/tasks.c **** 	}
1105:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
1106:../../Source/tasks.c **** 
1107:../../Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1108:../../Source/tasks.c **** 	{
1109:../../Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1110:../../Source/tasks.c **** 		then it should run now. */
1111:../../Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1112:../../Source/tasks.c **** 		{
1113:../../Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1114:../../Source/tasks.c **** 		}
1115:../../Source/tasks.c **** 		else
1116:../../Source/tasks.c **** 		{
1117:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1118:../../Source/tasks.c **** 		}
1119:../../Source/tasks.c **** 	}
1120:../../Source/tasks.c **** 	else
1121:../../Source/tasks.c **** 	{
1122:../../Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1123:../../Source/tasks.c **** 	}
1124:../../Source/tasks.c **** }
1125:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1126:../../Source/tasks.c **** 
1127:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1128:../../Source/tasks.c **** 
1129:../../Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1130:../../Source/tasks.c **** 	{
1131:../../Source/tasks.c **** 	TCB_t *pxTCB;
1132:../../Source/tasks.c **** 
1133:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1134:../../Source/tasks.c **** 		{
1135:../../Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1136:../../Source/tasks.c **** 			being deleted. */
1137:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1138:../../Source/tasks.c **** 
1139:../../Source/tasks.c **** 			/* Remove task from the ready list. */
1140:../../Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1141:../../Source/tasks.c **** 			{
1142:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1143:../../Source/tasks.c **** 			}
1144:../../Source/tasks.c **** 			else
1145:../../Source/tasks.c **** 			{
1146:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1147:../../Source/tasks.c **** 			}
1148:../../Source/tasks.c **** 
1149:../../Source/tasks.c **** 			/* Is the task waiting on an event also? */
1150:../../Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1151:../../Source/tasks.c **** 			{
1152:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1153:../../Source/tasks.c **** 			}
1154:../../Source/tasks.c **** 			else
1155:../../Source/tasks.c **** 			{
1156:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1157:../../Source/tasks.c **** 			}
1158:../../Source/tasks.c **** 
1159:../../Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1160:../../Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1161:../../Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1162:../../Source/tasks.c **** 			not return. */
1163:../../Source/tasks.c **** 			uxTaskNumber++;
1164:../../Source/tasks.c **** 
1165:../../Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1166:../../Source/tasks.c **** 			{
1167:../../Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1168:../../Source/tasks.c **** 				task itself, as a context switch to another task is required.
1169:../../Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1170:../../Source/tasks.c **** 				check the termination list and free up any memory allocated by
1171:../../Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1172:../../Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1173:../../Source/tasks.c **** 
1174:../../Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1175:../../Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1176:../../Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1177:../../Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1178:../../Source/tasks.c **** 
1179:../../Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1180:../../Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1181:../../Source/tasks.c **** 				after which it is not possible to yield away from this task -
1182:../../Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1183:../../Source/tasks.c **** 				required. */
1184:../../Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1185:../../Source/tasks.c **** 			}
1186:../../Source/tasks.c **** 			else
1187:../../Source/tasks.c **** 			{
1188:../../Source/tasks.c **** 				--uxCurrentNumberOfTasks;
1189:../../Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1190:../../Source/tasks.c **** 
1191:../../Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1192:../../Source/tasks.c **** 				the task that has just been deleted. */
1193:../../Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1194:../../Source/tasks.c **** 			}
1195:../../Source/tasks.c **** 
1196:../../Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
1197:../../Source/tasks.c **** 		}
1198:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1199:../../Source/tasks.c **** 
1200:../../Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1201:../../Source/tasks.c **** 		been deleted. */
1202:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1203:../../Source/tasks.c **** 		{
1204:../../Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1205:../../Source/tasks.c **** 			{
1206:../../Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1207:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
1208:../../Source/tasks.c **** 			}
1209:../../Source/tasks.c **** 			else
1210:../../Source/tasks.c **** 			{
1211:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1212:../../Source/tasks.c **** 			}
1213:../../Source/tasks.c **** 		}
1214:../../Source/tasks.c **** 	}
1215:../../Source/tasks.c **** 
1216:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1217:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1218:../../Source/tasks.c **** 
1219:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1220:../../Source/tasks.c **** 
1221:../../Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1222:../../Source/tasks.c **** 	{
1223:../../Source/tasks.c **** 	TickType_t xTimeToWake;
1224:../../Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1225:../../Source/tasks.c **** 
1226:../../Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1227:../../Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1228:../../Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1229:../../Source/tasks.c **** 
1230:../../Source/tasks.c **** 		vTaskSuspendAll();
1231:../../Source/tasks.c **** 		{
1232:../../Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1233:../../Source/tasks.c **** 			block. */
1234:../../Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1235:../../Source/tasks.c **** 
1236:../../Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1237:../../Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1238:../../Source/tasks.c **** 
1239:../../Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1240:../../Source/tasks.c **** 			{
1241:../../Source/tasks.c **** 				/* The tick count has overflowed since this function was
1242:../../Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1243:../../Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1244:../../Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1245:../../Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1246:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1247:../../Source/tasks.c **** 				{
1248:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
1249:../../Source/tasks.c **** 				}
1250:../../Source/tasks.c **** 				else
1251:../../Source/tasks.c **** 				{
1252:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1253:../../Source/tasks.c **** 				}
1254:../../Source/tasks.c **** 			}
1255:../../Source/tasks.c **** 			else
1256:../../Source/tasks.c **** 			{
1257:../../Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1258:../../Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1259:../../Source/tasks.c **** 				tick time is less than the wake time. */
1260:../../Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1261:../../Source/tasks.c **** 				{
1262:../../Source/tasks.c **** 					xShouldDelay = pdTRUE;
1263:../../Source/tasks.c **** 				}
1264:../../Source/tasks.c **** 				else
1265:../../Source/tasks.c **** 				{
1266:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1267:../../Source/tasks.c **** 				}
1268:../../Source/tasks.c **** 			}
1269:../../Source/tasks.c **** 
1270:../../Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1271:../../Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1272:../../Source/tasks.c **** 
1273:../../Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
1274:../../Source/tasks.c **** 			{
1275:../../Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1276:../../Source/tasks.c **** 
1277:../../Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1278:../../Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1279:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1280:../../Source/tasks.c **** 			}
1281:../../Source/tasks.c **** 			else
1282:../../Source/tasks.c **** 			{
1283:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1284:../../Source/tasks.c **** 			}
1285:../../Source/tasks.c **** 		}
1286:../../Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
1287:../../Source/tasks.c **** 
1288:../../Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1289:../../Source/tasks.c **** 		have put ourselves to sleep. */
1290:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1291:../../Source/tasks.c **** 		{
1292:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
1293:../../Source/tasks.c **** 		}
1294:../../Source/tasks.c **** 		else
1295:../../Source/tasks.c **** 		{
1296:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1297:../../Source/tasks.c **** 		}
1298:../../Source/tasks.c **** 	}
1299:../../Source/tasks.c **** 
1300:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1301:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1302:../../Source/tasks.c **** 
1303:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1304:../../Source/tasks.c **** 
1305:../../Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1306:../../Source/tasks.c **** 	{
1307:../../Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1308:../../Source/tasks.c **** 
1309:../../Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1310:../../Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1311:../../Source/tasks.c **** 		{
1312:../../Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1313:../../Source/tasks.c **** 			vTaskSuspendAll();
1314:../../Source/tasks.c **** 			{
1315:../../Source/tasks.c **** 				traceTASK_DELAY();
1316:../../Source/tasks.c **** 
1317:../../Source/tasks.c **** 				/* A task that is removed from the event list while the
1318:../../Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1319:../../Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1320:../../Source/tasks.c **** 				is resumed.
1321:../../Source/tasks.c **** 
1322:../../Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1323:../../Source/tasks.c **** 				executing task. */
1324:../../Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1325:../../Source/tasks.c **** 			}
1326:../../Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1327:../../Source/tasks.c **** 		}
1328:../../Source/tasks.c **** 		else
1329:../../Source/tasks.c **** 		{
1330:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1331:../../Source/tasks.c **** 		}
1332:../../Source/tasks.c **** 
1333:../../Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1334:../../Source/tasks.c **** 		have put ourselves to sleep. */
1335:../../Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1336:../../Source/tasks.c **** 		{
1337:../../Source/tasks.c **** 			portYIELD_WITHIN_API();
1338:../../Source/tasks.c **** 		}
1339:../../Source/tasks.c **** 		else
1340:../../Source/tasks.c **** 		{
1341:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1342:../../Source/tasks.c **** 		}
1343:../../Source/tasks.c **** 	}
1344:../../Source/tasks.c **** 
1345:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1346:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1347:../../Source/tasks.c **** 
1348:../../Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1349:../../Source/tasks.c **** 
1350:../../Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1351:../../Source/tasks.c **** 	{
1352:../../Source/tasks.c **** 	eTaskState eReturn;
1353:../../Source/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1354:../../Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1355:../../Source/tasks.c **** 
1356:../../Source/tasks.c **** 		configASSERT( pxTCB );
1357:../../Source/tasks.c **** 
1358:../../Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1359:../../Source/tasks.c **** 		{
1360:../../Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1361:../../Source/tasks.c **** 			eReturn = eRunning;
1362:../../Source/tasks.c **** 		}
1363:../../Source/tasks.c **** 		else
1364:../../Source/tasks.c **** 		{
1365:../../Source/tasks.c **** 			taskENTER_CRITICAL();
1366:../../Source/tasks.c **** 			{
1367:../../Source/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1368:../../Source/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
1369:../../Source/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1370:../../Source/tasks.c **** 			}
1371:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
1372:../../Source/tasks.c **** 
1373:../../Source/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1374:../../Source/tasks.c **** 			{
1375:../../Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1376:../../Source/tasks.c **** 				lists. */
1377:../../Source/tasks.c **** 				eReturn = eBlocked;
1378:../../Source/tasks.c **** 			}
1379:../../Source/tasks.c **** 
1380:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1381:../../Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1382:../../Source/tasks.c **** 				{
1383:../../Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1384:../../Source/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1385:../../Source/tasks.c **** 					indefinitely? */
1386:../../Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1387:../../Source/tasks.c **** 					{
1388:../../Source/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1389:../../Source/tasks.c **** 						{
1390:../../Source/tasks.c **** 							/* The task does not appear on the event list item of
1391:../../Source/tasks.c **** 							and of the RTOS objects, but could still be in the
1392:../../Source/tasks.c **** 							blocked state if it is waiting on its notification
1393:../../Source/tasks.c **** 							rather than waiting on an object. */
1394:../../Source/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1395:../../Source/tasks.c **** 							{
1396:../../Source/tasks.c **** 								eReturn = eBlocked;
1397:../../Source/tasks.c **** 							}
1398:../../Source/tasks.c **** 							else
1399:../../Source/tasks.c **** 							{
1400:../../Source/tasks.c **** 								eReturn = eSuspended;
1401:../../Source/tasks.c **** 							}
1402:../../Source/tasks.c **** 						}
1403:../../Source/tasks.c **** 						#else
1404:../../Source/tasks.c **** 						{
1405:../../Source/tasks.c **** 							eReturn = eSuspended;
1406:../../Source/tasks.c **** 						}
1407:../../Source/tasks.c **** 						#endif
1408:../../Source/tasks.c **** 					}
1409:../../Source/tasks.c **** 					else
1410:../../Source/tasks.c **** 					{
1411:../../Source/tasks.c **** 						eReturn = eBlocked;
1412:../../Source/tasks.c **** 					}
1413:../../Source/tasks.c **** 				}
1414:../../Source/tasks.c **** 			#endif
1415:../../Source/tasks.c **** 
1416:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1417:../../Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1418:../../Source/tasks.c **** 				{
1419:../../Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1420:../../Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1421:../../Source/tasks.c **** 					all. */
1422:../../Source/tasks.c **** 					eReturn = eDeleted;
1423:../../Source/tasks.c **** 				}
1424:../../Source/tasks.c **** 			#endif
1425:../../Source/tasks.c **** 
1426:../../Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1427:../../Source/tasks.c **** 			{
1428:../../Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1429:../../Source/tasks.c **** 				Ready (including pending ready) state. */
1430:../../Source/tasks.c **** 				eReturn = eReady;
1431:../../Source/tasks.c **** 			}
1432:../../Source/tasks.c **** 		}
1433:../../Source/tasks.c **** 
1434:../../Source/tasks.c **** 		return eReturn;
1435:../../Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1436:../../Source/tasks.c **** 
1437:../../Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1438:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1439:../../Source/tasks.c **** 
1440:../../Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1441:../../Source/tasks.c **** 
1442:../../Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1443:../../Source/tasks.c **** 	{
1444:../../Source/tasks.c **** 	TCB_t const *pxTCB;
1445:../../Source/tasks.c **** 	UBaseType_t uxReturn;
1446:../../Source/tasks.c **** 
1447:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1448:../../Source/tasks.c **** 		{
1449:../../Source/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1450:../../Source/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1451:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1452:../../Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1453:../../Source/tasks.c **** 		}
1454:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1455:../../Source/tasks.c **** 
1456:../../Source/tasks.c **** 		return uxReturn;
1457:../../Source/tasks.c **** 	}
1458:../../Source/tasks.c **** 
1459:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1460:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1461:../../Source/tasks.c **** 
1462:../../Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1463:../../Source/tasks.c **** 
1464:../../Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1465:../../Source/tasks.c **** 	{
1466:../../Source/tasks.c **** 	TCB_t const *pxTCB;
1467:../../Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1468:../../Source/tasks.c **** 
1469:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1470:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1471:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1472:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1473:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1474:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1475:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1476:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1477:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1478:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1479:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1480:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1481:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1482:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1483:../../Source/tasks.c **** 		provided on the following link:
1484:../../Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1485:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1486:../../Source/tasks.c **** 
1487:../../Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1488:../../Source/tasks.c **** 		{
1489:../../Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1490:../../Source/tasks.c **** 			task that is being queried. */
1491:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1492:../../Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1493:../../Source/tasks.c **** 		}
1494:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1495:../../Source/tasks.c **** 
1496:../../Source/tasks.c **** 		return uxReturn;
1497:../../Source/tasks.c **** 	}
1498:../../Source/tasks.c **** 
1499:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1500:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1501:../../Source/tasks.c **** 
1502:../../Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1503:../../Source/tasks.c **** 
1504:../../Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1505:../../Source/tasks.c **** 	{
1506:../../Source/tasks.c **** 	TCB_t *pxTCB;
1507:../../Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1508:../../Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1509:../../Source/tasks.c **** 
1510:../../Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1511:../../Source/tasks.c **** 
1512:../../Source/tasks.c **** 		/* Ensure the new priority is valid. */
1513:../../Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1514:../../Source/tasks.c **** 		{
1515:../../Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1516:../../Source/tasks.c **** 		}
1517:../../Source/tasks.c **** 		else
1518:../../Source/tasks.c **** 		{
1519:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1520:../../Source/tasks.c **** 		}
1521:../../Source/tasks.c **** 
1522:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1523:../../Source/tasks.c **** 		{
1524:../../Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1525:../../Source/tasks.c **** 			task that is being changed. */
1526:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1527:../../Source/tasks.c **** 
1528:../../Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1529:../../Source/tasks.c **** 
1530:../../Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1531:../../Source/tasks.c **** 			{
1532:../../Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1533:../../Source/tasks.c **** 			}
1534:../../Source/tasks.c **** 			#else
1535:../../Source/tasks.c **** 			{
1536:../../Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1537:../../Source/tasks.c **** 			}
1538:../../Source/tasks.c **** 			#endif
1539:../../Source/tasks.c **** 
1540:../../Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1541:../../Source/tasks.c **** 			{
1542:../../Source/tasks.c **** 				/* The priority change may have readied a task of higher
1543:../../Source/tasks.c **** 				priority than the calling task. */
1544:../../Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1545:../../Source/tasks.c **** 				{
1546:../../Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1547:../../Source/tasks.c **** 					{
1548:../../Source/tasks.c **** 						/* The priority of a task other than the currently
1549:../../Source/tasks.c **** 						running task is being raised.  Is the priority being
1550:../../Source/tasks.c **** 						raised above that of the running task? */
1551:../../Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1552:../../Source/tasks.c **** 						{
1553:../../Source/tasks.c **** 							xYieldRequired = pdTRUE;
1554:../../Source/tasks.c **** 						}
1555:../../Source/tasks.c **** 						else
1556:../../Source/tasks.c **** 						{
1557:../../Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1558:../../Source/tasks.c **** 						}
1559:../../Source/tasks.c **** 					}
1560:../../Source/tasks.c **** 					else
1561:../../Source/tasks.c **** 					{
1562:../../Source/tasks.c **** 						/* The priority of the running task is being raised,
1563:../../Source/tasks.c **** 						but the running task must already be the highest
1564:../../Source/tasks.c **** 						priority task able to run so no yield is required. */
1565:../../Source/tasks.c **** 					}
1566:../../Source/tasks.c **** 				}
1567:../../Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1568:../../Source/tasks.c **** 				{
1569:../../Source/tasks.c **** 					/* Setting the priority of the running task down means
1570:../../Source/tasks.c **** 					there may now be another task of higher priority that
1571:../../Source/tasks.c **** 					is ready to execute. */
1572:../../Source/tasks.c **** 					xYieldRequired = pdTRUE;
1573:../../Source/tasks.c **** 				}
1574:../../Source/tasks.c **** 				else
1575:../../Source/tasks.c **** 				{
1576:../../Source/tasks.c **** 					/* Setting the priority of any other task down does not
1577:../../Source/tasks.c **** 					require a yield as the running task must be above the
1578:../../Source/tasks.c **** 					new priority of the task being modified. */
1579:../../Source/tasks.c **** 				}
1580:../../Source/tasks.c **** 
1581:../../Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1582:../../Source/tasks.c **** 				before its uxPriority member is changed so the
1583:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1584:../../Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1585:../../Source/tasks.c **** 
1586:../../Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1587:../../Source/tasks.c **** 				{
1588:../../Source/tasks.c **** 					/* Only change the priority being used if the task is not
1589:../../Source/tasks.c **** 					currently using an inherited priority. */
1590:../../Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1591:../../Source/tasks.c **** 					{
1592:../../Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1593:../../Source/tasks.c **** 					}
1594:../../Source/tasks.c **** 					else
1595:../../Source/tasks.c **** 					{
1596:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1597:../../Source/tasks.c **** 					}
1598:../../Source/tasks.c **** 
1599:../../Source/tasks.c **** 					/* The base priority gets set whatever. */
1600:../../Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1601:../../Source/tasks.c **** 				}
1602:../../Source/tasks.c **** 				#else
1603:../../Source/tasks.c **** 				{
1604:../../Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1605:../../Source/tasks.c **** 				}
1606:../../Source/tasks.c **** 				#endif
1607:../../Source/tasks.c **** 
1608:../../Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1609:../../Source/tasks.c **** 				being used for anything else. */
1610:../../Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1611:../../Source/tasks.c **** 				{
1612:../../Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1613:../../Source/tasks.c **** 				}
1614:../../Source/tasks.c **** 				else
1615:../../Source/tasks.c **** 				{
1616:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1617:../../Source/tasks.c **** 				}
1618:../../Source/tasks.c **** 
1619:../../Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1620:../../Source/tasks.c **** 				nothing more than change its priority variable. However, if
1621:../../Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1622:../../Source/tasks.c **** 				in the list appropriate to its new priority. */
1623:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1624:../../Source/tasks.c **** 				{
1625:../../Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1626:../../Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1627:../../Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1628:../../Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1629:../../Source/tasks.c **** 					{
1630:../../Source/tasks.c **** 						/* It is known that the task is in its ready list so
1631:../../Source/tasks.c **** 						there is no need to check again and the port level
1632:../../Source/tasks.c **** 						reset macro can be called directly. */
1633:../../Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1634:../../Source/tasks.c **** 					}
1635:../../Source/tasks.c **** 					else
1636:../../Source/tasks.c **** 					{
1637:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1638:../../Source/tasks.c **** 					}
1639:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1640:../../Source/tasks.c **** 				}
1641:../../Source/tasks.c **** 				else
1642:../../Source/tasks.c **** 				{
1643:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1644:../../Source/tasks.c **** 				}
1645:../../Source/tasks.c **** 
1646:../../Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
1647:../../Source/tasks.c **** 				{
1648:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1649:../../Source/tasks.c **** 				}
1650:../../Source/tasks.c **** 				else
1651:../../Source/tasks.c **** 				{
1652:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:../../Source/tasks.c **** 				}
1654:../../Source/tasks.c **** 
1655:../../Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1656:../../Source/tasks.c **** 				optimised task selection is not being used. */
1657:../../Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1658:../../Source/tasks.c **** 			}
1659:../../Source/tasks.c **** 		}
1660:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1661:../../Source/tasks.c **** 	}
1662:../../Source/tasks.c **** 
1663:../../Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1664:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1665:../../Source/tasks.c **** 
1666:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1667:../../Source/tasks.c **** 
1668:../../Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1669:../../Source/tasks.c **** 	{
1670:../../Source/tasks.c **** 	TCB_t *pxTCB;
1671:../../Source/tasks.c **** 
1672:../../Source/tasks.c **** 		taskENTER_CRITICAL();
1673:../../Source/tasks.c **** 		{
1674:../../Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1675:../../Source/tasks.c **** 			being suspended. */
1676:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1677:../../Source/tasks.c **** 
1678:../../Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1679:../../Source/tasks.c **** 
1680:../../Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1681:../../Source/tasks.c **** 			suspended list. */
1682:../../Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1683:../../Source/tasks.c **** 			{
1684:../../Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1685:../../Source/tasks.c **** 			}
1686:../../Source/tasks.c **** 			else
1687:../../Source/tasks.c **** 			{
1688:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1689:../../Source/tasks.c **** 			}
1690:../../Source/tasks.c **** 
1691:../../Source/tasks.c **** 			/* Is the task waiting on an event also? */
1692:../../Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1693:../../Source/tasks.c **** 			{
1694:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1695:../../Source/tasks.c **** 			}
1696:../../Source/tasks.c **** 			else
1697:../../Source/tasks.c **** 			{
1698:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1699:../../Source/tasks.c **** 			}
1700:../../Source/tasks.c **** 
1701:../../Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1702:../../Source/tasks.c **** 
1703:../../Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1704:../../Source/tasks.c **** 			{
1705:../../Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1706:../../Source/tasks.c **** 				{
1707:../../Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1708:../../Source/tasks.c **** 					now suspended, so no notification was received. */
1709:../../Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1710:../../Source/tasks.c **** 				}
1711:../../Source/tasks.c **** 			}
1712:../../Source/tasks.c **** 			#endif
1713:../../Source/tasks.c **** 		}
1714:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
1715:../../Source/tasks.c **** 
1716:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1717:../../Source/tasks.c **** 		{
1718:../../Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1719:../../Source/tasks.c **** 			task that is now in the Suspended state. */
1720:../../Source/tasks.c **** 			taskENTER_CRITICAL();
1721:../../Source/tasks.c **** 			{
1722:../../Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1723:../../Source/tasks.c **** 			}
1724:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
1725:../../Source/tasks.c **** 		}
1726:../../Source/tasks.c **** 		else
1727:../../Source/tasks.c **** 		{
1728:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1729:../../Source/tasks.c **** 		}
1730:../../Source/tasks.c **** 
1731:../../Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1732:../../Source/tasks.c **** 		{
1733:../../Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1734:../../Source/tasks.c **** 			{
1735:../../Source/tasks.c **** 				/* The current task has just been suspended. */
1736:../../Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1737:../../Source/tasks.c **** 				portYIELD_WITHIN_API();
1738:../../Source/tasks.c **** 			}
1739:../../Source/tasks.c **** 			else
1740:../../Source/tasks.c **** 			{
1741:../../Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1742:../../Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1743:../../Source/tasks.c **** 				must be adjusted to point to a different task. */
1744:../../Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1745:../../Source/tasks.c **** 				{
1746:../../Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1747:../../Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1748:../../Source/tasks.c **** 					be set to point to it no matter what its relative priority
1749:../../Source/tasks.c **** 					is. */
1750:../../Source/tasks.c **** 					pxCurrentTCB = NULL;
1751:../../Source/tasks.c **** 				}
1752:../../Source/tasks.c **** 				else
1753:../../Source/tasks.c **** 				{
1754:../../Source/tasks.c **** 					vTaskSwitchContext();
1755:../../Source/tasks.c **** 				}
1756:../../Source/tasks.c **** 			}
1757:../../Source/tasks.c **** 		}
1758:../../Source/tasks.c **** 		else
1759:../../Source/tasks.c **** 		{
1760:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1761:../../Source/tasks.c **** 		}
1762:../../Source/tasks.c **** 	}
1763:../../Source/tasks.c **** 
1764:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1765:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1766:../../Source/tasks.c **** 
1767:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1768:../../Source/tasks.c **** 
1769:../../Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1770:../../Source/tasks.c **** 	{
1771:../../Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1772:../../Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1773:../../Source/tasks.c **** 
1774:../../Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1775:../../Source/tasks.c **** 		section. */
1776:../../Source/tasks.c **** 
1777:../../Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1778:../../Source/tasks.c **** 		configASSERT( xTask );
1779:../../Source/tasks.c **** 
1780:../../Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1781:../../Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1782:../../Source/tasks.c **** 		{
1783:../../Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1784:../../Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1785:../../Source/tasks.c **** 			{
1786:../../Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1787:../../Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1788:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
1789:../../Source/tasks.c **** 				{
1790:../../Source/tasks.c **** 					xReturn = pdTRUE;
1791:../../Source/tasks.c **** 				}
1792:../../Source/tasks.c **** 				else
1793:../../Source/tasks.c **** 				{
1794:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1795:../../Source/tasks.c **** 				}
1796:../../Source/tasks.c **** 			}
1797:../../Source/tasks.c **** 			else
1798:../../Source/tasks.c **** 			{
1799:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1800:../../Source/tasks.c **** 			}
1801:../../Source/tasks.c **** 		}
1802:../../Source/tasks.c **** 		else
1803:../../Source/tasks.c **** 		{
1804:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1805:../../Source/tasks.c **** 		}
1806:../../Source/tasks.c **** 
1807:../../Source/tasks.c **** 		return xReturn;
1808:../../Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1809:../../Source/tasks.c **** 
1810:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1811:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1812:../../Source/tasks.c **** 
1813:../../Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1814:../../Source/tasks.c **** 
1815:../../Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1816:../../Source/tasks.c **** 	{
1817:../../Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1818:../../Source/tasks.c **** 
1819:../../Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1820:../../Source/tasks.c **** 		configASSERT( xTaskToResume );
1821:../../Source/tasks.c **** 
1822:../../Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1823:../../Source/tasks.c **** 		currently executing task. */
1824:../../Source/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1825:../../Source/tasks.c **** 		{
1826:../../Source/tasks.c **** 			taskENTER_CRITICAL();
1827:../../Source/tasks.c **** 			{
1828:../../Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1829:../../Source/tasks.c **** 				{
1830:../../Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1831:../../Source/tasks.c **** 
1832:../../Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1833:../../Source/tasks.c **** 					suspended because this is inside a critical section. */
1834:../../Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1835:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1836:../../Source/tasks.c **** 
1837:../../Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1838:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1839:../../Source/tasks.c **** 					{
1840:../../Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1841:../../Source/tasks.c **** 						but will leave the lists in the correct state for the
1842:../../Source/tasks.c **** 						next yield. */
1843:../../Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1844:../../Source/tasks.c **** 					}
1845:../../Source/tasks.c **** 					else
1846:../../Source/tasks.c **** 					{
1847:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1848:../../Source/tasks.c **** 					}
1849:../../Source/tasks.c **** 				}
1850:../../Source/tasks.c **** 				else
1851:../../Source/tasks.c **** 				{
1852:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1853:../../Source/tasks.c **** 				}
1854:../../Source/tasks.c **** 			}
1855:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
1856:../../Source/tasks.c **** 		}
1857:../../Source/tasks.c **** 		else
1858:../../Source/tasks.c **** 		{
1859:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1860:../../Source/tasks.c **** 		}
1861:../../Source/tasks.c **** 	}
1862:../../Source/tasks.c **** 
1863:../../Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1864:../../Source/tasks.c **** 
1865:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1866:../../Source/tasks.c **** 
1867:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1868:../../Source/tasks.c **** 
1869:../../Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1870:../../Source/tasks.c **** 	{
1871:../../Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1872:../../Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1873:../../Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1874:../../Source/tasks.c **** 
1875:../../Source/tasks.c **** 		configASSERT( xTaskToResume );
1876:../../Source/tasks.c **** 
1877:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1878:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1879:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1880:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1881:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1882:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1883:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1884:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1885:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1886:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1887:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1888:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1889:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1890:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1891:../../Source/tasks.c **** 		provided on the following link:
1892:../../Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1893:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1894:../../Source/tasks.c **** 
1895:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1896:../../Source/tasks.c **** 		{
1897:../../Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1898:../../Source/tasks.c **** 			{
1899:../../Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1900:../../Source/tasks.c **** 
1901:../../Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1902:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1903:../../Source/tasks.c **** 				{
1904:../../Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1905:../../Source/tasks.c **** 					suspended list to the ready list directly. */
1906:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1907:../../Source/tasks.c **** 					{
1908:../../Source/tasks.c **** 						xYieldRequired = pdTRUE;
1909:../../Source/tasks.c **** 					}
1910:../../Source/tasks.c **** 					else
1911:../../Source/tasks.c **** 					{
1912:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1913:../../Source/tasks.c **** 					}
1914:../../Source/tasks.c **** 
1915:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1916:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1917:../../Source/tasks.c **** 				}
1918:../../Source/tasks.c **** 				else
1919:../../Source/tasks.c **** 				{
1920:../../Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1921:../../Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1922:../../Source/tasks.c **** 					unsuspended. */
1923:../../Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1924:../../Source/tasks.c **** 				}
1925:../../Source/tasks.c **** 			}
1926:../../Source/tasks.c **** 			else
1927:../../Source/tasks.c **** 			{
1928:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1929:../../Source/tasks.c **** 			}
1930:../../Source/tasks.c **** 		}
1931:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1932:../../Source/tasks.c **** 
1933:../../Source/tasks.c **** 		return xYieldRequired;
1934:../../Source/tasks.c **** 	}
1935:../../Source/tasks.c **** 
1936:../../Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1937:../../Source/tasks.c **** /*-----------------------------------------------------------*/
1938:../../Source/tasks.c **** 
1939:../../Source/tasks.c **** void vTaskStartScheduler( void )
1940:../../Source/tasks.c **** {
1941:../../Source/tasks.c **** BaseType_t xReturn;
1942:../../Source/tasks.c **** 
1943:../../Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1944:../../Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1945:../../Source/tasks.c **** 	{
1946:../../Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1947:../../Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1948:../../Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1949:../../Source/tasks.c **** 
1950:../../Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1951:../../Source/tasks.c **** 		address of the RAM then create the idle task. */
1952:../../Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1953:../../Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1954:../../Source/tasks.c **** 												configIDLE_TASK_NAME,
1955:../../Source/tasks.c **** 												ulIdleTaskStackSize,
1956:../../Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1957:../../Source/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1958:../../Source/tasks.c **** 												pxIdleTaskStackBuffer,
1959:../../Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1960:../../Source/tasks.c **** 
1961:../../Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1962:../../Source/tasks.c **** 		{
1963:../../Source/tasks.c **** 			xReturn = pdPASS;
1964:../../Source/tasks.c **** 		}
1965:../../Source/tasks.c **** 		else
1966:../../Source/tasks.c **** 		{
1967:../../Source/tasks.c **** 			xReturn = pdFAIL;
1968:../../Source/tasks.c **** 		}
1969:../../Source/tasks.c **** 	}
1970:../../Source/tasks.c **** 	#else
1971:../../Source/tasks.c **** 	{
1972:../../Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1973:../../Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
1974:../../Source/tasks.c **** 								configIDLE_TASK_NAME,
1975:../../Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
1976:../../Source/tasks.c **** 								( void * ) NULL,
1977:../../Source/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
1978:../../Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1979:../../Source/tasks.c **** 	}
1980:../../Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1981:../../Source/tasks.c **** 
1982:../../Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1983:../../Source/tasks.c **** 	{
1984:../../Source/tasks.c **** 		if( xReturn == pdPASS )
1985:../../Source/tasks.c **** 		{
1986:../../Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1987:../../Source/tasks.c **** 		}
1988:../../Source/tasks.c **** 		else
1989:../../Source/tasks.c **** 		{
1990:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1991:../../Source/tasks.c **** 		}
1992:../../Source/tasks.c **** 	}
1993:../../Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1994:../../Source/tasks.c **** 
1995:../../Source/tasks.c **** 	if( xReturn == pdPASS )
1996:../../Source/tasks.c **** 	{
1997:../../Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
1998:../../Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
1999:../../Source/tasks.c **** 		the only macro called by the function. */
2000:../../Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2001:../../Source/tasks.c **** 		{
2002:../../Source/tasks.c **** 			freertos_tasks_c_additions_init();
2003:../../Source/tasks.c **** 		}
2004:../../Source/tasks.c **** 		#endif
2005:../../Source/tasks.c **** 
2006:../../Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2007:../../Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2008:../../Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2009:../../Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2010:../../Source/tasks.c **** 		starts to run. */
2011:../../Source/tasks.c **** 		portDISABLE_INTERRUPTS();
2012:../../Source/tasks.c **** 
2013:../../Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2014:../../Source/tasks.c **** 		{
2015:../../Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2016:../../Source/tasks.c **** 			structure specific to the task that will run first. */
2017:../../Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2018:../../Source/tasks.c **** 		}
2019:../../Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2020:../../Source/tasks.c **** 
2021:../../Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
2022:../../Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
2023:../../Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2024:../../Source/tasks.c **** 
2025:../../Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2026:../../Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2027:../../Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2028:../../Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2029:../../Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2030:../../Source/tasks.c **** 		FreeRTOSConfig.h file. */
2031:../../Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2032:../../Source/tasks.c **** 
2033:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2034:../../Source/tasks.c **** 
2035:../../Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2036:../../Source/tasks.c **** 		portable interface. */
2037:../../Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
2038:../../Source/tasks.c **** 		{
2039:../../Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2040:../../Source/tasks.c **** 			function will not return. */
2041:../../Source/tasks.c **** 		}
2042:../../Source/tasks.c **** 		else
2043:../../Source/tasks.c **** 		{
2044:../../Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2045:../../Source/tasks.c **** 		}
2046:../../Source/tasks.c **** 	}
2047:../../Source/tasks.c **** 	else
2048:../../Source/tasks.c **** 	{
2049:../../Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2050:../../Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2051:../../Source/tasks.c **** 		or the timer task. */
2052:../../Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2053:../../Source/tasks.c **** 	}
2054:../../Source/tasks.c **** 
2055:../../Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2056:../../Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2057:../../Source/tasks.c **** 	( void ) xIdleTaskHandle;
2058:../../Source/tasks.c **** }
2059:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2060:../../Source/tasks.c **** 
2061:../../Source/tasks.c **** void vTaskEndScheduler( void )
2062:../../Source/tasks.c **** {
2063:../../Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2064:../../Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2065:../../Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2066:../../Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2067:../../Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
2068:../../Source/tasks.c **** 	vPortEndScheduler();
2069:../../Source/tasks.c **** }
2070:../../Source/tasks.c **** /*----------------------------------------------------------*/
2071:../../Source/tasks.c **** 
2072:../../Source/tasks.c **** void vTaskSuspendAll( void )
2073:../../Source/tasks.c **** {
2074:../../Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2075:../../Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2076:../../Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2077:../../Source/tasks.c **** 	http://goo.gl/wu4acr */
2078:../../Source/tasks.c **** 	++uxSchedulerSuspended;
2079:../../Source/tasks.c **** }
2080:../../Source/tasks.c **** /*----------------------------------------------------------*/
2081:../../Source/tasks.c **** 
2082:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2083:../../Source/tasks.c **** 
2084:../../Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2085:../../Source/tasks.c **** 	{
2086:../../Source/tasks.c **** 	TickType_t xReturn;
2087:../../Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2088:../../Source/tasks.c **** 
2089:../../Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2090:../../Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2091:../../Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2092:../../Source/tasks.c **** 		running. */
2093:../../Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2094:../../Source/tasks.c **** 		{
2095:../../Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2096:../../Source/tasks.c **** 			{
2097:../../Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2098:../../Source/tasks.c **** 			}
2099:../../Source/tasks.c **** 		}
2100:../../Source/tasks.c **** 		#else
2101:../../Source/tasks.c **** 		{
2102:../../Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2103:../../Source/tasks.c **** 
2104:../../Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2105:../../Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2106:../../Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2107:../../Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2108:../../Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2109:../../Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2110:../../Source/tasks.c **** 			{
2111:../../Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2112:../../Source/tasks.c **** 			}
2113:../../Source/tasks.c **** 		}
2114:../../Source/tasks.c **** 		#endif
2115:../../Source/tasks.c **** 
2116:../../Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2117:../../Source/tasks.c **** 		{
2118:../../Source/tasks.c **** 			xReturn = 0;
2119:../../Source/tasks.c **** 		}
2120:../../Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2121:../../Source/tasks.c **** 		{
2122:../../Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2123:../../Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2124:../../Source/tasks.c **** 			processed. */
2125:../../Source/tasks.c **** 			xReturn = 0;
2126:../../Source/tasks.c **** 		}
2127:../../Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2128:../../Source/tasks.c **** 		{
2129:../../Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2130:../../Source/tasks.c **** 			idle priority.  This path can only be reached if
2131:../../Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2132:../../Source/tasks.c **** 			xReturn = 0;
2133:../../Source/tasks.c **** 		}
2134:../../Source/tasks.c **** 		else
2135:../../Source/tasks.c **** 		{
2136:../../Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2137:../../Source/tasks.c **** 		}
2138:../../Source/tasks.c **** 
2139:../../Source/tasks.c **** 		return xReturn;
2140:../../Source/tasks.c **** 	}
2141:../../Source/tasks.c **** 
2142:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2143:../../Source/tasks.c **** /*----------------------------------------------------------*/
2144:../../Source/tasks.c **** 
2145:../../Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2146:../../Source/tasks.c **** {
2147:../../Source/tasks.c **** TCB_t *pxTCB = NULL;
2148:../../Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2149:../../Source/tasks.c **** 
2150:../../Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2151:../../Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2152:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2153:../../Source/tasks.c **** 
2154:../../Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2155:../../Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2156:../../Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2157:../../Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2158:../../Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2159:../../Source/tasks.c **** 	taskENTER_CRITICAL();
2160:../../Source/tasks.c **** 	{
2161:../../Source/tasks.c **** 		--uxSchedulerSuspended;
2162:../../Source/tasks.c **** 
2163:../../Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2164:../../Source/tasks.c **** 		{
2165:../../Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2166:../../Source/tasks.c **** 			{
2167:../../Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2168:../../Source/tasks.c **** 				appropriate ready list. */
2169:../../Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2170:../../Source/tasks.c **** 				{
2171:../../Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
2172:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2173:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2174:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2175:../../Source/tasks.c **** 
2176:../../Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2177:../../Source/tasks.c **** 					task then a yield must be performed. */
2178:../../Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2179:../../Source/tasks.c **** 					{
2180:../../Source/tasks.c **** 						xYieldPending = pdTRUE;
2181:../../Source/tasks.c **** 					}
2182:../../Source/tasks.c **** 					else
2183:../../Source/tasks.c **** 					{
2184:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2185:../../Source/tasks.c **** 					}
2186:../../Source/tasks.c **** 				}
2187:../../Source/tasks.c **** 
2188:../../Source/tasks.c **** 				if( pxTCB != NULL )
2189:../../Source/tasks.c **** 				{
2190:../../Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2191:../../Source/tasks.c **** 					which may have prevented the next unblock time from being
2192:../../Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2193:../../Source/tasks.c **** 					important for low power tickless implementations, where
2194:../../Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2195:../../Source/tasks.c **** 					state. */
2196:../../Source/tasks.c **** 					prvResetNextTaskUnblockTime();
2197:../../Source/tasks.c **** 				}
2198:../../Source/tasks.c **** 
2199:../../Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2200:../../Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2201:../../Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2202:../../Source/tasks.c **** 				time. */
2203:../../Source/tasks.c **** 				{
2204:../../Source/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
2205:../../Source/tasks.c **** 
2206:../../Source/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
2207:../../Source/tasks.c **** 					{
2208:../../Source/tasks.c **** 						do
2209:../../Source/tasks.c **** 						{
2210:../../Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2211:../../Source/tasks.c **** 							{
2212:../../Source/tasks.c **** 								xYieldPending = pdTRUE;
2213:../../Source/tasks.c **** 							}
2214:../../Source/tasks.c **** 							else
2215:../../Source/tasks.c **** 							{
2216:../../Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2217:../../Source/tasks.c **** 							}
2218:../../Source/tasks.c **** 							--uxPendedCounts;
2219:../../Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
2220:../../Source/tasks.c **** 
2221:../../Source/tasks.c **** 						uxPendedTicks = 0;
2222:../../Source/tasks.c **** 					}
2223:../../Source/tasks.c **** 					else
2224:../../Source/tasks.c **** 					{
2225:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2226:../../Source/tasks.c **** 					}
2227:../../Source/tasks.c **** 				}
2228:../../Source/tasks.c **** 
2229:../../Source/tasks.c **** 				if( xYieldPending != pdFALSE )
2230:../../Source/tasks.c **** 				{
2231:../../Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2232:../../Source/tasks.c **** 					{
2233:../../Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
2234:../../Source/tasks.c **** 					}
2235:../../Source/tasks.c **** 					#endif
2236:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2237:../../Source/tasks.c **** 				}
2238:../../Source/tasks.c **** 				else
2239:../../Source/tasks.c **** 				{
2240:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2241:../../Source/tasks.c **** 				}
2242:../../Source/tasks.c **** 			}
2243:../../Source/tasks.c **** 		}
2244:../../Source/tasks.c **** 		else
2245:../../Source/tasks.c **** 		{
2246:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2247:../../Source/tasks.c **** 		}
2248:../../Source/tasks.c **** 	}
2249:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
2250:../../Source/tasks.c **** 
2251:../../Source/tasks.c **** 	return xAlreadyYielded;
2252:../../Source/tasks.c **** }
2253:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2254:../../Source/tasks.c **** 
2255:../../Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2256:../../Source/tasks.c **** {
2257:../../Source/tasks.c **** TickType_t xTicks;
2258:../../Source/tasks.c **** 
2259:../../Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2260:../../Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2261:../../Source/tasks.c **** 	{
2262:../../Source/tasks.c **** 		xTicks = xTickCount;
2263:../../Source/tasks.c **** 	}
2264:../../Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2265:../../Source/tasks.c **** 
2266:../../Source/tasks.c **** 	return xTicks;
2267:../../Source/tasks.c **** }
2268:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2269:../../Source/tasks.c **** 
2270:../../Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2271:../../Source/tasks.c **** {
2272:../../Source/tasks.c **** TickType_t xReturn;
2273:../../Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2274:../../Source/tasks.c **** 
2275:../../Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2276:../../Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2277:../../Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2278:../../Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2279:../../Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2280:../../Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2281:../../Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2282:../../Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2283:../../Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2284:../../Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2285:../../Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2286:../../Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2287:../../Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2288:../../Source/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2289:../../Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2290:../../Source/tasks.c **** 
2291:../../Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2292:../../Source/tasks.c **** 	{
2293:../../Source/tasks.c **** 		xReturn = xTickCount;
2294:../../Source/tasks.c **** 	}
2295:../../Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2296:../../Source/tasks.c **** 
2297:../../Source/tasks.c **** 	return xReturn;
2298:../../Source/tasks.c **** }
2299:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2300:../../Source/tasks.c **** 
2301:../../Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2302:../../Source/tasks.c **** {
2303:../../Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2304:../../Source/tasks.c **** 	BaseType_t. */
2305:../../Source/tasks.c **** 	return uxCurrentNumberOfTasks;
2306:../../Source/tasks.c **** }
2307:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2308:../../Source/tasks.c **** 
2309:../../Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2310:../../Source/tasks.c **** {
2311:../../Source/tasks.c **** TCB_t *pxTCB;
2312:../../Source/tasks.c **** 
2313:../../Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2314:../../Source/tasks.c **** 	queried. */
2315:../../Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2316:../../Source/tasks.c **** 	configASSERT( pxTCB );
2317:../../Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2318:../../Source/tasks.c **** }
2319:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2320:../../Source/tasks.c **** 
2321:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2322:../../Source/tasks.c **** 
2323:../../Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2324:../../Source/tasks.c **** 	{
2325:../../Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2326:../../Source/tasks.c **** 	UBaseType_t x;
2327:../../Source/tasks.c **** 	char cNextChar;
2328:../../Source/tasks.c **** 	BaseType_t xBreakLoop;
2329:../../Source/tasks.c **** 
2330:../../Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2331:../../Source/tasks.c **** 
2332:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2333:../../Source/tasks.c **** 		{
2334:../../Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2335:../../Source/tasks.c **** 
2336:../../Source/tasks.c **** 			do
2337:../../Source/tasks.c **** 			{
2338:../../Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2339:../../Source/tasks.c **** 
2340:../../Source/tasks.c **** 				/* Check each character in the name looking for a match or
2341:../../Source/tasks.c **** 				mismatch. */
2342:../../Source/tasks.c **** 				xBreakLoop = pdFALSE;
2343:../../Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2344:../../Source/tasks.c **** 				{
2345:../../Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2346:../../Source/tasks.c **** 
2347:../../Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2348:../../Source/tasks.c **** 					{
2349:../../Source/tasks.c **** 						/* Characters didn't match. */
2350:../../Source/tasks.c **** 						xBreakLoop = pdTRUE;
2351:../../Source/tasks.c **** 					}
2352:../../Source/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2353:../../Source/tasks.c **** 					{
2354:../../Source/tasks.c **** 						/* Both strings terminated, a match must have been
2355:../../Source/tasks.c **** 						found. */
2356:../../Source/tasks.c **** 						pxReturn = pxNextTCB;
2357:../../Source/tasks.c **** 						xBreakLoop = pdTRUE;
2358:../../Source/tasks.c **** 					}
2359:../../Source/tasks.c **** 					else
2360:../../Source/tasks.c **** 					{
2361:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2362:../../Source/tasks.c **** 					}
2363:../../Source/tasks.c **** 
2364:../../Source/tasks.c **** 					if( xBreakLoop != pdFALSE )
2365:../../Source/tasks.c **** 					{
2366:../../Source/tasks.c **** 						break;
2367:../../Source/tasks.c **** 					}
2368:../../Source/tasks.c **** 				}
2369:../../Source/tasks.c **** 
2370:../../Source/tasks.c **** 				if( pxReturn != NULL )
2371:../../Source/tasks.c **** 				{
2372:../../Source/tasks.c **** 					/* The handle has been found. */
2373:../../Source/tasks.c **** 					break;
2374:../../Source/tasks.c **** 				}
2375:../../Source/tasks.c **** 
2376:../../Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2377:../../Source/tasks.c **** 		}
2378:../../Source/tasks.c **** 		else
2379:../../Source/tasks.c **** 		{
2380:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2381:../../Source/tasks.c **** 		}
2382:../../Source/tasks.c **** 
2383:../../Source/tasks.c **** 		return pxReturn;
2384:../../Source/tasks.c **** 	}
2385:../../Source/tasks.c **** 
2386:../../Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2387:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2388:../../Source/tasks.c **** 
2389:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2390:../../Source/tasks.c **** 
2391:../../Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2392:../../Source/tasks.c **** 	{
2393:../../Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2394:../../Source/tasks.c **** 	TCB_t* pxTCB;
2395:../../Source/tasks.c **** 
2396:../../Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2397:../../Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2398:../../Source/tasks.c **** 
2399:../../Source/tasks.c **** 		vTaskSuspendAll();
2400:../../Source/tasks.c **** 		{
2401:../../Source/tasks.c **** 			/* Search the ready lists. */
2402:../../Source/tasks.c **** 			do
2403:../../Source/tasks.c **** 			{
2404:../../Source/tasks.c **** 				uxQueue--;
2405:../../Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2406:../../Source/tasks.c **** 
2407:../../Source/tasks.c **** 				if( pxTCB != NULL )
2408:../../Source/tasks.c **** 				{
2409:../../Source/tasks.c **** 					/* Found the handle. */
2410:../../Source/tasks.c **** 					break;
2411:../../Source/tasks.c **** 				}
2412:../../Source/tasks.c **** 
2413:../../Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2414:../../Source/tasks.c **** 
2415:../../Source/tasks.c **** 			/* Search the delayed lists. */
2416:../../Source/tasks.c **** 			if( pxTCB == NULL )
2417:../../Source/tasks.c **** 			{
2418:../../Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2419:../../Source/tasks.c **** 			}
2420:../../Source/tasks.c **** 
2421:../../Source/tasks.c **** 			if( pxTCB == NULL )
2422:../../Source/tasks.c **** 			{
2423:../../Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2424:../../Source/tasks.c **** 			}
2425:../../Source/tasks.c **** 
2426:../../Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2427:../../Source/tasks.c **** 			{
2428:../../Source/tasks.c **** 				if( pxTCB == NULL )
2429:../../Source/tasks.c **** 				{
2430:../../Source/tasks.c **** 					/* Search the suspended list. */
2431:../../Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2432:../../Source/tasks.c **** 				}
2433:../../Source/tasks.c **** 			}
2434:../../Source/tasks.c **** 			#endif
2435:../../Source/tasks.c **** 
2436:../../Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2437:../../Source/tasks.c **** 			{
2438:../../Source/tasks.c **** 				if( pxTCB == NULL )
2439:../../Source/tasks.c **** 				{
2440:../../Source/tasks.c **** 					/* Search the deleted list. */
2441:../../Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2442:../../Source/tasks.c **** 				}
2443:../../Source/tasks.c **** 			}
2444:../../Source/tasks.c **** 			#endif
2445:../../Source/tasks.c **** 		}
2446:../../Source/tasks.c **** 		( void ) xTaskResumeAll();
2447:../../Source/tasks.c **** 
2448:../../Source/tasks.c **** 		return pxTCB;
2449:../../Source/tasks.c **** 	}
2450:../../Source/tasks.c **** 
2451:../../Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2452:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2453:../../Source/tasks.c **** 
2454:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2455:../../Source/tasks.c **** 
2456:../../Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2457:../../Source/tasks.c **** 	{
2458:../../Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2459:../../Source/tasks.c **** 
2460:../../Source/tasks.c **** 		vTaskSuspendAll();
2461:../../Source/tasks.c **** 		{
2462:../../Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2463:../../Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2464:../../Source/tasks.c **** 			{
2465:../../Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2466:../../Source/tasks.c **** 				task in the Ready state. */
2467:../../Source/tasks.c **** 				do
2468:../../Source/tasks.c **** 				{
2469:../../Source/tasks.c **** 					uxQueue--;
2470:../../Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2471:../../Source/tasks.c **** 
2472:../../Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2473:../../Source/tasks.c **** 
2474:../../Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2475:../../Source/tasks.c **** 				task in the Blocked state. */
2476:../../Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2477:../../Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2478:../../Source/tasks.c **** 
2479:../../Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2480:../../Source/tasks.c **** 				{
2481:../../Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2482:../../Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2483:../../Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2484:../../Source/tasks.c **** 				}
2485:../../Source/tasks.c **** 				#endif
2486:../../Source/tasks.c **** 
2487:../../Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2488:../../Source/tasks.c **** 				{
2489:../../Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2490:../../Source/tasks.c **** 					each task in the Suspended state. */
2491:../../Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2492:../../Source/tasks.c **** 				}
2493:../../Source/tasks.c **** 				#endif
2494:../../Source/tasks.c **** 
2495:../../Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2496:../../Source/tasks.c **** 				{
2497:../../Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2498:../../Source/tasks.c **** 					{
2499:../../Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2500:../../Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2501:../../Source/tasks.c **** 						#else
2502:../../Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2503:../../Source/tasks.c **** 						#endif
2504:../../Source/tasks.c **** 					}
2505:../../Source/tasks.c **** 				}
2506:../../Source/tasks.c **** 				#else
2507:../../Source/tasks.c **** 				{
2508:../../Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2509:../../Source/tasks.c **** 					{
2510:../../Source/tasks.c **** 						*pulTotalRunTime = 0;
2511:../../Source/tasks.c **** 					}
2512:../../Source/tasks.c **** 				}
2513:../../Source/tasks.c **** 				#endif
2514:../../Source/tasks.c **** 			}
2515:../../Source/tasks.c **** 			else
2516:../../Source/tasks.c **** 			{
2517:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2518:../../Source/tasks.c **** 			}
2519:../../Source/tasks.c **** 		}
2520:../../Source/tasks.c **** 		( void ) xTaskResumeAll();
2521:../../Source/tasks.c **** 
2522:../../Source/tasks.c **** 		return uxTask;
2523:../../Source/tasks.c **** 	}
2524:../../Source/tasks.c **** 
2525:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2526:../../Source/tasks.c **** /*----------------------------------------------------------*/
2527:../../Source/tasks.c **** 
2528:../../Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2529:../../Source/tasks.c **** 
2530:../../Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2531:../../Source/tasks.c **** 	{
2532:../../Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2533:../../Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2534:../../Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2535:../../Source/tasks.c **** 		return xIdleTaskHandle;
2536:../../Source/tasks.c **** 	}
2537:../../Source/tasks.c **** 
2538:../../Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2539:../../Source/tasks.c **** /*----------------------------------------------------------*/
2540:../../Source/tasks.c **** 
2541:../../Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2542:../../Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2543:../../Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2544:../../Source/tasks.c **** 1. */
2545:../../Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2546:../../Source/tasks.c **** 
2547:../../Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2548:../../Source/tasks.c **** 	{
2549:../../Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2550:../../Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2551:../../Source/tasks.c **** 		each stepped tick. */
2552:../../Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2553:../../Source/tasks.c **** 		xTickCount += xTicksToJump;
2554:../../Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2555:../../Source/tasks.c **** 	}
2556:../../Source/tasks.c **** 
2557:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2558:../../Source/tasks.c **** /*----------------------------------------------------------*/
2559:../../Source/tasks.c **** 
2560:../../Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2561:../../Source/tasks.c **** 
2562:../../Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2563:../../Source/tasks.c **** 	{
2564:../../Source/tasks.c **** 	TCB_t *pxTCB = xTask;
2565:../../Source/tasks.c **** 	BaseType_t xReturn;
2566:../../Source/tasks.c **** 
2567:../../Source/tasks.c **** 		configASSERT( pxTCB );
2568:../../Source/tasks.c **** 
2569:../../Source/tasks.c **** 		vTaskSuspendAll();
2570:../../Source/tasks.c **** 		{
2571:../../Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2572:../../Source/tasks.c **** 			it is actually in the Blocked state. */
2573:../../Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2574:../../Source/tasks.c **** 			{
2575:../../Source/tasks.c **** 				xReturn = pdPASS;
2576:../../Source/tasks.c **** 
2577:../../Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2578:../../Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2579:../../Source/tasks.c **** 				scheduler is suspended. */
2580:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2581:../../Source/tasks.c **** 
2582:../../Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2583:../../Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2584:../../Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2585:../../Source/tasks.c **** 				is used. */
2586:../../Source/tasks.c **** 				taskENTER_CRITICAL();
2587:../../Source/tasks.c **** 				{
2588:../../Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2589:../../Source/tasks.c **** 					{
2590:../../Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2591:../../Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2592:../../Source/tasks.c **** 					}
2593:../../Source/tasks.c **** 					else
2594:../../Source/tasks.c **** 					{
2595:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2596:../../Source/tasks.c **** 					}
2597:../../Source/tasks.c **** 				}
2598:../../Source/tasks.c **** 				taskEXIT_CRITICAL();
2599:../../Source/tasks.c **** 
2600:../../Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2601:../../Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2602:../../Source/tasks.c **** 
2603:../../Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2604:../../Source/tasks.c **** 				switch if preemption is turned off. */
2605:../../Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2606:../../Source/tasks.c **** 				{
2607:../../Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2608:../../Source/tasks.c **** 					performed if the unblocked task has a priority that is
2609:../../Source/tasks.c **** 					equal to or higher than the currently executing task. */
2610:../../Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2611:../../Source/tasks.c **** 					{
2612:../../Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2613:../../Source/tasks.c **** 						is unsuspended. */
2614:../../Source/tasks.c **** 						xYieldPending = pdTRUE;
2615:../../Source/tasks.c **** 					}
2616:../../Source/tasks.c **** 					else
2617:../../Source/tasks.c **** 					{
2618:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2619:../../Source/tasks.c **** 					}
2620:../../Source/tasks.c **** 				}
2621:../../Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2622:../../Source/tasks.c **** 			}
2623:../../Source/tasks.c **** 			else
2624:../../Source/tasks.c **** 			{
2625:../../Source/tasks.c **** 				xReturn = pdFAIL;
2626:../../Source/tasks.c **** 			}
2627:../../Source/tasks.c **** 		}
2628:../../Source/tasks.c **** 		( void ) xTaskResumeAll();
2629:../../Source/tasks.c **** 
2630:../../Source/tasks.c **** 		return xReturn;
2631:../../Source/tasks.c **** 	}
2632:../../Source/tasks.c **** 
2633:../../Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2634:../../Source/tasks.c **** /*----------------------------------------------------------*/
2635:../../Source/tasks.c **** 
2636:../../Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2637:../../Source/tasks.c **** {
2638:../../Source/tasks.c **** TCB_t * pxTCB;
2639:../../Source/tasks.c **** TickType_t xItemValue;
2640:../../Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2641:../../Source/tasks.c **** 
2642:../../Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2643:../../Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2644:../../Source/tasks.c **** 	tasks to be unblocked. */
2645:../../Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2646:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2647:../../Source/tasks.c **** 	{
2648:../../Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2649:../../Source/tasks.c **** 		block. */
2650:../../Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2651:../../Source/tasks.c **** 
2652:../../Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2653:../../Source/tasks.c **** 		delayed lists if it wraps to 0. */
2654:../../Source/tasks.c **** 		xTickCount = xConstTickCount;
2655:../../Source/tasks.c **** 
2656:../../Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2657:../../Source/tasks.c **** 		{
2658:../../Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
2659:../../Source/tasks.c **** 		}
2660:../../Source/tasks.c **** 		else
2661:../../Source/tasks.c **** 		{
2662:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2663:../../Source/tasks.c **** 		}
2664:../../Source/tasks.c **** 
2665:../../Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2666:../../Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2667:../../Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2668:../../Source/tasks.c **** 		look any further down the list. */
2669:../../Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2670:../../Source/tasks.c **** 		{
2671:../../Source/tasks.c **** 			for( ;; )
2672:../../Source/tasks.c **** 			{
2673:../../Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2674:../../Source/tasks.c **** 				{
2675:../../Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2676:../../Source/tasks.c **** 					to the maximum possible value so it is extremely
2677:../../Source/tasks.c **** 					unlikely that the
2678:../../Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2679:../../Source/tasks.c **** 					next time through. */
2680:../../Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2681:../../Source/tasks.c **** 					break;
2682:../../Source/tasks.c **** 				}
2683:../../Source/tasks.c **** 				else
2684:../../Source/tasks.c **** 				{
2685:../../Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2686:../../Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2687:../../Source/tasks.c **** 					at which the task at the head of the delayed list must
2688:../../Source/tasks.c **** 					be removed from the Blocked state. */
2689:../../Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
2690:../../Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2691:../../Source/tasks.c **** 
2692:../../Source/tasks.c **** 					if( xConstTickCount < xItemValue )
2693:../../Source/tasks.c **** 					{
2694:../../Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2695:../../Source/tasks.c **** 						item value is the time at which the task at the head
2696:../../Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2697:../../Source/tasks.c **** 						state -	so record the item value in
2698:../../Source/tasks.c **** 						xNextTaskUnblockTime. */
2699:../../Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2700:../../Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
2701:../../Source/tasks.c **** 					}
2702:../../Source/tasks.c **** 					else
2703:../../Source/tasks.c **** 					{
2704:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2705:../../Source/tasks.c **** 					}
2706:../../Source/tasks.c **** 
2707:../../Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2708:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2709:../../Source/tasks.c **** 
2710:../../Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2711:../../Source/tasks.c **** 					it from the event list. */
2712:../../Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2713:../../Source/tasks.c **** 					{
2714:../../Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2715:../../Source/tasks.c **** 					}
2716:../../Source/tasks.c **** 					else
2717:../../Source/tasks.c **** 					{
2718:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2719:../../Source/tasks.c **** 					}
2720:../../Source/tasks.c **** 
2721:../../Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2722:../../Source/tasks.c **** 					list. */
2723:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2724:../../Source/tasks.c **** 
2725:../../Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2726:../../Source/tasks.c **** 					context switch if preemption is turned off. */
2727:../../Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2728:../../Source/tasks.c **** 					{
2729:../../Source/tasks.c **** 						/* Preemption is on, but a context switch should
2730:../../Source/tasks.c **** 						only be performed if the unblocked task has a
2731:../../Source/tasks.c **** 						priority that is equal to or higher than the
2732:../../Source/tasks.c **** 						currently executing task. */
2733:../../Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2734:../../Source/tasks.c **** 						{
2735:../../Source/tasks.c **** 							xSwitchRequired = pdTRUE;
2736:../../Source/tasks.c **** 						}
2737:../../Source/tasks.c **** 						else
2738:../../Source/tasks.c **** 						{
2739:../../Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2740:../../Source/tasks.c **** 						}
2741:../../Source/tasks.c **** 					}
2742:../../Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2743:../../Source/tasks.c **** 				}
2744:../../Source/tasks.c **** 			}
2745:../../Source/tasks.c **** 		}
2746:../../Source/tasks.c **** 
2747:../../Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2748:../../Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2749:../../Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2750:../../Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2751:../../Source/tasks.c **** 		{
2752:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2753:../../Source/tasks.c **** 			{
2754:../../Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2755:../../Source/tasks.c **** 			}
2756:../../Source/tasks.c **** 			else
2757:../../Source/tasks.c **** 			{
2758:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2759:../../Source/tasks.c **** 			}
2760:../../Source/tasks.c **** 		}
2761:../../Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2762:../../Source/tasks.c **** 
2763:../../Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2764:../../Source/tasks.c **** 		{
2765:../../Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2766:../../Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2767:../../Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2768:../../Source/tasks.c **** 			{
2769:../../Source/tasks.c **** 				vApplicationTickHook();
2770:../../Source/tasks.c **** 			}
2771:../../Source/tasks.c **** 			else
2772:../../Source/tasks.c **** 			{
2773:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2774:../../Source/tasks.c **** 			}
2775:../../Source/tasks.c **** 		}
2776:../../Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2777:../../Source/tasks.c **** 	}
2778:../../Source/tasks.c **** 	else
2779:../../Source/tasks.c **** 	{
2780:../../Source/tasks.c **** 		++uxPendedTicks;
2781:../../Source/tasks.c **** 
2782:../../Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2783:../../Source/tasks.c **** 		scheduler is locked. */
2784:../../Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2785:../../Source/tasks.c **** 		{
2786:../../Source/tasks.c **** 			vApplicationTickHook();
2787:../../Source/tasks.c **** 		}
2788:../../Source/tasks.c **** 		#endif
2789:../../Source/tasks.c **** 	}
2790:../../Source/tasks.c **** 
2791:../../Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2792:../../Source/tasks.c **** 	{
2793:../../Source/tasks.c **** 		if( xYieldPending != pdFALSE )
2794:../../Source/tasks.c **** 		{
2795:../../Source/tasks.c **** 			xSwitchRequired = pdTRUE;
2796:../../Source/tasks.c **** 		}
2797:../../Source/tasks.c **** 		else
2798:../../Source/tasks.c **** 		{
2799:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2800:../../Source/tasks.c **** 		}
2801:../../Source/tasks.c **** 	}
2802:../../Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2803:../../Source/tasks.c **** 
2804:../../Source/tasks.c **** 	return xSwitchRequired;
2805:../../Source/tasks.c **** }
2806:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2807:../../Source/tasks.c **** 
2808:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2809:../../Source/tasks.c **** 
2810:../../Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2811:../../Source/tasks.c **** 	{
2812:../../Source/tasks.c **** 	TCB_t *xTCB;
2813:../../Source/tasks.c **** 
2814:../../Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2815:../../Source/tasks.c **** 		getting set. */
2816:../../Source/tasks.c **** 		if( xTask == NULL )
2817:../../Source/tasks.c **** 		{
2818:../../Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2819:../../Source/tasks.c **** 		}
2820:../../Source/tasks.c **** 		else
2821:../../Source/tasks.c **** 		{
2822:../../Source/tasks.c **** 			xTCB = xTask;
2823:../../Source/tasks.c **** 		}
2824:../../Source/tasks.c **** 
2825:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2826:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
2827:../../Source/tasks.c **** 		taskENTER_CRITICAL();
2828:../../Source/tasks.c **** 		{
2829:../../Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2830:../../Source/tasks.c **** 		}
2831:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
2832:../../Source/tasks.c **** 	}
2833:../../Source/tasks.c **** 
2834:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2835:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2836:../../Source/tasks.c **** 
2837:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2838:../../Source/tasks.c **** 
2839:../../Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2840:../../Source/tasks.c **** 	{
2841:../../Source/tasks.c **** 	TCB_t *xTCB;
2842:../../Source/tasks.c **** 	TaskHookFunction_t xReturn;
2843:../../Source/tasks.c **** 
2844:../../Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2845:../../Source/tasks.c **** 		if( xTask == NULL )
2846:../../Source/tasks.c **** 		{
2847:../../Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2848:../../Source/tasks.c **** 		}
2849:../../Source/tasks.c **** 		else
2850:../../Source/tasks.c **** 		{
2851:../../Source/tasks.c **** 			xTCB = xTask;
2852:../../Source/tasks.c **** 		}
2853:../../Source/tasks.c **** 
2854:../../Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2855:../../Source/tasks.c **** 		the value can be accessed from an interrupt. */
2856:../../Source/tasks.c **** 		taskENTER_CRITICAL();
2857:../../Source/tasks.c **** 		{
2858:../../Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2859:../../Source/tasks.c **** 		}
2860:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
2861:../../Source/tasks.c **** 
2862:../../Source/tasks.c **** 		return xReturn;
2863:../../Source/tasks.c **** 	}
2864:../../Source/tasks.c **** 
2865:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2866:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2867:../../Source/tasks.c **** 
2868:../../Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2869:../../Source/tasks.c **** 
2870:../../Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2871:../../Source/tasks.c **** 	{
2872:../../Source/tasks.c **** 	TCB_t *xTCB;
2873:../../Source/tasks.c **** 	BaseType_t xReturn;
2874:../../Source/tasks.c **** 
2875:../../Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2876:../../Source/tasks.c **** 		if( xTask == NULL )
2877:../../Source/tasks.c **** 		{
2878:../../Source/tasks.c **** 			xTCB = pxCurrentTCB;
2879:../../Source/tasks.c **** 		}
2880:../../Source/tasks.c **** 		else
2881:../../Source/tasks.c **** 		{
2882:../../Source/tasks.c **** 			xTCB = xTask;
2883:../../Source/tasks.c **** 		}
2884:../../Source/tasks.c **** 
2885:../../Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2886:../../Source/tasks.c **** 		{
2887:../../Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2888:../../Source/tasks.c **** 		}
2889:../../Source/tasks.c **** 		else
2890:../../Source/tasks.c **** 		{
2891:../../Source/tasks.c **** 			xReturn = pdFAIL;
2892:../../Source/tasks.c **** 		}
2893:../../Source/tasks.c **** 
2894:../../Source/tasks.c **** 		return xReturn;
2895:../../Source/tasks.c **** 	}
2896:../../Source/tasks.c **** 
2897:../../Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2898:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2899:../../Source/tasks.c **** 
2900:../../Source/tasks.c **** void vTaskSwitchContext( void )
2901:../../Source/tasks.c **** {
2902:../../Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2903:../../Source/tasks.c **** 	{
2904:../../Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2905:../../Source/tasks.c **** 		switch. */
2906:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
2907:../../Source/tasks.c **** 	}
2908:../../Source/tasks.c **** 	else
2909:../../Source/tasks.c **** 	{
2910:../../Source/tasks.c **** 		xYieldPending = pdFALSE;
2911:../../Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2912:../../Source/tasks.c **** 
2913:../../Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2914:../../Source/tasks.c **** 		{
2915:../../Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2916:../../Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2917:../../Source/tasks.c **** 				#else
2918:../../Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2919:../../Source/tasks.c **** 				#endif
2920:../../Source/tasks.c **** 
2921:../../Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2922:../../Source/tasks.c **** 				accumulated time so far.  The time the task started running was
2923:../../Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2924:../../Source/tasks.c **** 				protection here so count values are only valid until the timer
2925:../../Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2926:../../Source/tasks.c **** 				against suspect run time stat counter implementations - which
2927:../../Source/tasks.c **** 				are provided by the application, not the kernel. */
2928:../../Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2929:../../Source/tasks.c **** 				{
2930:../../Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2931:../../Source/tasks.c **** 				}
2932:../../Source/tasks.c **** 				else
2933:../../Source/tasks.c **** 				{
2934:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2935:../../Source/tasks.c **** 				}
2936:../../Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2937:../../Source/tasks.c **** 		}
2938:../../Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2939:../../Source/tasks.c **** 
2940:../../Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2941:../../Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2942:../../Source/tasks.c **** 
2943:../../Source/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
2944:../../Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2945:../../Source/tasks.c **** 		{
2946:../../Source/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
2947:../../Source/tasks.c **** 		}
2948:../../Source/tasks.c **** 		#endif
2949:../../Source/tasks.c **** 
2950:../../Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2951:../../Source/tasks.c **** 		optimised asm code. */
2952:../../Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
2953:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2954:../../Source/tasks.c **** 
2955:../../Source/tasks.c **** 		/* After the new task is switched in, update the global errno. */
2956:../../Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2957:../../Source/tasks.c **** 		{
2958:../../Source/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
2959:../../Source/tasks.c **** 		}
2960:../../Source/tasks.c **** 		#endif
2961:../../Source/tasks.c **** 
2962:../../Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2963:../../Source/tasks.c **** 		{
2964:../../Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2965:../../Source/tasks.c **** 			structure specific to this task. */
2966:../../Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2967:../../Source/tasks.c **** 		}
2968:../../Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2969:../../Source/tasks.c **** 	}
2970:../../Source/tasks.c **** }
2971:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2972:../../Source/tasks.c **** 
2973:../../Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2974:../../Source/tasks.c **** {
2975:../../Source/tasks.c **** 	configASSERT( pxEventList );
2976:../../Source/tasks.c **** 
2977:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2978:../../Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2979:../../Source/tasks.c **** 
2980:../../Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2981:../../Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2982:../../Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2983:../../Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2984:../../Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2985:../../Source/tasks.c **** 
2986:../../Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2987:../../Source/tasks.c **** }
2988:../../Source/tasks.c **** /*-----------------------------------------------------------*/
2989:../../Source/tasks.c **** 
2990:../../Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2991:../../Source/tasks.c **** {
2992:../../Source/tasks.c **** 	configASSERT( pxEventList );
2993:../../Source/tasks.c **** 
2994:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2995:../../Source/tasks.c **** 	the event groups implementation. */
2996:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2997:../../Source/tasks.c **** 
2998:../../Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2999:../../Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3000:../../Source/tasks.c **** 	task that is not in the Blocked state. */
3001:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
3002:../../Source/tasks.c **** 
3003:../../Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3004:../../Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3005:../../Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
3006:../../Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3007:../../Source/tasks.c **** 	the task level). */
3008:../../Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3009:../../Source/tasks.c **** 
3010:../../Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3011:../../Source/tasks.c **** }
3012:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3013:../../Source/tasks.c **** 
3014:../../Source/tasks.c **** #if( configUSE_TIMERS == 1 )
3015:../../Source/tasks.c **** 
3016:../../Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3017:../../Source/tasks.c **** 	{
3018:../../Source/tasks.c **** 		configASSERT( pxEventList );
3019:../../Source/tasks.c **** 
3020:../../Source/tasks.c **** 		/* This function should not be called by application code hence the
3021:../../Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3022:../../Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3023:../../Source/tasks.c **** 		it should be called with the scheduler suspended. */
3024:../../Source/tasks.c **** 
3025:../../Source/tasks.c **** 
3026:../../Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3027:../../Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
3028:../../Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3029:../../Source/tasks.c **** 		can be used in place of vListInsert. */
3030:../../Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3031:../../Source/tasks.c **** 
3032:../../Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3033:../../Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3034:../../Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3035:../../Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3036:../../Source/tasks.c **** 		{
3037:../../Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3038:../../Source/tasks.c **** 		}
3039:../../Source/tasks.c **** 
3040:../../Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3041:../../Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3042:../../Source/tasks.c **** 	}
3043:../../Source/tasks.c **** 
3044:../../Source/tasks.c **** #endif /* configUSE_TIMERS */
3045:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3046:../../Source/tasks.c **** 
3047:../../Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3048:../../Source/tasks.c **** {
3049:../../Source/tasks.c **** TCB_t *pxUnblockedTCB;
3050:../../Source/tasks.c **** BaseType_t xReturn;
3051:../../Source/tasks.c **** 
3052:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3053:../../Source/tasks.c **** 	called from a critical section within an ISR. */
3054:../../Source/tasks.c **** 
3055:../../Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3056:../../Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3057:../../Source/tasks.c **** 	the delayed list, and add it to the ready list.
3058:../../Source/tasks.c **** 
3059:../../Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
3060:../../Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3061:../../Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3062:../../Source/tasks.c **** 
3063:../../Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
3064:../../Source/tasks.c **** 	pxEventList is not empty. */
3065:../../Source/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
3066:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3067:../../Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3068:../../Source/tasks.c **** 
3069:../../Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3070:../../Source/tasks.c **** 	{
3071:../../Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3072:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3073:../../Source/tasks.c **** 	}
3074:../../Source/tasks.c **** 	else
3075:../../Source/tasks.c **** 	{
3076:../../Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3077:../../Source/tasks.c **** 		pending until the scheduler is resumed. */
3078:../../Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3079:../../Source/tasks.c **** 	}
3080:../../Source/tasks.c **** 
3081:../../Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3082:../../Source/tasks.c **** 	{
3083:../../Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3084:../../Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3085:../../Source/tasks.c **** 		it should force a context switch now. */
3086:../../Source/tasks.c **** 		xReturn = pdTRUE;
3087:../../Source/tasks.c **** 
3088:../../Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3089:../../Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3090:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
3091:../../Source/tasks.c **** 	}
3092:../../Source/tasks.c **** 	else
3093:../../Source/tasks.c **** 	{
3094:../../Source/tasks.c **** 		xReturn = pdFALSE;
3095:../../Source/tasks.c **** 	}
3096:../../Source/tasks.c **** 
3097:../../Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3098:../../Source/tasks.c **** 	{
3099:../../Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3100:../../Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3101:../../Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3102:../../Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3103:../../Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3104:../../Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3105:../../Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3106:../../Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3107:../../Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3108:../../Source/tasks.c **** 	}
3109:../../Source/tasks.c **** 	#endif
3110:../../Source/tasks.c **** 
3111:../../Source/tasks.c **** 	return xReturn;
3112:../../Source/tasks.c **** }
3113:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3114:../../Source/tasks.c **** 
3115:../../Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3116:../../Source/tasks.c **** {
3117:../../Source/tasks.c **** TCB_t *pxUnblockedTCB;
3118:../../Source/tasks.c **** 
3119:../../Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3120:../../Source/tasks.c **** 	the event flags implementation. */
3121:../../Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3122:../../Source/tasks.c **** 
3123:../../Source/tasks.c **** 	/* Store the new item value in the event list. */
3124:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3125:../../Source/tasks.c **** 
3126:../../Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3127:../../Source/tasks.c **** 	event flags. */
3128:../../Source/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
3129:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3130:../../Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3131:../../Source/tasks.c **** 
3132:../../Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3133:../../Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3134:../../Source/tasks.c **** 	lists. */
3135:../../Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3136:../../Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3137:../../Source/tasks.c **** 
3138:../../Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3139:../../Source/tasks.c **** 	{
3140:../../Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3141:../../Source/tasks.c **** 		a context switch is required.  This function is called with the
3142:../../Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3143:../../Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3144:../../Source/tasks.c **** 		xYieldPending = pdTRUE;
3145:../../Source/tasks.c **** 	}
3146:../../Source/tasks.c **** }
3147:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3148:../../Source/tasks.c **** 
3149:../../Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3150:../../Source/tasks.c **** {
3151:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
3152:../../Source/tasks.c **** 	taskENTER_CRITICAL();
3153:../../Source/tasks.c **** 	{
3154:../../Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3155:../../Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3156:../../Source/tasks.c **** 	}
3157:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
3158:../../Source/tasks.c **** }
3159:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3160:../../Source/tasks.c **** 
3161:../../Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3162:../../Source/tasks.c **** {
3163:../../Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3164:../../Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3165:../../Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3166:../../Source/tasks.c **** }
3167:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3168:../../Source/tasks.c **** 
3169:../../Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3170:../../Source/tasks.c **** {
3171:../../Source/tasks.c **** BaseType_t xReturn;
3172:../../Source/tasks.c **** 
3173:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
3174:../../Source/tasks.c **** 	configASSERT( pxTicksToWait );
3175:../../Source/tasks.c **** 
3176:../../Source/tasks.c **** 	taskENTER_CRITICAL();
3177:../../Source/tasks.c **** 	{
3178:../../Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3179:../../Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3180:../../Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3181:../../Source/tasks.c **** 
3182:../../Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3183:../../Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3184:../../Source/tasks.c **** 			{
3185:../../Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3186:../../Source/tasks.c **** 				but has the same result. */
3187:../../Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3188:../../Source/tasks.c **** 				xReturn = pdTRUE;
3189:../../Source/tasks.c **** 			}
3190:../../Source/tasks.c **** 			else
3191:../../Source/tasks.c **** 		#endif
3192:../../Source/tasks.c **** 
3193:../../Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3194:../../Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3195:../../Source/tasks.c **** 			{
3196:../../Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3197:../../Source/tasks.c **** 				specified is the maximum block time then the task should block
3198:../../Source/tasks.c **** 				indefinitely, and therefore never time out. */
3199:../../Source/tasks.c **** 				xReturn = pdFALSE;
3200:../../Source/tasks.c **** 			}
3201:../../Source/tasks.c **** 			else
3202:../../Source/tasks.c **** 		#endif
3203:../../Source/tasks.c **** 
3204:../../Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3205:../../Source/tasks.c **** 		{
3206:../../Source/tasks.c **** 			/* The tick count is greater than the time at which
3207:../../Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3208:../../Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3209:../../Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3210:../../Source/tasks.c **** 			was called. */
3211:../../Source/tasks.c **** 			xReturn = pdTRUE;
3212:../../Source/tasks.c **** 		}
3213:../../Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3214:../../Source/tasks.c **** 		{
3215:../../Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3216:../../Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3217:../../Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3218:../../Source/tasks.c **** 			xReturn = pdFALSE;
3219:../../Source/tasks.c **** 		}
3220:../../Source/tasks.c **** 		else
3221:../../Source/tasks.c **** 		{
3222:../../Source/tasks.c **** 			*pxTicksToWait = 0;
3223:../../Source/tasks.c **** 			xReturn = pdTRUE;
3224:../../Source/tasks.c **** 		}
3225:../../Source/tasks.c **** 	}
3226:../../Source/tasks.c **** 	taskEXIT_CRITICAL();
3227:../../Source/tasks.c **** 
3228:../../Source/tasks.c **** 	return xReturn;
3229:../../Source/tasks.c **** }
3230:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3231:../../Source/tasks.c **** 
3232:../../Source/tasks.c **** void vTaskMissedYield( void )
3233:../../Source/tasks.c **** {
3234:../../Source/tasks.c **** 	xYieldPending = pdTRUE;
3235:../../Source/tasks.c **** }
3236:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3237:../../Source/tasks.c **** 
3238:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3239:../../Source/tasks.c **** 
3240:../../Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3241:../../Source/tasks.c **** 	{
3242:../../Source/tasks.c **** 	UBaseType_t uxReturn;
3243:../../Source/tasks.c **** 	TCB_t const *pxTCB;
3244:../../Source/tasks.c **** 
3245:../../Source/tasks.c **** 		if( xTask != NULL )
3246:../../Source/tasks.c **** 		{
3247:../../Source/tasks.c **** 			pxTCB = xTask;
3248:../../Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3249:../../Source/tasks.c **** 		}
3250:../../Source/tasks.c **** 		else
3251:../../Source/tasks.c **** 		{
3252:../../Source/tasks.c **** 			uxReturn = 0U;
3253:../../Source/tasks.c **** 		}
3254:../../Source/tasks.c **** 
3255:../../Source/tasks.c **** 		return uxReturn;
3256:../../Source/tasks.c **** 	}
3257:../../Source/tasks.c **** 
3258:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3259:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3260:../../Source/tasks.c **** 
3261:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3262:../../Source/tasks.c **** 
3263:../../Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3264:../../Source/tasks.c **** 	{
3265:../../Source/tasks.c **** 	TCB_t * pxTCB;
3266:../../Source/tasks.c **** 
3267:../../Source/tasks.c **** 		if( xTask != NULL )
3268:../../Source/tasks.c **** 		{
3269:../../Source/tasks.c **** 			pxTCB = xTask;
3270:../../Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3271:../../Source/tasks.c **** 		}
3272:../../Source/tasks.c **** 	}
3273:../../Source/tasks.c **** 
3274:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3275:../../Source/tasks.c **** 
3276:../../Source/tasks.c **** /*
3277:../../Source/tasks.c ****  * -----------------------------------------------------------
3278:../../Source/tasks.c ****  * The Idle task.
3279:../../Source/tasks.c ****  * ----------------------------------------------------------
3280:../../Source/tasks.c ****  *
3281:../../Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3282:../../Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3283:../../Source/tasks.c ****  *
3284:../../Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3285:../../Source/tasks.c ****  *
3286:../../Source/tasks.c ****  */
3287:../../Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3288:../../Source/tasks.c **** {
3289:../../Source/tasks.c **** 	/* Stop warnings. */
3290:../../Source/tasks.c **** 	( void ) pvParameters;
3291:../../Source/tasks.c **** 
3292:../../Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3293:../../Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3294:../../Source/tasks.c **** 
3295:../../Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3296:../../Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3297:../../Source/tasks.c **** 	any. */
3298:../../Source/tasks.c **** 	portTASK_CALLS_SECURE_FUNCTIONS();
3299:../../Source/tasks.c **** 
3300:../../Source/tasks.c **** 	for( ;; )
3301:../../Source/tasks.c **** 	{
3302:../../Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3303:../../Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3304:../../Source/tasks.c **** 		prvCheckTasksWaitingTermination();
3305:../../Source/tasks.c **** 
3306:../../Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3307:../../Source/tasks.c **** 		{
3308:../../Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3309:../../Source/tasks.c **** 			see if any other task has become available.  If we are using
3310:../../Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3311:../../Source/tasks.c **** 			will automatically get the processor anyway. */
3312:../../Source/tasks.c **** 			taskYIELD();
3313:../../Source/tasks.c **** 		}
3314:../../Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3315:../../Source/tasks.c **** 
3316:../../Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3317:../../Source/tasks.c **** 		{
3318:../../Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3319:../../Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3320:../../Source/tasks.c **** 			to run then the idle task should yield before the end of the
3321:../../Source/tasks.c **** 			timeslice.
3322:../../Source/tasks.c **** 
3323:../../Source/tasks.c **** 			A critical region is not required here as we are just reading from
3324:../../Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3325:../../Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3326:../../Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3327:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3328:../../Source/tasks.c **** 			{
3329:../../Source/tasks.c **** 				taskYIELD();
3330:../../Source/tasks.c **** 			}
3331:../../Source/tasks.c **** 			else
3332:../../Source/tasks.c **** 			{
3333:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3334:../../Source/tasks.c **** 			}
3335:../../Source/tasks.c **** 		}
3336:../../Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3337:../../Source/tasks.c **** 
3338:../../Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3339:../../Source/tasks.c **** 		{
3340:../../Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3341:../../Source/tasks.c **** 
3342:../../Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3343:../../Source/tasks.c **** 			allows the application designer to add background functionality
3344:../../Source/tasks.c **** 			without the overhead of a separate task.
3345:../../Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3346:../../Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3347:../../Source/tasks.c **** 			vApplicationIdleHook();
3348:../../Source/tasks.c **** 		}
3349:../../Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3350:../../Source/tasks.c **** 
3351:../../Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3352:../../Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3353:../../Source/tasks.c **** 		user defined low power mode	implementations require
3354:../../Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3355:../../Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3356:../../Source/tasks.c **** 		{
3357:../../Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3358:../../Source/tasks.c **** 
3359:../../Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3360:../../Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3361:../../Source/tasks.c **** 			test of the expected idle time is performed without the
3362:../../Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3363:../../Source/tasks.c **** 			valid. */
3364:../../Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3365:../../Source/tasks.c **** 
3366:../../Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3367:../../Source/tasks.c **** 			{
3368:../../Source/tasks.c **** 				vTaskSuspendAll();
3369:../../Source/tasks.c **** 				{
3370:../../Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3371:../../Source/tasks.c **** 					time can be sampled again, and this time its value can
3372:../../Source/tasks.c **** 					be used. */
3373:../../Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3374:../../Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3375:../../Source/tasks.c **** 
3376:../../Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3377:../../Source/tasks.c **** 					if the application does not want
3378:../../Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3379:../../Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3380:../../Source/tasks.c **** 
3381:../../Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3382:../../Source/tasks.c **** 					{
3383:../../Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3384:../../Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3385:../../Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3386:../../Source/tasks.c **** 					}
3387:../../Source/tasks.c **** 					else
3388:../../Source/tasks.c **** 					{
3389:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3390:../../Source/tasks.c **** 					}
3391:../../Source/tasks.c **** 				}
3392:../../Source/tasks.c **** 				( void ) xTaskResumeAll();
3393:../../Source/tasks.c **** 			}
3394:../../Source/tasks.c **** 			else
3395:../../Source/tasks.c **** 			{
3396:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3397:../../Source/tasks.c **** 			}
3398:../../Source/tasks.c **** 		}
3399:../../Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3400:../../Source/tasks.c **** 	}
3401:../../Source/tasks.c **** }
3402:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3403:../../Source/tasks.c **** 
3404:../../Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3405:../../Source/tasks.c **** 
3406:../../Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3407:../../Source/tasks.c **** 	{
3408:../../Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3409:../../Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3410:../../Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3411:../../Source/tasks.c **** 
3412:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3413:../../Source/tasks.c **** 		{
3414:../../Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3415:../../Source/tasks.c **** 			eReturn = eAbortSleep;
3416:../../Source/tasks.c **** 		}
3417:../../Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3418:../../Source/tasks.c **** 		{
3419:../../Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3420:../../Source/tasks.c **** 			eReturn = eAbortSleep;
3421:../../Source/tasks.c **** 		}
3422:../../Source/tasks.c **** 		else
3423:../../Source/tasks.c **** 		{
3424:../../Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3425:../../Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3426:../../Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3427:../../Source/tasks.c **** 			interrupts. */
3428:../../Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3429:../../Source/tasks.c **** 			{
3430:../../Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3431:../../Source/tasks.c **** 			}
3432:../../Source/tasks.c **** 			else
3433:../../Source/tasks.c **** 			{
3434:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3435:../../Source/tasks.c **** 			}
3436:../../Source/tasks.c **** 		}
3437:../../Source/tasks.c **** 
3438:../../Source/tasks.c **** 		return eReturn;
3439:../../Source/tasks.c **** 	}
3440:../../Source/tasks.c **** 
3441:../../Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3442:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3443:../../Source/tasks.c **** 
3444:../../Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3445:../../Source/tasks.c **** 
3446:../../Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3447:../../Source/tasks.c **** 	{
3448:../../Source/tasks.c **** 	TCB_t *pxTCB;
3449:../../Source/tasks.c **** 
3450:../../Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3451:../../Source/tasks.c **** 		{
3452:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3453:../../Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3454:../../Source/tasks.c **** 		}
3455:../../Source/tasks.c **** 	}
3456:../../Source/tasks.c **** 
3457:../../Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3458:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3459:../../Source/tasks.c **** 
3460:../../Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3461:../../Source/tasks.c **** 
3462:../../Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3463:../../Source/tasks.c **** 	{
3464:../../Source/tasks.c **** 	void *pvReturn = NULL;
3465:../../Source/tasks.c **** 	TCB_t *pxTCB;
3466:../../Source/tasks.c **** 
3467:../../Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3468:../../Source/tasks.c **** 		{
3469:../../Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3470:../../Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3471:../../Source/tasks.c **** 		}
3472:../../Source/tasks.c **** 		else
3473:../../Source/tasks.c **** 		{
3474:../../Source/tasks.c **** 			pvReturn = NULL;
3475:../../Source/tasks.c **** 		}
3476:../../Source/tasks.c **** 
3477:../../Source/tasks.c **** 		return pvReturn;
3478:../../Source/tasks.c **** 	}
3479:../../Source/tasks.c **** 
3480:../../Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3481:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3482:../../Source/tasks.c **** 
3483:../../Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3484:../../Source/tasks.c **** 
3485:../../Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3486:../../Source/tasks.c **** 	{
3487:../../Source/tasks.c **** 	TCB_t *pxTCB;
3488:../../Source/tasks.c **** 
3489:../../Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3490:../../Source/tasks.c **** 		the calling task. */
3491:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3492:../../Source/tasks.c **** 
3493:../../Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3494:../../Source/tasks.c **** 	}
3495:../../Source/tasks.c **** 
3496:../../Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3497:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3498:../../Source/tasks.c **** 
3499:../../Source/tasks.c **** static void prvInitialiseTaskLists( void )
3500:../../Source/tasks.c **** {
3501:../../Source/tasks.c **** UBaseType_t uxPriority;
3502:../../Source/tasks.c **** 
3503:../../Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3504:../../Source/tasks.c **** 	{
3505:../../Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3506:../../Source/tasks.c **** 	}
3507:../../Source/tasks.c **** 
3508:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3509:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3510:../../Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
3511:../../Source/tasks.c **** 
3512:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3513:../../Source/tasks.c **** 	{
3514:../../Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3515:../../Source/tasks.c **** 	}
3516:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3517:../../Source/tasks.c **** 
3518:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3519:../../Source/tasks.c **** 	{
3520:../../Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3521:../../Source/tasks.c **** 	}
3522:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3523:../../Source/tasks.c **** 
3524:../../Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3525:../../Source/tasks.c **** 	using list2. */
3526:../../Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3527:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3528:../../Source/tasks.c **** }
3529:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3530:../../Source/tasks.c **** 
3531:../../Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3532:../../Source/tasks.c **** {
3533:../../Source/tasks.c **** 
3534:../../Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3535:../../Source/tasks.c **** 
3536:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3537:../../Source/tasks.c **** 	{
3538:../../Source/tasks.c **** 		TCB_t *pxTCB;
3539:../../Source/tasks.c **** 
3540:../../Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3541:../../Source/tasks.c **** 		being called too often in the idle task. */
3542:../../Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3543:../../Source/tasks.c **** 		{
3544:../../Source/tasks.c **** 			taskENTER_CRITICAL();
3545:../../Source/tasks.c **** 			{
3546:../../Source/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
3547:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3548:../../Source/tasks.c **** 				--uxCurrentNumberOfTasks;
3549:../../Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3550:../../Source/tasks.c **** 			}
3551:../../Source/tasks.c **** 			taskEXIT_CRITICAL();
3552:../../Source/tasks.c **** 
3553:../../Source/tasks.c **** 			prvDeleteTCB( pxTCB );
3554:../../Source/tasks.c **** 		}
3555:../../Source/tasks.c **** 	}
3556:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3557:../../Source/tasks.c **** }
3558:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3559:../../Source/tasks.c **** 
3560:../../Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3561:../../Source/tasks.c **** 
3562:../../Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3563:../../Source/tasks.c **** 	{
3564:../../Source/tasks.c **** 	TCB_t *pxTCB;
3565:../../Source/tasks.c **** 
3566:../../Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3567:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3568:../../Source/tasks.c **** 
3569:../../Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3570:../../Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3571:../../Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3572:../../Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3573:../../Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3574:../../Source/tasks.c **** 
3575:../../Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3576:../../Source/tasks.c **** 		{
3577:../../Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3578:../../Source/tasks.c **** 		}
3579:../../Source/tasks.c **** 		#else
3580:../../Source/tasks.c **** 		{
3581:../../Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3582:../../Source/tasks.c **** 		}
3583:../../Source/tasks.c **** 		#endif
3584:../../Source/tasks.c **** 
3585:../../Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3586:../../Source/tasks.c **** 		{
3587:../../Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3588:../../Source/tasks.c **** 		}
3589:../../Source/tasks.c **** 		#else
3590:../../Source/tasks.c **** 		{
3591:../../Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3592:../../Source/tasks.c **** 		}
3593:../../Source/tasks.c **** 		#endif
3594:../../Source/tasks.c **** 
3595:../../Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3596:../../Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3597:../../Source/tasks.c **** 		state is just set to whatever is passed in. */
3598:../../Source/tasks.c **** 		if( eState != eInvalid )
3599:../../Source/tasks.c **** 		{
3600:../../Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3601:../../Source/tasks.c **** 			{
3602:../../Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3603:../../Source/tasks.c **** 			}
3604:../../Source/tasks.c **** 			else
3605:../../Source/tasks.c **** 			{
3606:../../Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3607:../../Source/tasks.c **** 
3608:../../Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3609:../../Source/tasks.c **** 				{
3610:../../Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3611:../../Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3612:../../Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3613:../../Source/tasks.c **** 					if( eState == eSuspended )
3614:../../Source/tasks.c **** 					{
3615:../../Source/tasks.c **** 						vTaskSuspendAll();
3616:../../Source/tasks.c **** 						{
3617:../../Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3618:../../Source/tasks.c **** 							{
3619:../../Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3620:../../Source/tasks.c **** 							}
3621:../../Source/tasks.c **** 						}
3622:../../Source/tasks.c **** 						( void ) xTaskResumeAll();
3623:../../Source/tasks.c **** 					}
3624:../../Source/tasks.c **** 				}
3625:../../Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3626:../../Source/tasks.c **** 			}
3627:../../Source/tasks.c **** 		}
3628:../../Source/tasks.c **** 		else
3629:../../Source/tasks.c **** 		{
3630:../../Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3631:../../Source/tasks.c **** 		}
3632:../../Source/tasks.c **** 
3633:../../Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3634:../../Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3635:../../Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3636:../../Source/tasks.c **** 		{
3637:../../Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3638:../../Source/tasks.c **** 			{
3639:../../Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3640:../../Source/tasks.c **** 			}
3641:../../Source/tasks.c **** 			#else
3642:../../Source/tasks.c **** 			{
3643:../../Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3644:../../Source/tasks.c **** 			}
3645:../../Source/tasks.c **** 			#endif
3646:../../Source/tasks.c **** 		}
3647:../../Source/tasks.c **** 		else
3648:../../Source/tasks.c **** 		{
3649:../../Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3650:../../Source/tasks.c **** 		}
3651:../../Source/tasks.c **** 	}
3652:../../Source/tasks.c **** 
3653:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3654:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3655:../../Source/tasks.c **** 
3656:../../Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3657:../../Source/tasks.c **** 
3658:../../Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3659:../../Source/tasks.c **** 	{
3660:../../Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3661:../../Source/tasks.c **** 	UBaseType_t uxTask = 0;
3662:../../Source/tasks.c **** 
3663:../../Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3664:../../Source/tasks.c **** 		{
3665:../../Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3666:../../Source/tasks.c **** 
3667:../../Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3668:../../Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3669:../../Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3670:../../Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3671:../../Source/tasks.c **** 			do
3672:../../Source/tasks.c **** 			{
3673:../../Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3674:../../Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3675:../../Source/tasks.c **** 				uxTask++;
3676:../../Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3677:../../Source/tasks.c **** 		}
3678:../../Source/tasks.c **** 		else
3679:../../Source/tasks.c **** 		{
3680:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3681:../../Source/tasks.c **** 		}
3682:../../Source/tasks.c **** 
3683:../../Source/tasks.c **** 		return uxTask;
3684:../../Source/tasks.c **** 	}
3685:../../Source/tasks.c **** 
3686:../../Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3687:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3688:../../Source/tasks.c **** 
3689:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3690:../../Source/tasks.c **** 
3691:../../Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3692:../../Source/tasks.c **** 	{
3693:../../Source/tasks.c **** 	uint32_t ulCount = 0U;
3694:../../Source/tasks.c **** 
3695:../../Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3696:../../Source/tasks.c **** 		{
3697:../../Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3698:../../Source/tasks.c **** 			ulCount++;
3699:../../Source/tasks.c **** 		}
3700:../../Source/tasks.c **** 
3701:../../Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3702:../../Source/tasks.c **** 
3703:../../Source/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
3704:../../Source/tasks.c **** 	}
3705:../../Source/tasks.c **** 
3706:../../Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3707:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3708:../../Source/tasks.c **** 
3709:../../Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3710:../../Source/tasks.c **** 
3711:../../Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3712:../../Source/tasks.c **** 	{
3713:../../Source/tasks.c **** 	TCB_t *pxTCB;
3714:../../Source/tasks.c **** 	uint8_t *pucEndOfStack;
3715:../../Source/tasks.c **** 	UBaseType_t uxReturn;
3716:../../Source/tasks.c **** 
3717:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3718:../../Source/tasks.c **** 
3719:../../Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3720:../../Source/tasks.c **** 		{
3721:../../Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3722:../../Source/tasks.c **** 		}
3723:../../Source/tasks.c **** 		#else
3724:../../Source/tasks.c **** 		{
3725:../../Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3726:../../Source/tasks.c **** 		}
3727:../../Source/tasks.c **** 		#endif
3728:../../Source/tasks.c **** 
3729:../../Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3730:../../Source/tasks.c **** 
3731:../../Source/tasks.c **** 		return uxReturn;
3732:../../Source/tasks.c **** 	}
3733:../../Source/tasks.c **** 
3734:../../Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3735:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3736:../../Source/tasks.c **** 
3737:../../Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3738:../../Source/tasks.c **** 
3739:../../Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3740:../../Source/tasks.c **** 	{
3741:../../Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3742:../../Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3743:../../Source/tasks.c **** 		want to allocate and clean RAM statically. */
3744:../../Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3745:../../Source/tasks.c **** 
3746:../../Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3747:../../Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3748:../../Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3749:../../Source/tasks.c **** 		{
3750:../../Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3751:../../Source/tasks.c **** 		}
3752:../../Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3753:../../Source/tasks.c **** 
3754:../../Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3755:../../Source/tasks.c **** 		{
3756:../../Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3757:../../Source/tasks.c **** 			the stack and TCB. */
3758:../../Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
3759:../../Source/tasks.c **** 			vPortFree( pxTCB );
3760:../../Source/tasks.c **** 		}
3761:../../Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3762:../../Source/tasks.c **** 		{
3763:../../Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3764:../../Source/tasks.c **** 			check what was statically allocated before trying to free the
3765:../../Source/tasks.c **** 			memory. */
3766:../../Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3767:../../Source/tasks.c **** 			{
3768:../../Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3769:../../Source/tasks.c **** 				must be freed. */
3770:../../Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3771:../../Source/tasks.c **** 				vPortFree( pxTCB );
3772:../../Source/tasks.c **** 			}
3773:../../Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3774:../../Source/tasks.c **** 			{
3775:../../Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3776:../../Source/tasks.c **** 				only memory that must be freed. */
3777:../../Source/tasks.c **** 				vPortFree( pxTCB );
3778:../../Source/tasks.c **** 			}
3779:../../Source/tasks.c **** 			else
3780:../../Source/tasks.c **** 			{
3781:../../Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3782:../../Source/tasks.c **** 				nothing needs to be freed. */
3783:../../Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3784:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3785:../../Source/tasks.c **** 			}
3786:../../Source/tasks.c **** 		}
3787:../../Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3788:../../Source/tasks.c **** 	}
3789:../../Source/tasks.c **** 
3790:../../Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3791:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3792:../../Source/tasks.c **** 
3793:../../Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3794:../../Source/tasks.c **** {
  15               		.loc 1 3794 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
3795:../../Source/tasks.c **** TCB_t *pxTCB;
3796:../../Source/tasks.c **** 
3797:../../Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  21               		.loc 1 3797 0
  22 0000 E091 0000 		lds r30,pxDelayedTaskList
  23 0004 F091 0000 		lds r31,pxDelayedTaskList+1
  24 0008 8081      		ld r24,Z
  25 000a 8111      		cpse r24,__zero_reg__
  26 000c 00C0      		rjmp .L2
3798:../../Source/tasks.c **** 	{
3799:../../Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3800:../../Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3801:../../Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3802:../../Source/tasks.c **** 		there is an item in the delayed list. */
3803:../../Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
  27               		.loc 1 3803 0
  28 000e 8FEF      		ldi r24,lo8(-1)
  29 0010 9FEF      		ldi r25,lo8(-1)
  30 0012 00C0      		rjmp .L4
  31               	.L2:
  32               	.LBB4:
  33               	.LBB5:
3804:../../Source/tasks.c **** 	}
3805:../../Source/tasks.c **** 	else
3806:../../Source/tasks.c **** 	{
3807:../../Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3808:../../Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3809:../../Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3810:../../Source/tasks.c **** 		from the Blocked state. */
3811:../../Source/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
  34               		.loc 1 3811 0
  35 0014 E091 0000 		lds r30,pxDelayedTaskList
  36 0018 F091 0000 		lds r31,pxDelayedTaskList+1
  37               	.LVL0:
  38 001c 0580      		ldd __tmp_reg__,Z+5
  39 001e F681      		ldd r31,Z+6
  40 0020 E02D      		mov r30,__tmp_reg__
  41               	.LVL1:
3812:../../Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  42               		.loc 1 3812 0
  43 0022 0680      		ldd __tmp_reg__,Z+6
  44 0024 F781      		ldd r31,Z+7
  45 0026 E02D      		mov r30,__tmp_reg__
  46               	.LVL2:
  47 0028 8281      		ldd r24,Z+2
  48 002a 9381      		ldd r25,Z+3
  49               	.LVL3:
  50               	.L4:
  51 002c 9093 0000 		sts xNextTaskUnblockTime+1,r25
  52 0030 8093 0000 		sts xNextTaskUnblockTime,r24
  53 0034 0895      		ret
  54               	.LBE5:
  55               	.LBE4:
  56               		.cfi_endproc
  57               	.LFE32:
  60               	prvAddCurrentTaskToDelayedList.isra.2:
  61               	.LFB43:
3813:../../Source/tasks.c **** 	}
3814:../../Source/tasks.c **** }
3815:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3816:../../Source/tasks.c **** 
3817:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3818:../../Source/tasks.c **** 
3819:../../Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3820:../../Source/tasks.c **** 	{
3821:../../Source/tasks.c **** 	TaskHandle_t xReturn;
3822:../../Source/tasks.c **** 
3823:../../Source/tasks.c **** 		/* A critical section is not required as this is not called from
3824:../../Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3825:../../Source/tasks.c **** 		individual execution thread. */
3826:../../Source/tasks.c **** 		xReturn = pxCurrentTCB;
3827:../../Source/tasks.c **** 
3828:../../Source/tasks.c **** 		return xReturn;
3829:../../Source/tasks.c **** 	}
3830:../../Source/tasks.c **** 
3831:../../Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3832:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3833:../../Source/tasks.c **** 
3834:../../Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3835:../../Source/tasks.c **** 
3836:../../Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3837:../../Source/tasks.c **** 	{
3838:../../Source/tasks.c **** 	BaseType_t xReturn;
3839:../../Source/tasks.c **** 
3840:../../Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3841:../../Source/tasks.c **** 		{
3842:../../Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3843:../../Source/tasks.c **** 		}
3844:../../Source/tasks.c **** 		else
3845:../../Source/tasks.c **** 		{
3846:../../Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3847:../../Source/tasks.c **** 			{
3848:../../Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3849:../../Source/tasks.c **** 			}
3850:../../Source/tasks.c **** 			else
3851:../../Source/tasks.c **** 			{
3852:../../Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3853:../../Source/tasks.c **** 			}
3854:../../Source/tasks.c **** 		}
3855:../../Source/tasks.c **** 
3856:../../Source/tasks.c **** 		return xReturn;
3857:../../Source/tasks.c **** 	}
3858:../../Source/tasks.c **** 
3859:../../Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3860:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3861:../../Source/tasks.c **** 
3862:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3863:../../Source/tasks.c **** 
3864:../../Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3865:../../Source/tasks.c **** 	{
3866:../../Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
3867:../../Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3868:../../Source/tasks.c **** 
3869:../../Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3870:../../Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
3871:../../Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
3872:../../Source/tasks.c **** 		if( pxMutexHolder != NULL )
3873:../../Source/tasks.c **** 		{
3874:../../Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3875:../../Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3876:../../Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3877:../../Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
3878:../../Source/tasks.c **** 			{
3879:../../Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3880:../../Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3881:../../Source/tasks.c **** 				not being used for anything else. */
3882:../../Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
3883:../../Source/tasks.c **** 				{
3884:../../Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
3885:../../Source/tasks.c **** 				}
3886:../../Source/tasks.c **** 				else
3887:../../Source/tasks.c **** 				{
3888:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3889:../../Source/tasks.c **** 				}
3890:../../Source/tasks.c **** 
3891:../../Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
3892:../../Source/tasks.c **** 				to be moved into a new list. */
3893:../../Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
3894:../../Source/tasks.c **** 				{
3895:../../Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3896:../../Source/tasks.c **** 					{
3897:../../Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
3898:../../Source/tasks.c **** 					}
3899:../../Source/tasks.c **** 					else
3900:../../Source/tasks.c **** 					{
3901:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3902:../../Source/tasks.c **** 					}
3903:../../Source/tasks.c **** 
3904:../../Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3905:../../Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3906:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
3907:../../Source/tasks.c **** 				}
3908:../../Source/tasks.c **** 				else
3909:../../Source/tasks.c **** 				{
3910:../../Source/tasks.c **** 					/* Just inherit the priority. */
3911:../../Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3912:../../Source/tasks.c **** 				}
3913:../../Source/tasks.c **** 
3914:../../Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
3915:../../Source/tasks.c **** 
3916:../../Source/tasks.c **** 				/* Inheritance occurred. */
3917:../../Source/tasks.c **** 				xReturn = pdTRUE;
3918:../../Source/tasks.c **** 			}
3919:../../Source/tasks.c **** 			else
3920:../../Source/tasks.c **** 			{
3921:../../Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
3922:../../Source/tasks.c **** 				{
3923:../../Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
3924:../../Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
3925:../../Source/tasks.c **** 					current priority of the mutex holder is not lower than the
3926:../../Source/tasks.c **** 					priority of the task attempting to take the mutex.
3927:../../Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
3928:../../Source/tasks.c **** 					priority, but inheritance would have occurred if that had
3929:../../Source/tasks.c **** 					not been the case. */
3930:../../Source/tasks.c **** 					xReturn = pdTRUE;
3931:../../Source/tasks.c **** 				}
3932:../../Source/tasks.c **** 				else
3933:../../Source/tasks.c **** 				{
3934:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3935:../../Source/tasks.c **** 				}
3936:../../Source/tasks.c **** 			}
3937:../../Source/tasks.c **** 		}
3938:../../Source/tasks.c **** 		else
3939:../../Source/tasks.c **** 		{
3940:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3941:../../Source/tasks.c **** 		}
3942:../../Source/tasks.c **** 
3943:../../Source/tasks.c **** 		return xReturn;
3944:../../Source/tasks.c **** 	}
3945:../../Source/tasks.c **** 
3946:../../Source/tasks.c **** #endif /* configUSE_MUTEXES */
3947:../../Source/tasks.c **** /*-----------------------------------------------------------*/
3948:../../Source/tasks.c **** 
3949:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3950:../../Source/tasks.c **** 
3951:../../Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3952:../../Source/tasks.c **** 	{
3953:../../Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
3954:../../Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3955:../../Source/tasks.c **** 
3956:../../Source/tasks.c **** 		if( pxMutexHolder != NULL )
3957:../../Source/tasks.c **** 		{
3958:../../Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3959:../../Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3960:../../Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3961:../../Source/tasks.c **** 			be the running state task. */
3962:../../Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3963:../../Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3964:../../Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3965:../../Source/tasks.c **** 
3966:../../Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3967:../../Source/tasks.c **** 			task? */
3968:../../Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3969:../../Source/tasks.c **** 			{
3970:../../Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3971:../../Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3972:../../Source/tasks.c **** 				{
3973:../../Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
3974:../../Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3975:../../Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3976:../../Source/tasks.c **** 					holding task then it must be the running state task.  Remove
3977:../../Source/tasks.c **** 					the holding task from the ready list. */
3978:../../Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3979:../../Source/tasks.c **** 					{
3980:../../Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3981:../../Source/tasks.c **** 					}
3982:../../Source/tasks.c **** 					else
3983:../../Source/tasks.c **** 					{
3984:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3985:../../Source/tasks.c **** 					}
3986:../../Source/tasks.c **** 
3987:../../Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3988:../../Source/tasks.c **** 					new	ready list. */
3989:../../Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3990:../../Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3991:../../Source/tasks.c **** 
3992:../../Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3993:../../Source/tasks.c **** 					any other purpose if this task is running, and it must be
3994:../../Source/tasks.c **** 					running to give back the mutex. */
3995:../../Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3996:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3997:../../Source/tasks.c **** 
3998:../../Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3999:../../Source/tasks.c **** 					This is only actually required in the corner case whereby
4000:../../Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4001:../../Source/tasks.c **** 					in an order different to that in which they were taken.
4002:../../Source/tasks.c **** 					If a context switch did not occur when the first mutex was
4003:../../Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
4004:../../Source/tasks.c **** 					switch should occur when the last mutex is returned whether
4005:../../Source/tasks.c **** 					a task is waiting on it or not. */
4006:../../Source/tasks.c **** 					xReturn = pdTRUE;
4007:../../Source/tasks.c **** 				}
4008:../../Source/tasks.c **** 				else
4009:../../Source/tasks.c **** 				{
4010:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4011:../../Source/tasks.c **** 				}
4012:../../Source/tasks.c **** 			}
4013:../../Source/tasks.c **** 			else
4014:../../Source/tasks.c **** 			{
4015:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4016:../../Source/tasks.c **** 			}
4017:../../Source/tasks.c **** 		}
4018:../../Source/tasks.c **** 		else
4019:../../Source/tasks.c **** 		{
4020:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4021:../../Source/tasks.c **** 		}
4022:../../Source/tasks.c **** 
4023:../../Source/tasks.c **** 		return xReturn;
4024:../../Source/tasks.c **** 	}
4025:../../Source/tasks.c **** 
4026:../../Source/tasks.c **** #endif /* configUSE_MUTEXES */
4027:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4028:../../Source/tasks.c **** 
4029:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4030:../../Source/tasks.c **** 
4031:../../Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4032:../../Source/tasks.c **** 	{
4033:../../Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4034:../../Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4035:../../Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4036:../../Source/tasks.c **** 
4037:../../Source/tasks.c **** 		if( pxMutexHolder != NULL )
4038:../../Source/tasks.c **** 		{
4039:../../Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4040:../../Source/tasks.c **** 			one mutex. */
4041:../../Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4042:../../Source/tasks.c **** 
4043:../../Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
4044:../../Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4045:../../Source/tasks.c **** 			holding task's base priority and the priority of the highest
4046:../../Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4047:../../Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4048:../../Source/tasks.c **** 			{
4049:../../Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4050:../../Source/tasks.c **** 			}
4051:../../Source/tasks.c **** 			else
4052:../../Source/tasks.c **** 			{
4053:../../Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4054:../../Source/tasks.c **** 			}
4055:../../Source/tasks.c **** 
4056:../../Source/tasks.c **** 			/* Does the priority need to change? */
4057:../../Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4058:../../Source/tasks.c **** 			{
4059:../../Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4060:../../Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
4061:../../Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4062:../../Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4063:../../Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4064:../../Source/tasks.c **** 				{
4065:../../Source/tasks.c **** 					/* If a task has timed out because it already holds the
4066:../../Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4067:../../Source/tasks.c **** 					its own priority. */
4068:../../Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4069:../../Source/tasks.c **** 
4070:../../Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4071:../../Source/tasks.c **** 					priority to facilitate determining the subject task's
4072:../../Source/tasks.c **** 					state. */
4073:../../Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4074:../../Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4075:../../Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4076:../../Source/tasks.c **** 
4077:../../Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4078:../../Source/tasks.c **** 					being used for anything else. */
4079:../../Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4080:../../Source/tasks.c **** 					{
4081:../../Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4082:../../Source/tasks.c **** 					}
4083:../../Source/tasks.c **** 					else
4084:../../Source/tasks.c **** 					{
4085:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4086:../../Source/tasks.c **** 					}
4087:../../Source/tasks.c **** 
4088:../../Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4089:../../Source/tasks.c **** 					then the task that holds the mutex could be in either the
4090:../../Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4091:../../Source/tasks.c **** 					from its current state list if it is in the Ready state as
4092:../../Source/tasks.c **** 					the task's priority is going to change and there is one
4093:../../Source/tasks.c **** 					Ready list per priority. */
4094:../../Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4095:../../Source/tasks.c **** 					{
4096:../../Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4097:../../Source/tasks.c **** 						{
4098:../../Source/tasks.c **** 							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4099:../../Source/tasks.c **** 						}
4100:../../Source/tasks.c **** 						else
4101:../../Source/tasks.c **** 						{
4102:../../Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4103:../../Source/tasks.c **** 						}
4104:../../Source/tasks.c **** 
4105:../../Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4106:../../Source/tasks.c **** 					}
4107:../../Source/tasks.c **** 					else
4108:../../Source/tasks.c **** 					{
4109:../../Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4110:../../Source/tasks.c **** 					}
4111:../../Source/tasks.c **** 				}
4112:../../Source/tasks.c **** 				else
4113:../../Source/tasks.c **** 				{
4114:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4115:../../Source/tasks.c **** 				}
4116:../../Source/tasks.c **** 			}
4117:../../Source/tasks.c **** 			else
4118:../../Source/tasks.c **** 			{
4119:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4120:../../Source/tasks.c **** 			}
4121:../../Source/tasks.c **** 		}
4122:../../Source/tasks.c **** 		else
4123:../../Source/tasks.c **** 		{
4124:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4125:../../Source/tasks.c **** 		}
4126:../../Source/tasks.c **** 	}
4127:../../Source/tasks.c **** 
4128:../../Source/tasks.c **** #endif /* configUSE_MUTEXES */
4129:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4130:../../Source/tasks.c **** 
4131:../../Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4132:../../Source/tasks.c **** 
4133:../../Source/tasks.c **** 	void vTaskEnterCritical( void )
4134:../../Source/tasks.c **** 	{
4135:../../Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4136:../../Source/tasks.c **** 
4137:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4138:../../Source/tasks.c **** 		{
4139:../../Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4140:../../Source/tasks.c **** 
4141:../../Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4142:../../Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4143:../../Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4144:../../Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4145:../../Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
4146:../../Source/tasks.c **** 			critical section. */
4147:../../Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4148:../../Source/tasks.c **** 			{
4149:../../Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4150:../../Source/tasks.c **** 			}
4151:../../Source/tasks.c **** 		}
4152:../../Source/tasks.c **** 		else
4153:../../Source/tasks.c **** 		{
4154:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4155:../../Source/tasks.c **** 		}
4156:../../Source/tasks.c **** 	}
4157:../../Source/tasks.c **** 
4158:../../Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4159:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4160:../../Source/tasks.c **** 
4161:../../Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4162:../../Source/tasks.c **** 
4163:../../Source/tasks.c **** 	void vTaskExitCritical( void )
4164:../../Source/tasks.c **** 	{
4165:../../Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4166:../../Source/tasks.c **** 		{
4167:../../Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4168:../../Source/tasks.c **** 			{
4169:../../Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4170:../../Source/tasks.c **** 
4171:../../Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4172:../../Source/tasks.c **** 				{
4173:../../Source/tasks.c **** 					portENABLE_INTERRUPTS();
4174:../../Source/tasks.c **** 				}
4175:../../Source/tasks.c **** 				else
4176:../../Source/tasks.c **** 				{
4177:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4178:../../Source/tasks.c **** 				}
4179:../../Source/tasks.c **** 			}
4180:../../Source/tasks.c **** 			else
4181:../../Source/tasks.c **** 			{
4182:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4183:../../Source/tasks.c **** 			}
4184:../../Source/tasks.c **** 		}
4185:../../Source/tasks.c **** 		else
4186:../../Source/tasks.c **** 		{
4187:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4188:../../Source/tasks.c **** 		}
4189:../../Source/tasks.c **** 	}
4190:../../Source/tasks.c **** 
4191:../../Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4192:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4193:../../Source/tasks.c **** 
4194:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4195:../../Source/tasks.c **** 
4196:../../Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4197:../../Source/tasks.c **** 	{
4198:../../Source/tasks.c **** 	size_t x;
4199:../../Source/tasks.c **** 
4200:../../Source/tasks.c **** 		/* Start by copying the entire string. */
4201:../../Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4202:../../Source/tasks.c **** 
4203:../../Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4204:../../Source/tasks.c **** 		printed out. */
4205:../../Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4206:../../Source/tasks.c **** 		{
4207:../../Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4208:../../Source/tasks.c **** 		}
4209:../../Source/tasks.c **** 
4210:../../Source/tasks.c **** 		/* Terminate. */
4211:../../Source/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4212:../../Source/tasks.c **** 
4213:../../Source/tasks.c **** 		/* Return the new end of string. */
4214:../../Source/tasks.c **** 		return &( pcBuffer[ x ] );
4215:../../Source/tasks.c **** 	}
4216:../../Source/tasks.c **** 
4217:../../Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4218:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4219:../../Source/tasks.c **** 
4220:../../Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4221:../../Source/tasks.c **** 
4222:../../Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4223:../../Source/tasks.c **** 	{
4224:../../Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4225:../../Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4226:../../Source/tasks.c **** 	char cStatus;
4227:../../Source/tasks.c **** 
4228:../../Source/tasks.c **** 		/*
4229:../../Source/tasks.c **** 		 * PLEASE NOTE:
4230:../../Source/tasks.c **** 		 *
4231:../../Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4232:../../Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4233:../../Source/tasks.c **** 		 * scheduler.
4234:../../Source/tasks.c **** 		 *
4235:../../Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4236:../../Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4237:../../Source/tasks.c **** 		 * displays task names, states and stack usage.
4238:../../Source/tasks.c **** 		 *
4239:../../Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4240:../../Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4241:../../Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4242:../../Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4243:../../Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4244:../../Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4245:../../Source/tasks.c **** 		 * snprintf() implementation!).
4246:../../Source/tasks.c **** 		 *
4247:../../Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4248:../../Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4249:../../Source/tasks.c **** 		 * through a call to vTaskList().
4250:../../Source/tasks.c **** 		 */
4251:../../Source/tasks.c **** 
4252:../../Source/tasks.c **** 
4253:../../Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4254:../../Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4255:../../Source/tasks.c **** 
4256:../../Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4257:../../Source/tasks.c **** 		function is executing. */
4258:../../Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4259:../../Source/tasks.c **** 
4260:../../Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4261:../../Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4262:../../Source/tasks.c **** 		equate to NULL. */
4263:../../Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4264:../../Source/tasks.c **** 
4265:../../Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4266:../../Source/tasks.c **** 		{
4267:../../Source/tasks.c **** 			/* Generate the (binary) data. */
4268:../../Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4269:../../Source/tasks.c **** 
4270:../../Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4271:../../Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4272:../../Source/tasks.c **** 			{
4273:../../Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4274:../../Source/tasks.c **** 				{
4275:../../Source/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4276:../../Source/tasks.c **** 										break;
4277:../../Source/tasks.c **** 
4278:../../Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4279:../../Source/tasks.c **** 										break;
4280:../../Source/tasks.c **** 
4281:../../Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4282:../../Source/tasks.c **** 										break;
4283:../../Source/tasks.c **** 
4284:../../Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4285:../../Source/tasks.c **** 										break;
4286:../../Source/tasks.c **** 
4287:../../Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4288:../../Source/tasks.c **** 										break;
4289:../../Source/tasks.c **** 
4290:../../Source/tasks.c **** 					case eInvalid:		/* Fall through. */
4291:../../Source/tasks.c **** 					default:			/* Should not get here, but it is included
4292:../../Source/tasks.c **** 										to prevent static checking errors. */
4293:../../Source/tasks.c **** 										cStatus = ( char ) 0x00;
4294:../../Source/tasks.c **** 										break;
4295:../../Source/tasks.c **** 				}
4296:../../Source/tasks.c **** 
4297:../../Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4298:../../Source/tasks.c **** 				can be printed in tabular form more easily. */
4299:../../Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4300:../../Source/tasks.c **** 
4301:../../Source/tasks.c **** 				/* Write the rest of the string. */
4302:../../Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4303:../../Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4304:../../Source/tasks.c **** 			}
4305:../../Source/tasks.c **** 
4306:../../Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4307:../../Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4308:../../Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4309:../../Source/tasks.c **** 		}
4310:../../Source/tasks.c **** 		else
4311:../../Source/tasks.c **** 		{
4312:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4313:../../Source/tasks.c **** 		}
4314:../../Source/tasks.c **** 	}
4315:../../Source/tasks.c **** 
4316:../../Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4317:../../Source/tasks.c **** /*----------------------------------------------------------*/
4318:../../Source/tasks.c **** 
4319:../../Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4320:../../Source/tasks.c **** 
4321:../../Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4322:../../Source/tasks.c **** 	{
4323:../../Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4324:../../Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4325:../../Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4326:../../Source/tasks.c **** 
4327:../../Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4328:../../Source/tasks.c **** 		{
4329:../../Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4330:../../Source/tasks.c **** 		}
4331:../../Source/tasks.c **** 		#endif
4332:../../Source/tasks.c **** 
4333:../../Source/tasks.c **** 		/*
4334:../../Source/tasks.c **** 		 * PLEASE NOTE:
4335:../../Source/tasks.c **** 		 *
4336:../../Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4337:../../Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4338:../../Source/tasks.c **** 		 * scheduler.
4339:../../Source/tasks.c **** 		 *
4340:../../Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4341:../../Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4342:../../Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4343:../../Source/tasks.c **** 		 * in both absolute and percentage terms.
4344:../../Source/tasks.c **** 		 *
4345:../../Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4346:../../Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4347:../../Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4348:../../Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4349:../../Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4350:../../Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4351:../../Source/tasks.c **** 		 * a full snprintf() implementation!).
4352:../../Source/tasks.c **** 		 *
4353:../../Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4354:../../Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4355:../../Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4356:../../Source/tasks.c **** 		 */
4357:../../Source/tasks.c **** 
4358:../../Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4359:../../Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4360:../../Source/tasks.c **** 
4361:../../Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4362:../../Source/tasks.c **** 		function is executing. */
4363:../../Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4364:../../Source/tasks.c **** 
4365:../../Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4366:../../Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4367:../../Source/tasks.c **** 		equate to NULL. */
4368:../../Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4369:../../Source/tasks.c **** 
4370:../../Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4371:../../Source/tasks.c **** 		{
4372:../../Source/tasks.c **** 			/* Generate the (binary) data. */
4373:../../Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4374:../../Source/tasks.c **** 
4375:../../Source/tasks.c **** 			/* For percentage calculations. */
4376:../../Source/tasks.c **** 			ulTotalTime /= 100UL;
4377:../../Source/tasks.c **** 
4378:../../Source/tasks.c **** 			/* Avoid divide by zero errors. */
4379:../../Source/tasks.c **** 			if( ulTotalTime > 0UL )
4380:../../Source/tasks.c **** 			{
4381:../../Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4382:../../Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4383:../../Source/tasks.c **** 				{
4384:../../Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4385:../../Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4386:../../Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4387:../../Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4388:../../Source/tasks.c **** 
4389:../../Source/tasks.c **** 					/* Write the task name to the string, padding with
4390:../../Source/tasks.c **** 					spaces so it can be printed in tabular form more
4391:../../Source/tasks.c **** 					easily. */
4392:../../Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4393:../../Source/tasks.c **** 
4394:../../Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4395:../../Source/tasks.c **** 					{
4396:../../Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4397:../../Source/tasks.c **** 						{
4398:../../Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4399:../../Source/tasks.c **** 						}
4400:../../Source/tasks.c **** 						#else
4401:../../Source/tasks.c **** 						{
4402:../../Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4403:../../Source/tasks.c **** 							printf() library can be used. */
4404:../../Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4405:../../Source/tasks.c **** 						}
4406:../../Source/tasks.c **** 						#endif
4407:../../Source/tasks.c **** 					}
4408:../../Source/tasks.c **** 					else
4409:../../Source/tasks.c **** 					{
4410:../../Source/tasks.c **** 						/* If the percentage is zero here then the task has
4411:../../Source/tasks.c **** 						consumed less than 1% of the total run time. */
4412:../../Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4413:../../Source/tasks.c **** 						{
4414:../../Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4415:../../Source/tasks.c **** 						}
4416:../../Source/tasks.c **** 						#else
4417:../../Source/tasks.c **** 						{
4418:../../Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4419:../../Source/tasks.c **** 							printf() library can be used. */
4420:../../Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4421:../../Source/tasks.c **** 						}
4422:../../Source/tasks.c **** 						#endif
4423:../../Source/tasks.c **** 					}
4424:../../Source/tasks.c **** 
4425:../../Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4426:../../Source/tasks.c **** 				}
4427:../../Source/tasks.c **** 			}
4428:../../Source/tasks.c **** 			else
4429:../../Source/tasks.c **** 			{
4430:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4431:../../Source/tasks.c **** 			}
4432:../../Source/tasks.c **** 
4433:../../Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4434:../../Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4435:../../Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4436:../../Source/tasks.c **** 		}
4437:../../Source/tasks.c **** 		else
4438:../../Source/tasks.c **** 		{
4439:../../Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4440:../../Source/tasks.c **** 		}
4441:../../Source/tasks.c **** 	}
4442:../../Source/tasks.c **** 
4443:../../Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4444:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4445:../../Source/tasks.c **** 
4446:../../Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4447:../../Source/tasks.c **** {
4448:../../Source/tasks.c **** TickType_t uxReturn;
4449:../../Source/tasks.c **** 
4450:../../Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4451:../../Source/tasks.c **** 
4452:../../Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4453:../../Source/tasks.c **** 	queues and semaphores. */
4454:../../Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4455:../../Source/tasks.c **** 
4456:../../Source/tasks.c **** 	return uxReturn;
4457:../../Source/tasks.c **** }
4458:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4459:../../Source/tasks.c **** 
4460:../../Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4461:../../Source/tasks.c **** 
4462:../../Source/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4463:../../Source/tasks.c **** 	{
4464:../../Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4465:../../Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4466:../../Source/tasks.c **** 		if( pxCurrentTCB != NULL )
4467:../../Source/tasks.c **** 		{
4468:../../Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4469:../../Source/tasks.c **** 		}
4470:../../Source/tasks.c **** 
4471:../../Source/tasks.c **** 		return pxCurrentTCB;
4472:../../Source/tasks.c **** 	}
4473:../../Source/tasks.c **** 
4474:../../Source/tasks.c **** #endif /* configUSE_MUTEXES */
4475:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4476:../../Source/tasks.c **** 
4477:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4478:../../Source/tasks.c **** 
4479:../../Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4480:../../Source/tasks.c **** 	{
4481:../../Source/tasks.c **** 	uint32_t ulReturn;
4482:../../Source/tasks.c **** 
4483:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4484:../../Source/tasks.c **** 		{
4485:../../Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4486:../../Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4487:../../Source/tasks.c **** 			{
4488:../../Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4489:../../Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4490:../../Source/tasks.c **** 
4491:../../Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4492:../../Source/tasks.c **** 				{
4493:../../Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4494:../../Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4495:../../Source/tasks.c **** 
4496:../../Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4497:../../Source/tasks.c **** 					section (some will yield immediately, others wait until the
4498:../../Source/tasks.c **** 					critical section exits) - but it is not something that
4499:../../Source/tasks.c **** 					application code should ever do. */
4500:../../Source/tasks.c **** 					portYIELD_WITHIN_API();
4501:../../Source/tasks.c **** 				}
4502:../../Source/tasks.c **** 				else
4503:../../Source/tasks.c **** 				{
4504:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4505:../../Source/tasks.c **** 				}
4506:../../Source/tasks.c **** 			}
4507:../../Source/tasks.c **** 			else
4508:../../Source/tasks.c **** 			{
4509:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4510:../../Source/tasks.c **** 			}
4511:../../Source/tasks.c **** 		}
4512:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4513:../../Source/tasks.c **** 
4514:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4515:../../Source/tasks.c **** 		{
4516:../../Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4517:../../Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4518:../../Source/tasks.c **** 
4519:../../Source/tasks.c **** 			if( ulReturn != 0UL )
4520:../../Source/tasks.c **** 			{
4521:../../Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4522:../../Source/tasks.c **** 				{
4523:../../Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4524:../../Source/tasks.c **** 				}
4525:../../Source/tasks.c **** 				else
4526:../../Source/tasks.c **** 				{
4527:../../Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4528:../../Source/tasks.c **** 				}
4529:../../Source/tasks.c **** 			}
4530:../../Source/tasks.c **** 			else
4531:../../Source/tasks.c **** 			{
4532:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4533:../../Source/tasks.c **** 			}
4534:../../Source/tasks.c **** 
4535:../../Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4536:../../Source/tasks.c **** 		}
4537:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4538:../../Source/tasks.c **** 
4539:../../Source/tasks.c **** 		return ulReturn;
4540:../../Source/tasks.c **** 	}
4541:../../Source/tasks.c **** 
4542:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4543:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4544:../../Source/tasks.c **** 
4545:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4546:../../Source/tasks.c **** 
4547:../../Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4548:../../Source/tasks.c **** 	{
4549:../../Source/tasks.c **** 	BaseType_t xReturn;
4550:../../Source/tasks.c **** 
4551:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4552:../../Source/tasks.c **** 		{
4553:../../Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4554:../../Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4555:../../Source/tasks.c **** 			{
4556:../../Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4557:../../Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4558:../../Source/tasks.c **** 				clear the value to zero. */
4559:../../Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4560:../../Source/tasks.c **** 
4561:../../Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4562:../../Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4563:../../Source/tasks.c **** 
4564:../../Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4565:../../Source/tasks.c **** 				{
4566:../../Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4567:../../Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4568:../../Source/tasks.c **** 
4569:../../Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4570:../../Source/tasks.c **** 					section (some will yield immediately, others wait until the
4571:../../Source/tasks.c **** 					critical section exits) - but it is not something that
4572:../../Source/tasks.c **** 					application code should ever do. */
4573:../../Source/tasks.c **** 					portYIELD_WITHIN_API();
4574:../../Source/tasks.c **** 				}
4575:../../Source/tasks.c **** 				else
4576:../../Source/tasks.c **** 				{
4577:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4578:../../Source/tasks.c **** 				}
4579:../../Source/tasks.c **** 			}
4580:../../Source/tasks.c **** 			else
4581:../../Source/tasks.c **** 			{
4582:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4583:../../Source/tasks.c **** 			}
4584:../../Source/tasks.c **** 		}
4585:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4586:../../Source/tasks.c **** 
4587:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4588:../../Source/tasks.c **** 		{
4589:../../Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4590:../../Source/tasks.c **** 
4591:../../Source/tasks.c **** 			if( pulNotificationValue != NULL )
4592:../../Source/tasks.c **** 			{
4593:../../Source/tasks.c **** 				/* Output the current notification value, which may or may not
4594:../../Source/tasks.c **** 				have changed. */
4595:../../Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4596:../../Source/tasks.c **** 			}
4597:../../Source/tasks.c **** 
4598:../../Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4599:../../Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4600:../../Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4601:../../Source/tasks.c **** 			unblocked because of a timeout. */
4602:../../Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4603:../../Source/tasks.c **** 			{
4604:../../Source/tasks.c **** 				/* A notification was not received. */
4605:../../Source/tasks.c **** 				xReturn = pdFALSE;
4606:../../Source/tasks.c **** 			}
4607:../../Source/tasks.c **** 			else
4608:../../Source/tasks.c **** 			{
4609:../../Source/tasks.c **** 				/* A notification was already pending or a notification was
4610:../../Source/tasks.c **** 				received while the task was waiting. */
4611:../../Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4612:../../Source/tasks.c **** 				xReturn = pdTRUE;
4613:../../Source/tasks.c **** 			}
4614:../../Source/tasks.c **** 
4615:../../Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4616:../../Source/tasks.c **** 		}
4617:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4618:../../Source/tasks.c **** 
4619:../../Source/tasks.c **** 		return xReturn;
4620:../../Source/tasks.c **** 	}
4621:../../Source/tasks.c **** 
4622:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4623:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4624:../../Source/tasks.c **** 
4625:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4626:../../Source/tasks.c **** 
4627:../../Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4628:../../Source/tasks.c **** 	{
4629:../../Source/tasks.c **** 	TCB_t * pxTCB;
4630:../../Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4631:../../Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4632:../../Source/tasks.c **** 
4633:../../Source/tasks.c **** 		configASSERT( xTaskToNotify );
4634:../../Source/tasks.c **** 		pxTCB = xTaskToNotify;
4635:../../Source/tasks.c **** 
4636:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4637:../../Source/tasks.c **** 		{
4638:../../Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4639:../../Source/tasks.c **** 			{
4640:../../Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4641:../../Source/tasks.c **** 			}
4642:../../Source/tasks.c **** 
4643:../../Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4644:../../Source/tasks.c **** 
4645:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4646:../../Source/tasks.c **** 
4647:../../Source/tasks.c **** 			switch( eAction )
4648:../../Source/tasks.c **** 			{
4649:../../Source/tasks.c **** 				case eSetBits	:
4650:../../Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4651:../../Source/tasks.c **** 					break;
4652:../../Source/tasks.c **** 
4653:../../Source/tasks.c **** 				case eIncrement	:
4654:../../Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4655:../../Source/tasks.c **** 					break;
4656:../../Source/tasks.c **** 
4657:../../Source/tasks.c **** 				case eSetValueWithOverwrite	:
4658:../../Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4659:../../Source/tasks.c **** 					break;
4660:../../Source/tasks.c **** 
4661:../../Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4662:../../Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4663:../../Source/tasks.c **** 					{
4664:../../Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4665:../../Source/tasks.c **** 					}
4666:../../Source/tasks.c **** 					else
4667:../../Source/tasks.c **** 					{
4668:../../Source/tasks.c **** 						/* The value could not be written to the task. */
4669:../../Source/tasks.c **** 						xReturn = pdFAIL;
4670:../../Source/tasks.c **** 					}
4671:../../Source/tasks.c **** 					break;
4672:../../Source/tasks.c **** 
4673:../../Source/tasks.c **** 				case eNoAction:
4674:../../Source/tasks.c **** 					/* The task is being notified without its notify value being
4675:../../Source/tasks.c **** 					updated. */
4676:../../Source/tasks.c **** 					break;
4677:../../Source/tasks.c **** 
4678:../../Source/tasks.c **** 				default:
4679:../../Source/tasks.c **** 					/* Should not get here if all enums are handled.
4680:../../Source/tasks.c **** 					Artificially force an assert by testing a value the
4681:../../Source/tasks.c **** 					compiler can't assume is const. */
4682:../../Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4683:../../Source/tasks.c **** 
4684:../../Source/tasks.c **** 					break;
4685:../../Source/tasks.c **** 			}
4686:../../Source/tasks.c **** 
4687:../../Source/tasks.c **** 			traceTASK_NOTIFY();
4688:../../Source/tasks.c **** 
4689:../../Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4690:../../Source/tasks.c **** 			notification then unblock it now. */
4691:../../Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4692:../../Source/tasks.c **** 			{
4693:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4694:../../Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4695:../../Source/tasks.c **** 
4696:../../Source/tasks.c **** 				/* The task should not have been on an event list. */
4697:../../Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4698:../../Source/tasks.c **** 
4699:../../Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4700:../../Source/tasks.c **** 				{
4701:../../Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4702:../../Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4703:../../Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4704:../../Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4705:../../Source/tasks.c **** 					because it will automatically get reset to a new value when
4706:../../Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4707:../../Source/tasks.c **** 					tickless idling is used it might be more important to enter
4708:../../Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4709:../../Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4710:../../Source/tasks.c **** 					earliest possible time. */
4711:../../Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4712:../../Source/tasks.c **** 				}
4713:../../Source/tasks.c **** 				#endif
4714:../../Source/tasks.c **** 
4715:../../Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4716:../../Source/tasks.c **** 				{
4717:../../Source/tasks.c **** 					/* The notified task has a priority above the currently
4718:../../Source/tasks.c **** 					executing task so a yield is required. */
4719:../../Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4720:../../Source/tasks.c **** 				}
4721:../../Source/tasks.c **** 				else
4722:../../Source/tasks.c **** 				{
4723:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4724:../../Source/tasks.c **** 				}
4725:../../Source/tasks.c **** 			}
4726:../../Source/tasks.c **** 			else
4727:../../Source/tasks.c **** 			{
4728:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4729:../../Source/tasks.c **** 			}
4730:../../Source/tasks.c **** 		}
4731:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4732:../../Source/tasks.c **** 
4733:../../Source/tasks.c **** 		return xReturn;
4734:../../Source/tasks.c **** 	}
4735:../../Source/tasks.c **** 
4736:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4737:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4738:../../Source/tasks.c **** 
4739:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4740:../../Source/tasks.c **** 
4741:../../Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4742:../../Source/tasks.c **** 	{
4743:../../Source/tasks.c **** 	TCB_t * pxTCB;
4744:../../Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4745:../../Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4746:../../Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4747:../../Source/tasks.c **** 
4748:../../Source/tasks.c **** 		configASSERT( xTaskToNotify );
4749:../../Source/tasks.c **** 
4750:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4751:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4752:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4753:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4754:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4755:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4756:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4757:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4758:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4759:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4760:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4761:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4762:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4763:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4764:../../Source/tasks.c **** 		provided on the following link:
4765:../../Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4766:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4767:../../Source/tasks.c **** 
4768:../../Source/tasks.c **** 		pxTCB = xTaskToNotify;
4769:../../Source/tasks.c **** 
4770:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4771:../../Source/tasks.c **** 		{
4772:../../Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4773:../../Source/tasks.c **** 			{
4774:../../Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4775:../../Source/tasks.c **** 			}
4776:../../Source/tasks.c **** 
4777:../../Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4778:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4779:../../Source/tasks.c **** 
4780:../../Source/tasks.c **** 			switch( eAction )
4781:../../Source/tasks.c **** 			{
4782:../../Source/tasks.c **** 				case eSetBits	:
4783:../../Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4784:../../Source/tasks.c **** 					break;
4785:../../Source/tasks.c **** 
4786:../../Source/tasks.c **** 				case eIncrement	:
4787:../../Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4788:../../Source/tasks.c **** 					break;
4789:../../Source/tasks.c **** 
4790:../../Source/tasks.c **** 				case eSetValueWithOverwrite	:
4791:../../Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4792:../../Source/tasks.c **** 					break;
4793:../../Source/tasks.c **** 
4794:../../Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4795:../../Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4796:../../Source/tasks.c **** 					{
4797:../../Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4798:../../Source/tasks.c **** 					}
4799:../../Source/tasks.c **** 					else
4800:../../Source/tasks.c **** 					{
4801:../../Source/tasks.c **** 						/* The value could not be written to the task. */
4802:../../Source/tasks.c **** 						xReturn = pdFAIL;
4803:../../Source/tasks.c **** 					}
4804:../../Source/tasks.c **** 					break;
4805:../../Source/tasks.c **** 
4806:../../Source/tasks.c **** 				case eNoAction :
4807:../../Source/tasks.c **** 					/* The task is being notified without its notify value being
4808:../../Source/tasks.c **** 					updated. */
4809:../../Source/tasks.c **** 					break;
4810:../../Source/tasks.c **** 
4811:../../Source/tasks.c **** 				default:
4812:../../Source/tasks.c **** 					/* Should not get here if all enums are handled.
4813:../../Source/tasks.c **** 					Artificially force an assert by testing a value the
4814:../../Source/tasks.c **** 					compiler can't assume is const. */
4815:../../Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4816:../../Source/tasks.c **** 					break;
4817:../../Source/tasks.c **** 			}
4818:../../Source/tasks.c **** 
4819:../../Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4820:../../Source/tasks.c **** 
4821:../../Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4822:../../Source/tasks.c **** 			notification then unblock it now. */
4823:../../Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4824:../../Source/tasks.c **** 			{
4825:../../Source/tasks.c **** 				/* The task should not have been on an event list. */
4826:../../Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4827:../../Source/tasks.c **** 
4828:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4829:../../Source/tasks.c **** 				{
4830:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4831:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4832:../../Source/tasks.c **** 				}
4833:../../Source/tasks.c **** 				else
4834:../../Source/tasks.c **** 				{
4835:../../Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4836:../../Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4837:../../Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4838:../../Source/tasks.c **** 				}
4839:../../Source/tasks.c **** 
4840:../../Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4841:../../Source/tasks.c **** 				{
4842:../../Source/tasks.c **** 					/* The notified task has a priority above the currently
4843:../../Source/tasks.c **** 					executing task so a yield is required. */
4844:../../Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4845:../../Source/tasks.c **** 					{
4846:../../Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4847:../../Source/tasks.c **** 					}
4848:../../Source/tasks.c **** 
4849:../../Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4850:../../Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
4851:../../Source/tasks.c **** 					safe FreeRTOS function. */
4852:../../Source/tasks.c **** 					xYieldPending = pdTRUE;
4853:../../Source/tasks.c **** 				}
4854:../../Source/tasks.c **** 				else
4855:../../Source/tasks.c **** 				{
4856:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4857:../../Source/tasks.c **** 				}
4858:../../Source/tasks.c **** 			}
4859:../../Source/tasks.c **** 		}
4860:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4861:../../Source/tasks.c **** 
4862:../../Source/tasks.c **** 		return xReturn;
4863:../../Source/tasks.c **** 	}
4864:../../Source/tasks.c **** 
4865:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4866:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4867:../../Source/tasks.c **** 
4868:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4869:../../Source/tasks.c **** 
4870:../../Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4871:../../Source/tasks.c **** 	{
4872:../../Source/tasks.c **** 	TCB_t * pxTCB;
4873:../../Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4874:../../Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4875:../../Source/tasks.c **** 
4876:../../Source/tasks.c **** 		configASSERT( xTaskToNotify );
4877:../../Source/tasks.c **** 
4878:../../Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4879:../../Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4880:../../Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4881:../../Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4882:../../Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4883:../../Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4884:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4885:../../Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4886:../../Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4887:../../Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4888:../../Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4889:../../Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4890:../../Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4891:../../Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4892:../../Source/tasks.c **** 		provided on the following link:
4893:../../Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4894:../../Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4895:../../Source/tasks.c **** 
4896:../../Source/tasks.c **** 		pxTCB = xTaskToNotify;
4897:../../Source/tasks.c **** 
4898:../../Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4899:../../Source/tasks.c **** 		{
4900:../../Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4901:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4902:../../Source/tasks.c **** 
4903:../../Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4904:../../Source/tasks.c **** 			semaphore. */
4905:../../Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
4906:../../Source/tasks.c **** 
4907:../../Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4908:../../Source/tasks.c **** 
4909:../../Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4910:../../Source/tasks.c **** 			notification then unblock it now. */
4911:../../Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4912:../../Source/tasks.c **** 			{
4913:../../Source/tasks.c **** 				/* The task should not have been on an event list. */
4914:../../Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4915:../../Source/tasks.c **** 
4916:../../Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4917:../../Source/tasks.c **** 				{
4918:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4919:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4920:../../Source/tasks.c **** 				}
4921:../../Source/tasks.c **** 				else
4922:../../Source/tasks.c **** 				{
4923:../../Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4924:../../Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4925:../../Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4926:../../Source/tasks.c **** 				}
4927:../../Source/tasks.c **** 
4928:../../Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4929:../../Source/tasks.c **** 				{
4930:../../Source/tasks.c **** 					/* The notified task has a priority above the currently
4931:../../Source/tasks.c **** 					executing task so a yield is required. */
4932:../../Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4933:../../Source/tasks.c **** 					{
4934:../../Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4935:../../Source/tasks.c **** 					}
4936:../../Source/tasks.c **** 
4937:../../Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4938:../../Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
4939:../../Source/tasks.c **** 					safe FreeRTOS function. */
4940:../../Source/tasks.c **** 					xYieldPending = pdTRUE;
4941:../../Source/tasks.c **** 				}
4942:../../Source/tasks.c **** 				else
4943:../../Source/tasks.c **** 				{
4944:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4945:../../Source/tasks.c **** 				}
4946:../../Source/tasks.c **** 			}
4947:../../Source/tasks.c **** 		}
4948:../../Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4949:../../Source/tasks.c **** 	}
4950:../../Source/tasks.c **** 
4951:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4952:../../Source/tasks.c **** 
4953:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4954:../../Source/tasks.c **** 
4955:../../Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4956:../../Source/tasks.c **** 
4957:../../Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4958:../../Source/tasks.c **** 	{
4959:../../Source/tasks.c **** 	TCB_t *pxTCB;
4960:../../Source/tasks.c **** 	BaseType_t xReturn;
4961:../../Source/tasks.c **** 
4962:../../Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4963:../../Source/tasks.c **** 		its notification state cleared. */
4964:../../Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
4965:../../Source/tasks.c **** 
4966:../../Source/tasks.c **** 		taskENTER_CRITICAL();
4967:../../Source/tasks.c **** 		{
4968:../../Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
4969:../../Source/tasks.c **** 			{
4970:../../Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4971:../../Source/tasks.c **** 				xReturn = pdPASS;
4972:../../Source/tasks.c **** 			}
4973:../../Source/tasks.c **** 			else
4974:../../Source/tasks.c **** 			{
4975:../../Source/tasks.c **** 				xReturn = pdFAIL;
4976:../../Source/tasks.c **** 			}
4977:../../Source/tasks.c **** 		}
4978:../../Source/tasks.c **** 		taskEXIT_CRITICAL();
4979:../../Source/tasks.c **** 
4980:../../Source/tasks.c **** 		return xReturn;
4981:../../Source/tasks.c **** 	}
4982:../../Source/tasks.c **** 
4983:../../Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4984:../../Source/tasks.c **** /*-----------------------------------------------------------*/
4985:../../Source/tasks.c **** 
4986:../../Source/tasks.c **** 
4987:../../Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
  62               		.loc 1 4987 0
  63               		.cfi_startproc
  64               	.LVL4:
  65 0036 0F93      		push r16
  66               	.LCFI0:
  67               		.cfi_def_cfa_offset 4
  68               		.cfi_offset 16, -3
  69 0038 1F93      		push r17
  70               	.LCFI1:
  71               		.cfi_def_cfa_offset 5
  72               		.cfi_offset 17, -4
  73 003a CF93      		push r28
  74               	.LCFI2:
  75               		.cfi_def_cfa_offset 6
  76               		.cfi_offset 28, -5
  77 003c DF93      		push r29
  78               	.LCFI3:
  79               		.cfi_def_cfa_offset 7
  80               		.cfi_offset 29, -6
  81               	/* prologue: function */
  82               	/* frame size = 0 */
  83               	/* stack size = 4 */
  84               	.L__stack_usage = 4
  85 003e EC01      		movw r28,r24
  86               	.LVL5:
4988:../../Source/tasks.c **** {
4989:../../Source/tasks.c **** TickType_t xTimeToWake;
4990:../../Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
  87               		.loc 1 4990 0
  88 0040 0091 0000 		lds r16,xTickCount
  89 0044 1091 0000 		lds r17,xTickCount+1
  90               	.LVL6:
4991:../../Source/tasks.c **** 
4992:../../Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4993:../../Source/tasks.c **** 	{
4994:../../Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4995:../../Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4996:../../Source/tasks.c **** 		when the task leaves the Blocked state. */
4997:../../Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4998:../../Source/tasks.c **** 	}
4999:../../Source/tasks.c **** 	#endif
5000:../../Source/tasks.c **** 
5001:../../Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5002:../../Source/tasks.c **** 	as the same list item is used for both lists. */
5003:../../Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  91               		.loc 1 5003 0
  92 0048 8091 0000 		lds r24,pxCurrentTCB
  93 004c 9091 0000 		lds r25,pxCurrentTCB+1
  94               	.LVL7:
  95 0050 0296      		adiw r24,2
  96 0052 0E94 0000 		call uxListRemove
  97               	.LVL8:
5004:../../Source/tasks.c **** 	{
5005:../../Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5006:../../Source/tasks.c **** 		check, and the port reset macro can be called directly. */
5007:../../Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
5008:../../Source/tasks.c **** 	}
5009:../../Source/tasks.c **** 	else
5010:../../Source/tasks.c **** 	{
5011:../../Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5012:../../Source/tasks.c **** 	}
5013:../../Source/tasks.c **** 
5014:../../Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5015:../../Source/tasks.c **** 	{
5016:../../Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
5017:../../Source/tasks.c **** 		{
5018:../../Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5019:../../Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5020:../../Source/tasks.c **** 			indefinitely. */
5021:../../Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
5022:../../Source/tasks.c **** 		}
5023:../../Source/tasks.c **** 		else
5024:../../Source/tasks.c **** 		{
5025:../../Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5026:../../Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5027:../../Source/tasks.c **** 			kernel will manage it correctly. */
5028:../../Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
5029:../../Source/tasks.c **** 
5030:../../Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
5031:../../Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5032:../../Source/tasks.c **** 
5033:../../Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
5034:../../Source/tasks.c **** 			{
5035:../../Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5036:../../Source/tasks.c **** 				list. */
5037:../../Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5038:../../Source/tasks.c **** 			}
5039:../../Source/tasks.c **** 			else
5040:../../Source/tasks.c **** 			{
5041:../../Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5042:../../Source/tasks.c **** 				is used. */
5043:../../Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5044:../../Source/tasks.c **** 
5045:../../Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
5046:../../Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5047:../../Source/tasks.c **** 				needs to be updated too. */
5048:../../Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
5049:../../Source/tasks.c **** 				{
5050:../../Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
5051:../../Source/tasks.c **** 				}
5052:../../Source/tasks.c **** 				else
5053:../../Source/tasks.c **** 				{
5054:../../Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5055:../../Source/tasks.c **** 				}
5056:../../Source/tasks.c **** 			}
5057:../../Source/tasks.c **** 		}
5058:../../Source/tasks.c **** 	}
5059:../../Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
5060:../../Source/tasks.c **** 	{
5061:../../Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
5062:../../Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
5063:../../Source/tasks.c **** 		will manage it correctly. */
5064:../../Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
  98               		.loc 1 5064 0
  99 0056 C00F      		add r28,r16
 100 0058 D11F      		adc r29,r17
 101               	.LVL9:
5065:../../Source/tasks.c **** 
5066:../../Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
5067:../../Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 102               		.loc 1 5067 0
 103 005a E091 0000 		lds r30,pxCurrentTCB
 104 005e F091 0000 		lds r31,pxCurrentTCB+1
 105 0062 D383      		std Z+3,r29
 106 0064 C283      		std Z+2,r28
 107               	.LBB8:
 108               	.LBB9:
5068:../../Source/tasks.c **** 
5069:../../Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
5070:../../Source/tasks.c **** 		{
5071:../../Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
5072:../../Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 109               		.loc 1 5072 0
 110 0066 6091 0000 		lds r22,pxCurrentTCB
 111 006a 7091 0000 		lds r23,pxCurrentTCB+1
 112               	.LBE9:
 113               	.LBE8:
5069:../../Source/tasks.c **** 		{
 114               		.loc 1 5069 0
 115 006e C017      		cp r28,r16
 116 0070 D107      		cpc r29,r17
 117 0072 00F4      		brsh .L7
 118               	.LVL10:
 119               	.LBB12:
 120               	.LBB10:
 121               		.loc 1 5072 0
 122 0074 8091 0000 		lds r24,pxOverflowDelayedTaskList
 123 0078 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 124 007c 6E5F      		subi r22,-2
 125 007e 7F4F      		sbci r23,-1
 126               	/* epilogue start */
 127               	.LBE10:
 128               	.LBE12:
5073:../../Source/tasks.c **** 		}
5074:../../Source/tasks.c **** 		else
5075:../../Source/tasks.c **** 		{
5076:../../Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
5077:../../Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5078:../../Source/tasks.c **** 
5079:../../Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5080:../../Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5081:../../Source/tasks.c **** 			too. */
5082:../../Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5083:../../Source/tasks.c **** 			{
5084:../../Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5085:../../Source/tasks.c **** 			}
5086:../../Source/tasks.c **** 			else
5087:../../Source/tasks.c **** 			{
5088:../../Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5089:../../Source/tasks.c **** 			}
5090:../../Source/tasks.c **** 		}
5091:../../Source/tasks.c **** 
5092:../../Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5093:../../Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5094:../../Source/tasks.c **** 	}
5095:../../Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5096:../../Source/tasks.c **** }
 129               		.loc 1 5096 0
 130 0080 DF91      		pop r29
 131 0082 CF91      		pop r28
 132               	.LVL11:
 133 0084 1F91      		pop r17
 134 0086 0F91      		pop r16
 135               	.LVL12:
 136               	.LBB13:
 137               	.LBB11:
5072:../../Source/tasks.c **** 		}
 138               		.loc 1 5072 0
 139 0088 0C94 0000 		jmp vListInsert
 140               	.LVL13:
 141               	.L7:
 142               	.LBE11:
 143               	.LBE13:
5077:../../Source/tasks.c **** 
 144               		.loc 1 5077 0
 145 008c 8091 0000 		lds r24,pxDelayedTaskList
 146 0090 9091 0000 		lds r25,pxDelayedTaskList+1
 147 0094 6E5F      		subi r22,-2
 148 0096 7F4F      		sbci r23,-1
 149 0098 0E94 0000 		call vListInsert
 150               	.LVL14:
5082:../../Source/tasks.c **** 			{
 151               		.loc 1 5082 0
 152 009c 8091 0000 		lds r24,xNextTaskUnblockTime
 153 00a0 9091 0000 		lds r25,xNextTaskUnblockTime+1
 154 00a4 C817      		cp r28,r24
 155 00a6 D907      		cpc r29,r25
 156 00a8 00F4      		brsh .L6
5084:../../Source/tasks.c **** 			}
 157               		.loc 1 5084 0
 158 00aa D093 0000 		sts xNextTaskUnblockTime+1,r29
 159 00ae C093 0000 		sts xNextTaskUnblockTime,r28
 160               	.L6:
 161               	/* epilogue start */
 162               		.loc 1 5096 0
 163 00b2 DF91      		pop r29
 164 00b4 CF91      		pop r28
 165               	.LVL15:
 166 00b6 1F91      		pop r17
 167 00b8 0F91      		pop r16
 168               	.LVL16:
 169 00ba 0895      		ret
 170               		.cfi_endproc
 171               	.LFE43:
 173               		.section	.lowtext,"ax",@progbits
 175               	prvIdleTask:
 176               	.LFB28:
3288:../../Source/tasks.c **** 	/* Stop warnings. */
 177               		.loc 1 3288 0
 178               		.cfi_startproc
 179               	.LVL17:
 180               	/* prologue: function */
 181               	/* frame size = 0 */
 182               	/* stack size = 0 */
 183               	.L__stack_usage = 0
 184               	.L10:
 185               	.LBB20:
 186               	.LBB21:
3542:../../Source/tasks.c **** 		{
 187               		.loc 1 3542 0
 188 0000 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 189 0004 8823      		tst r24
 190 0006 01F0      		breq .L14
3544:../../Source/tasks.c **** 			{
 191               		.loc 1 3544 0
 192               	/* #APP */
 193               	 ;  3544 "../../Source/tasks.c" 1
 194 0008 0FB6      		in __tmp_reg__, __SREG__
 195 000a F894      		cli
 196 000c 0F92      		push __tmp_reg__
 197               		
 198               	 ;  0 "" 2
3546:../../Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 199               		.loc 1 3546 0
 200               	/* #NOAPP */
 201 000e E091 0000 		lds r30,xTasksWaitingTermination+5
 202 0012 F091 0000 		lds r31,xTasksWaitingTermination+5+1
 203 0016 C681      		ldd r28,Z+6
 204 0018 D781      		ldd r29,Z+7
 205               	.LVL18:
3547:../../Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 206               		.loc 1 3547 0
 207 001a CE01      		movw r24,r28
 208 001c 0296      		adiw r24,2
 209 001e 0E94 0000 		call uxListRemove
 210               	.LVL19:
3548:../../Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 211               		.loc 1 3548 0
 212 0022 8091 0000 		lds r24,uxCurrentNumberOfTasks
 213 0026 8150      		subi r24,lo8(-(-1))
 214 0028 8093 0000 		sts uxCurrentNumberOfTasks,r24
3549:../../Source/tasks.c **** 			}
 215               		.loc 1 3549 0
 216 002c 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 217 0030 8150      		subi r24,lo8(-(-1))
 218 0032 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
3551:../../Source/tasks.c **** 
 219               		.loc 1 3551 0
 220               	/* #APP */
 221               	 ;  3551 "../../Source/tasks.c" 1
 222 0036 0F90      		pop __tmp_reg__
 223 0038 0FBE      		out __SREG__, __tmp_reg__
 224               		
 225               	 ;  0 "" 2
 226               	.LVL20:
 227               	/* #NOAPP */
 228               	.LBB22:
 229               	.LBB23:
3758:../../Source/tasks.c **** 			vPortFree( pxTCB );
 230               		.loc 1 3758 0
 231 003a 8F89      		ldd r24,Y+23
 232 003c 988D      		ldd r25,Y+24
 233 003e 0E94 0000 		call vPortFree
 234               	.LVL21:
3759:../../Source/tasks.c **** 		}
 235               		.loc 1 3759 0
 236 0042 CE01      		movw r24,r28
 237 0044 0E94 0000 		call vPortFree
 238               	.LVL22:
 239 0048 00C0      		rjmp .L10
 240               	.LVL23:
 241               	.L14:
 242               	.LBE23:
 243               	.LBE22:
 244               	.LBE21:
 245               	.LBE20:
3327:../../Source/tasks.c **** 			{
 246               		.loc 1 3327 0
 247 004a 8091 0000 		lds r24,pxReadyTasksLists
 248 004e 8230      		cpi r24,lo8(2)
 249 0050 00F0      		brlo .L12
3329:../../Source/tasks.c **** 			}
 250               		.loc 1 3329 0
 251 0052 0E94 0000 		call vPortYield
 252               	.LVL24:
 253               	.L12:
 254               	.LBB24:
3347:../../Source/tasks.c **** 		}
 255               		.loc 1 3347 0
 256 0056 0E94 0000 		call vApplicationIdleHook
 257               	.LVL25:
 258               	.LBE24:
3400:../../Source/tasks.c **** }
 259               		.loc 1 3400 0
 260 005a 00C0      		rjmp .L10
 261               		.cfi_endproc
 262               	.LFE28:
 264               		.text
 265               	.global	xTaskCreate
 267               	xTaskCreate:
 268               	.LFB4:
 753:../../Source/tasks.c **** 	TCB_t *pxNewTCB;
 269               		.loc 1 753 0
 270               		.cfi_startproc
 271               	.LVL26:
 272 00bc 3F92      		push r3
 273               	.LCFI4:
 274               		.cfi_def_cfa_offset 4
 275               		.cfi_offset 3, -3
 276 00be 4F92      		push r4
 277               	.LCFI5:
 278               		.cfi_def_cfa_offset 5
 279               		.cfi_offset 4, -4
 280 00c0 5F92      		push r5
 281               	.LCFI6:
 282               		.cfi_def_cfa_offset 6
 283               		.cfi_offset 5, -5
 284 00c2 6F92      		push r6
 285               	.LCFI7:
 286               		.cfi_def_cfa_offset 7
 287               		.cfi_offset 6, -6
 288 00c4 7F92      		push r7
 289               	.LCFI8:
 290               		.cfi_def_cfa_offset 8
 291               		.cfi_offset 7, -7
 292 00c6 8F92      		push r8
 293               	.LCFI9:
 294               		.cfi_def_cfa_offset 9
 295               		.cfi_offset 8, -8
 296 00c8 9F92      		push r9
 297               	.LCFI10:
 298               		.cfi_def_cfa_offset 10
 299               		.cfi_offset 9, -9
 300 00ca AF92      		push r10
 301               	.LCFI11:
 302               		.cfi_def_cfa_offset 11
 303               		.cfi_offset 10, -10
 304 00cc BF92      		push r11
 305               	.LCFI12:
 306               		.cfi_def_cfa_offset 12
 307               		.cfi_offset 11, -11
 308 00ce CF92      		push r12
 309               	.LCFI13:
 310               		.cfi_def_cfa_offset 13
 311               		.cfi_offset 12, -12
 312 00d0 DF92      		push r13
 313               	.LCFI14:
 314               		.cfi_def_cfa_offset 14
 315               		.cfi_offset 13, -13
 316 00d2 EF92      		push r14
 317               	.LCFI15:
 318               		.cfi_def_cfa_offset 15
 319               		.cfi_offset 14, -14
 320 00d4 FF92      		push r15
 321               	.LCFI16:
 322               		.cfi_def_cfa_offset 16
 323               		.cfi_offset 15, -15
 324 00d6 0F93      		push r16
 325               	.LCFI17:
 326               		.cfi_def_cfa_offset 17
 327               		.cfi_offset 16, -16
 328 00d8 1F93      		push r17
 329               	.LCFI18:
 330               		.cfi_def_cfa_offset 18
 331               		.cfi_offset 17, -17
 332 00da CF93      		push r28
 333               	.LCFI19:
 334               		.cfi_def_cfa_offset 19
 335               		.cfi_offset 28, -18
 336 00dc DF93      		push r29
 337               	.LCFI20:
 338               		.cfi_def_cfa_offset 20
 339               		.cfi_offset 29, -19
 340               	/* prologue: function */
 341               	/* frame size = 0 */
 342               	/* stack size = 17 */
 343               	.L__stack_usage = 17
 344 00de 4C01      		movw r8,r24
 345 00e0 162F      		mov r17,r22
 346 00e2 372E      		mov r3,r23
 347 00e4 6A01      		movw r12,r20
 348 00e6 5901      		movw r10,r18
 349               	.LBB32:
 787:../../Source/tasks.c **** 
 350               		.loc 1 787 0
 351 00e8 CA01      		movw r24,r20
 352               	.LVL27:
 353 00ea 0E94 0000 		call pvPortMalloc
 354               	.LVL28:
 355 00ee 2C01      		movw r4,r24
 356               	.LVL29:
 789:../../Source/tasks.c **** 			{
 357               		.loc 1 789 0
 358 00f0 892B      		or r24,r25
 359 00f2 01F4      		brne .+2
 360 00f4 00C0      		rjmp .L16
 792:../../Source/tasks.c **** 
 361               		.loc 1 792 0
 362 00f6 86E2      		ldi r24,lo8(38)
 363 00f8 90E0      		ldi r25,0
 364 00fa 0E94 0000 		call pvPortMalloc
 365               	.LVL30:
 366 00fe EC01      		movw r28,r24
 367               	.LVL31:
 794:../../Source/tasks.c **** 				{
 368               		.loc 1 794 0
 369 0100 892B      		or r24,r25
 370 0102 01F0      		breq .L17
 797:../../Source/tasks.c **** 				}
 371               		.loc 1 797 0
 372 0104 588E      		std Y+24,r5
 373 0106 4F8A      		std Y+23,r4
 374               	.LVL32:
 375               	.LBE32:
 376               	.LBB33:
 377               	.LBB34:
 880:../../Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 378               		.loc 1 880 0
 379 0108 C601      		movw r24,r12
 380               	.LVL33:
 381 010a 0197      		sbiw r24,1
 382 010c 3201      		movw r6,r4
 383 010e 680E      		add r6,r24
 384 0110 791E      		adc r7,r25
 385               	.LVL34:
 386 0112 BE01      		movw r22,r28
 387 0114 675E      		subi r22,-25
 388 0116 7F4F      		sbci r23,-1
 389 0118 E12F      		mov r30,r17
 390 011a F32D      		mov r31,r3
 391 011c CF01      		movw r24,r30
 392 011e 0896      		adiw r24,8
 393 0120 00C0      		rjmp .L18
 394               	.LVL35:
 395               	.L17:
 396               	.LBE34:
 397               	.LBE33:
 398               	.LBB36:
 803:../../Source/tasks.c **** 				}
 399               		.loc 1 803 0
 400 0122 C201      		movw r24,r4
 401               	.LVL36:
 402 0124 0E94 0000 		call vPortFree
 403               	.LVL37:
 404 0128 00C0      		rjmp .L16
 405               	.LVL38:
 406               	.L41:
 407               	.LBE36:
 408               	.LBB37:
 409               	.LBB35:
 908:../../Source/tasks.c **** 	{
 410               		.loc 1 908 0
 411 012a E817      		cp r30,r24
 412 012c F907      		cpc r31,r25
 413 012e 01F0      		breq .L19
 414               	.LVL39:
 415               	.L18:
 416 0130 9F01      		movw r18,r30
 910:../../Source/tasks.c **** 
 417               		.loc 1 910 0
 418 0132 4191      		ld r20,Z+
 419               	.LVL40:
 420 0134 DB01      		movw r26,r22
 421 0136 4D93      		st X+,r20
 422 0138 BD01      		movw r22,r26
 915:../../Source/tasks.c **** 		{
 423               		.loc 1 915 0
 424 013a D901      		movw r26,r18
 425 013c 2C91      		ld r18,X
 426               	.LVL41:
 427 013e 2111      		cpse r18,__zero_reg__
 428 0140 00C0      		rjmp .L41
 429               	.LVL42:
 430               	.L19:
 927:../../Source/tasks.c **** 
 431               		.loc 1 927 0
 432 0142 18A2      		std Y+32,__zero_reg__
 433 0144 0430      		cpi r16,lo8(4)
 434 0146 00F0      		brlo .L20
 435 0148 03E0      		ldi r16,lo8(3)
 436               	.LVL43:
 437               	.L20:
 940:../../Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 438               		.loc 1 940 0
 439 014a 0E8B      		std Y+22,r16
 948:../../Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 440               		.loc 1 948 0
 441 014c 6E01      		movw r12,r28
 442               	.LVL44:
 443 014e B2E0      		ldi r27,2
 444 0150 CB0E      		add r12,r27
 445 0152 D11C      		adc r13,__zero_reg__
 446 0154 C601      		movw r24,r12
 447 0156 0E94 0000 		call vListInitialiseItem
 448               	.LVL45:
 949:../../Source/tasks.c **** 
 449               		.loc 1 949 0
 450 015a CE01      		movw r24,r28
 451 015c 0C96      		adiw r24,12
 452 015e 0E94 0000 		call vListInitialiseItem
 453               	.LVL46:
 953:../../Source/tasks.c **** 
 454               		.loc 1 953 0
 455 0162 D987      		std Y+9,r29
 456 0164 C887      		std Y+8,r28
 956:../../Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 457               		.loc 1 956 0
 458 0166 84E0      		ldi r24,lo8(4)
 459 0168 90E0      		ldi r25,0
 460 016a 801B      		sub r24,r16
 461 016c 9109      		sbc r25,__zero_reg__
 462 016e 9D87      		std Y+13,r25
 463 0170 8C87      		std Y+12,r24
 957:../../Source/tasks.c **** 
 464               		.loc 1 957 0
 465 0172 DB8B      		std Y+19,r29
 466 0174 CA8B      		std Y+18,r28
 999:../../Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 467               		.loc 1 999 0
 468 0176 19A2      		std Y+33,__zero_reg__
 469 0178 1AA2      		std Y+34,__zero_reg__
 470 017a 1BA2      		std Y+35,__zero_reg__
 471 017c 1CA2      		std Y+36,__zero_reg__
1000:../../Source/tasks.c **** 	}
 472               		.loc 1 1000 0
 473 017e 1DA2      		std Y+37,__zero_reg__
1027:../../Source/tasks.c **** 	}
 474               		.loc 1 1027 0
 475 0180 A501      		movw r20,r10
 476 0182 B401      		movw r22,r8
 477 0184 C301      		movw r24,r6
 478 0186 0E94 0000 		call pxPortInitialiseStack
 479               	.LVL47:
 480 018a 9983      		std Y+1,r25
 481 018c 8883      		st Y,r24
1031:../../Source/tasks.c **** 	{
 482               		.loc 1 1031 0
 483 018e E114      		cp r14,__zero_reg__
 484 0190 F104      		cpc r15,__zero_reg__
 485 0192 01F0      		breq .L21
1035:../../Source/tasks.c **** 	}
 486               		.loc 1 1035 0
 487 0194 F701      		movw r30,r14
 488 0196 D183      		std Z+1,r29
 489 0198 C083      		st Z,r28
 490               	.L21:
 491               	.LVL48:
 492               	.LBE35:
 493               	.LBE37:
 494               	.LBB38:
 495               	.LBB39:
1048:../../Source/tasks.c **** 	{
 496               		.loc 1 1048 0
 497               	/* #APP */
 498               	 ;  1048 "../../Source/tasks.c" 1
 499 019a 0FB6      		in __tmp_reg__, __SREG__
 500 019c F894      		cli
 501 019e 0F92      		push __tmp_reg__
 502               		
 503               	 ;  0 "" 2
1050:../../Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 504               		.loc 1 1050 0
 505               	/* #NOAPP */
 506 01a0 8091 0000 		lds r24,uxCurrentNumberOfTasks
 507 01a4 8F5F      		subi r24,lo8(-(1))
 508 01a6 8093 0000 		sts uxCurrentNumberOfTasks,r24
1051:../../Source/tasks.c **** 		{
 509               		.loc 1 1051 0
 510 01aa 8091 0000 		lds r24,pxCurrentTCB
 511 01ae 9091 0000 		lds r25,pxCurrentTCB+1
 512 01b2 892B      		or r24,r25
 513 01b4 01F4      		brne .L22
1055:../../Source/tasks.c **** 
 514               		.loc 1 1055 0
 515 01b6 D093 0000 		sts pxCurrentTCB+1,r29
 516 01ba C093 0000 		sts pxCurrentTCB,r28
1057:../../Source/tasks.c **** 			{
 517               		.loc 1 1057 0
 518 01be 8091 0000 		lds r24,uxCurrentNumberOfTasks
 519 01c2 8130      		cpi r24,lo8(1)
 520 01c4 01F4      		brne .L24
 521               	.LVL49:
 522               	.LBB40:
 523               	.LBB41:
3505:../../Source/tasks.c **** 	}
 524               		.loc 1 3505 0
 525 01c6 80E0      		ldi r24,lo8(pxReadyTasksLists)
 526 01c8 90E0      		ldi r25,hi8(pxReadyTasksLists)
 527 01ca 0E94 0000 		call vListInitialise
 528               	.LVL50:
 529 01ce 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 530 01d0 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 531 01d2 0E94 0000 		call vListInitialise
 532               	.LVL51:
 533 01d6 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 534 01d8 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 535 01da 0E94 0000 		call vListInitialise
 536               	.LVL52:
 537 01de 80E0      		ldi r24,lo8(pxReadyTasksLists+27)
 538 01e0 90E0      		ldi r25,hi8(pxReadyTasksLists+27)
 539 01e2 0E94 0000 		call vListInitialise
 540               	.LVL53:
3508:../../Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 541               		.loc 1 3508 0
 542 01e6 80E0      		ldi r24,lo8(xDelayedTaskList1)
 543 01e8 90E0      		ldi r25,hi8(xDelayedTaskList1)
 544 01ea 0E94 0000 		call vListInitialise
 545               	.LVL54:
3509:../../Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 546               		.loc 1 3509 0
 547 01ee 80E0      		ldi r24,lo8(xDelayedTaskList2)
 548 01f0 90E0      		ldi r25,hi8(xDelayedTaskList2)
 549 01f2 0E94 0000 		call vListInitialise
 550               	.LVL55:
3510:../../Source/tasks.c **** 
 551               		.loc 1 3510 0
 552 01f6 80E0      		ldi r24,lo8(xPendingReadyList)
 553 01f8 90E0      		ldi r25,hi8(xPendingReadyList)
 554 01fa 0E94 0000 		call vListInitialise
 555               	.LVL56:
3514:../../Source/tasks.c **** 	}
 556               		.loc 1 3514 0
 557 01fe 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 558 0200 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 559 0202 0E94 0000 		call vListInitialise
 560               	.LVL57:
3526:../../Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 561               		.loc 1 3526 0
 562 0206 80E0      		ldi r24,lo8(xDelayedTaskList1)
 563 0208 90E0      		ldi r25,hi8(xDelayedTaskList1)
 564 020a 9093 0000 		sts pxDelayedTaskList+1,r25
 565 020e 8093 0000 		sts pxDelayedTaskList,r24
3527:../../Source/tasks.c **** }
 566               		.loc 1 3527 0
 567 0212 80E0      		ldi r24,lo8(xDelayedTaskList2)
 568 0214 90E0      		ldi r25,hi8(xDelayedTaskList2)
 569 0216 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 570 021a 8093 0000 		sts pxOverflowDelayedTaskList,r24
 571 021e 00C0      		rjmp .L24
 572               	.LVL58:
 573               	.L22:
 574               	.LBE41:
 575               	.LBE40:
1074:../../Source/tasks.c **** 			{
 576               		.loc 1 1074 0
 577 0220 8091 0000 		lds r24,xSchedulerRunning
 578 0224 8111      		cpse r24,__zero_reg__
 579 0226 00C0      		rjmp .L24
1076:../../Source/tasks.c **** 				{
 580               		.loc 1 1076 0
 581 0228 E091 0000 		lds r30,pxCurrentTCB
 582 022c F091 0000 		lds r31,pxCurrentTCB+1
 583 0230 9689      		ldd r25,Z+22
 584 0232 8E89      		ldd r24,Y+22
 585 0234 8917      		cp r24,r25
 586 0236 00F0      		brlo .L24
1078:../../Source/tasks.c **** 				}
 587               		.loc 1 1078 0
 588 0238 D093 0000 		sts pxCurrentTCB+1,r29
 589 023c C093 0000 		sts pxCurrentTCB,r28
 590               	.L24:
1091:../../Source/tasks.c **** 
 591               		.loc 1 1091 0
 592 0240 8091 0000 		lds r24,uxTaskNumber
 593 0244 8F5F      		subi r24,lo8(-(1))
 594 0246 8093 0000 		sts uxTaskNumber,r24
1101:../../Source/tasks.c **** 
 595               		.loc 1 1101 0
 596 024a 8E89      		ldd r24,Y+22
 597 024c 9091 0000 		lds r25,uxTopReadyPriority
 598 0250 9817      		cp r25,r24
 599 0252 00F4      		brsh .L26
 600 0254 8093 0000 		sts uxTopReadyPriority,r24
 601               	.L26:
 602 0258 F9E0      		ldi r31,lo8(9)
 603 025a 8F9F      		mul r24,r31
 604 025c C001      		movw r24,r0
 605 025e 1124      		clr __zero_reg__
 606 0260 B601      		movw r22,r12
 607 0262 8050      		subi r24,lo8(-(pxReadyTasksLists))
 608 0264 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 609 0266 0E94 0000 		call vListInsertEnd
 610               	.LVL59:
1105:../../Source/tasks.c **** 
 611               		.loc 1 1105 0
 612               	/* #APP */
 613               	 ;  1105 "../../Source/tasks.c" 1
 614 026a 0F90      		pop __tmp_reg__
 615 026c 0FBE      		out __SREG__, __tmp_reg__
 616               		
 617               	 ;  0 "" 2
1107:../../Source/tasks.c **** 	{
 618               		.loc 1 1107 0
 619               	/* #NOAPP */
 620 026e 8091 0000 		lds r24,xSchedulerRunning
 621 0272 8823      		tst r24
 622 0274 01F0      		breq .L29
1111:../../Source/tasks.c **** 		{
 623               		.loc 1 1111 0
 624 0276 E091 0000 		lds r30,pxCurrentTCB
 625 027a F091 0000 		lds r31,pxCurrentTCB+1
 626 027e 9689      		ldd r25,Z+22
 627 0280 8E89      		ldd r24,Y+22
 628 0282 9817      		cp r25,r24
 629 0284 00F4      		brsh .L29
1113:../../Source/tasks.c **** 		}
 630               		.loc 1 1113 0
 631 0286 0E94 0000 		call vPortYield
 632               	.LVL60:
 633               	.L29:
 634               	.LBE39:
 635               	.LBE38:
 825:../../Source/tasks.c **** 		}
 636               		.loc 1 825 0
 637 028a 81E0      		ldi r24,lo8(1)
 638 028c 00C0      		rjmp .L40
 639               	.LVL61:
 640               	.L16:
 829:../../Source/tasks.c **** 		}
 641               		.loc 1 829 0
 642 028e 8FEF      		ldi r24,lo8(-1)
 643               	.LVL62:
 644               	.L40:
 645               	/* epilogue start */
 833:../../Source/tasks.c **** 
 646               		.loc 1 833 0
 647 0290 DF91      		pop r29
 648 0292 CF91      		pop r28
 649 0294 1F91      		pop r17
 650 0296 0F91      		pop r16
 651 0298 FF90      		pop r15
 652 029a EF90      		pop r14
 653               	.LVL63:
 654 029c DF90      		pop r13
 655 029e CF90      		pop r12
 656 02a0 BF90      		pop r11
 657 02a2 AF90      		pop r10
 658               	.LVL64:
 659 02a4 9F90      		pop r9
 660 02a6 8F90      		pop r8
 661               	.LVL65:
 662 02a8 7F90      		pop r7
 663 02aa 6F90      		pop r6
 664 02ac 5F90      		pop r5
 665 02ae 4F90      		pop r4
 666               	.LVL66:
 667 02b0 3F90      		pop r3
 668 02b2 0895      		ret
 669               		.cfi_endproc
 670               	.LFE4:
 672               	.global	vTaskDelete
 674               	vTaskDelete:
 675               	.LFB7:
1130:../../Source/tasks.c **** 	TCB_t *pxTCB;
 676               		.loc 1 1130 0
 677               		.cfi_startproc
 678               	.LVL67:
 679 02b4 0F93      		push r16
 680               	.LCFI21:
 681               		.cfi_def_cfa_offset 4
 682               		.cfi_offset 16, -3
 683 02b6 1F93      		push r17
 684               	.LCFI22:
 685               		.cfi_def_cfa_offset 5
 686               		.cfi_offset 17, -4
 687 02b8 CF93      		push r28
 688               	.LCFI23:
 689               		.cfi_def_cfa_offset 6
 690               		.cfi_offset 28, -5
 691 02ba DF93      		push r29
 692               	.LCFI24:
 693               		.cfi_def_cfa_offset 7
 694               		.cfi_offset 29, -6
 695               	/* prologue: function */
 696               	/* frame size = 0 */
 697               	/* stack size = 4 */
 698               	.L__stack_usage = 4
 699 02bc EC01      		movw r28,r24
1133:../../Source/tasks.c **** 		{
 700               		.loc 1 1133 0
 701               	/* #APP */
 702               	 ;  1133 "../../Source/tasks.c" 1
 703 02be 0FB6      		in __tmp_reg__, __SREG__
 704 02c0 F894      		cli
 705 02c2 0F92      		push __tmp_reg__
 706               		
 707               	 ;  0 "" 2
1137:../../Source/tasks.c **** 
 708               		.loc 1 1137 0
 709               	/* #NOAPP */
 710 02c4 892B      		or r24,r25
 711 02c6 01F4      		brne .L43
1137:../../Source/tasks.c **** 
 712               		.loc 1 1137 0 is_stmt 0 discriminator 1
 713 02c8 C091 0000 		lds r28,pxCurrentTCB
 714 02cc D091 0000 		lds r29,pxCurrentTCB+1
 715               	.LVL68:
 716               	.L43:
1140:../../Source/tasks.c **** 			{
 717               		.loc 1 1140 0 is_stmt 1 discriminator 4
 718 02d0 8E01      		movw r16,r28
 719 02d2 0E5F      		subi r16,-2
 720 02d4 1F4F      		sbci r17,-1
 721 02d6 C801      		movw r24,r16
 722 02d8 0E94 0000 		call uxListRemove
 723               	.LVL69:
1150:../../Source/tasks.c **** 			{
 724               		.loc 1 1150 0 discriminator 4
 725 02dc 8C89      		ldd r24,Y+20
 726 02de 9D89      		ldd r25,Y+21
 727 02e0 892B      		or r24,r25
 728 02e2 01F0      		breq .L44
1152:../../Source/tasks.c **** 			}
 729               		.loc 1 1152 0
 730 02e4 CE01      		movw r24,r28
 731 02e6 0C96      		adiw r24,12
 732 02e8 0E94 0000 		call uxListRemove
 733               	.LVL70:
 734               	.L44:
1163:../../Source/tasks.c **** 
 735               		.loc 1 1163 0
 736 02ec 8091 0000 		lds r24,uxTaskNumber
 737 02f0 8F5F      		subi r24,lo8(-(1))
 738 02f2 8093 0000 		sts uxTaskNumber,r24
1165:../../Source/tasks.c **** 			{
 739               		.loc 1 1165 0
 740 02f6 8091 0000 		lds r24,pxCurrentTCB
 741 02fa 9091 0000 		lds r25,pxCurrentTCB+1
 742 02fe C817      		cp r28,r24
 743 0300 D907      		cpc r29,r25
 744 0302 01F4      		brne .L45
1172:../../Source/tasks.c **** 
 745               		.loc 1 1172 0
 746 0304 B801      		movw r22,r16
 747 0306 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 748 0308 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 749 030a 0E94 0000 		call vListInsertEnd
 750               	.LVL71:
1177:../../Source/tasks.c **** 
 751               		.loc 1 1177 0
 752 030e 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 753 0312 8F5F      		subi r24,lo8(-(1))
 754 0314 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
 755 0318 00C0      		rjmp .L46
 756               	.L45:
1188:../../Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 757               		.loc 1 1188 0
 758 031a 8091 0000 		lds r24,uxCurrentNumberOfTasks
 759 031e 8150      		subi r24,lo8(-(-1))
 760 0320 8093 0000 		sts uxCurrentNumberOfTasks,r24
 761               	.LVL72:
 762               	.LBB44:
 763               	.LBB45:
3758:../../Source/tasks.c **** 			vPortFree( pxTCB );
 764               		.loc 1 3758 0
 765 0324 8F89      		ldd r24,Y+23
 766 0326 988D      		ldd r25,Y+24
 767 0328 0E94 0000 		call vPortFree
 768               	.LVL73:
3759:../../Source/tasks.c **** 		}
 769               		.loc 1 3759 0
 770 032c CE01      		movw r24,r28
 771 032e 0E94 0000 		call vPortFree
 772               	.LVL74:
 773               	.LBE45:
 774               	.LBE44:
1193:../../Source/tasks.c **** 			}
 775               		.loc 1 1193 0
 776 0332 0E94 0000 		call prvResetNextTaskUnblockTime
 777               	.LVL75:
 778               	.L46:
1198:../../Source/tasks.c **** 
 779               		.loc 1 1198 0
 780               	/* #APP */
 781               	 ;  1198 "../../Source/tasks.c" 1
 782 0336 0F90      		pop __tmp_reg__
 783 0338 0FBE      		out __SREG__, __tmp_reg__
 784               		
 785               	 ;  0 "" 2
1202:../../Source/tasks.c **** 		{
 786               		.loc 1 1202 0
 787               	/* #NOAPP */
 788 033a 8091 0000 		lds r24,xSchedulerRunning
 789 033e 8823      		tst r24
 790 0340 01F0      		breq .L42
1204:../../Source/tasks.c **** 			{
 791               		.loc 1 1204 0
 792 0342 8091 0000 		lds r24,pxCurrentTCB
 793 0346 9091 0000 		lds r25,pxCurrentTCB+1
 794 034a C817      		cp r28,r24
 795 034c D907      		cpc r29,r25
 796 034e 01F4      		brne .L42
1207:../../Source/tasks.c **** 			}
 797               		.loc 1 1207 0
 798 0350 0E94 0000 		call vPortYield
 799               	.LVL76:
 800               	.L42:
 801               	/* epilogue start */
1214:../../Source/tasks.c **** 
 802               		.loc 1 1214 0
 803 0354 DF91      		pop r29
 804 0356 CF91      		pop r28
 805               	.LVL77:
 806 0358 1F91      		pop r17
 807 035a 0F91      		pop r16
 808               	.LVL78:
 809 035c 0895      		ret
 810               		.cfi_endproc
 811               	.LFE7:
 813               		.section	.rodata.str1.1,"aMS",@progbits,1
 814               	.LC0:
 815 0000 4944 4C45 		.string	"IDLE"
 815      00
 816               		.text
 817               	.global	vTaskStartScheduler
 819               	vTaskStartScheduler:
 820               	.LFB10:
1940:../../Source/tasks.c **** BaseType_t xReturn;
 821               		.loc 1 1940 0
 822               		.cfi_startproc
 823 035e EF92      		push r14
 824               	.LCFI25:
 825               		.cfi_def_cfa_offset 4
 826               		.cfi_offset 14, -3
 827 0360 FF92      		push r15
 828               	.LCFI26:
 829               		.cfi_def_cfa_offset 5
 830               		.cfi_offset 15, -4
 831 0362 0F93      		push r16
 832               	.LCFI27:
 833               		.cfi_def_cfa_offset 6
 834               		.cfi_offset 16, -5
 835               	/* prologue: function */
 836               	/* frame size = 0 */
 837               	/* stack size = 3 */
 838               	.L__stack_usage = 3
1973:../../Source/tasks.c **** 								configIDLE_TASK_NAME,
 839               		.loc 1 1973 0
 840 0364 80E0      		ldi r24,lo8(xIdleTaskHandle)
 841 0366 E82E      		mov r14,r24
 842 0368 80E0      		ldi r24,hi8(xIdleTaskHandle)
 843 036a F82E      		mov r15,r24
 844 036c 00E0      		ldi r16,0
 845 036e 20E0      		ldi r18,0
 846 0370 30E0      		ldi r19,0
 847 0372 45E5      		ldi r20,lo8(85)
 848 0374 50E0      		ldi r21,0
 849 0376 60E0      		ldi r22,lo8(.LC0)
 850 0378 70E0      		ldi r23,hi8(.LC0)
 851 037a 80E0      		ldi r24,lo8(gs(prvIdleTask))
 852 037c 90E0      		ldi r25,hi8(gs(prvIdleTask))
 853 037e 0E94 0000 		call xTaskCreate
 854               	.LVL79:
1995:../../Source/tasks.c **** 	{
 855               		.loc 1 1995 0
 856 0382 8130      		cpi r24,lo8(1)
 857 0384 01F4      		brne .L54
2011:../../Source/tasks.c **** 
 858               		.loc 1 2011 0
 859               	/* #APP */
 860               	 ;  2011 "../../Source/tasks.c" 1
 861 0386 F894      		cli
 862               	 ;  0 "" 2
2021:../../Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 863               		.loc 1 2021 0
 864               	/* #NOAPP */
 865 0388 2FEF      		ldi r18,lo8(-1)
 866 038a 3FEF      		ldi r19,lo8(-1)
 867 038c 3093 0000 		sts xNextTaskUnblockTime+1,r19
 868 0390 2093 0000 		sts xNextTaskUnblockTime,r18
2022:../../Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 869               		.loc 1 2022 0
 870 0394 8093 0000 		sts xSchedulerRunning,r24
2023:../../Source/tasks.c **** 
 871               		.loc 1 2023 0
 872 0398 1092 0000 		sts xTickCount+1,__zero_reg__
 873 039c 1092 0000 		sts xTickCount,__zero_reg__
 874               	/* epilogue start */
2058:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 875               		.loc 1 2058 0
 876 03a0 0F91      		pop r16
 877 03a2 FF90      		pop r15
 878 03a4 EF90      		pop r14
2037:../../Source/tasks.c **** 		{
 879               		.loc 1 2037 0
 880 03a6 0C94 0000 		jmp xPortStartScheduler
 881               	.LVL80:
 882               	.L54:
 883               	/* epilogue start */
2058:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 884               		.loc 1 2058 0
 885 03aa 0F91      		pop r16
 886 03ac FF90      		pop r15
 887 03ae EF90      		pop r14
 888 03b0 0895      		ret
 889               		.cfi_endproc
 890               	.LFE10:
 892               	.global	vTaskEndScheduler
 894               	vTaskEndScheduler:
 895               	.LFB11:
2062:../../Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 896               		.loc 1 2062 0
 897               		.cfi_startproc
 898               	/* prologue: function */
 899               	/* frame size = 0 */
 900               	/* stack size = 0 */
 901               	.L__stack_usage = 0
2066:../../Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 902               		.loc 1 2066 0
 903               	/* #APP */
 904               	 ;  2066 "../../Source/tasks.c" 1
 905 03b2 F894      		cli
 906               	 ;  0 "" 2
2067:../../Source/tasks.c **** 	vPortEndScheduler();
 907               		.loc 1 2067 0
 908               	/* #NOAPP */
 909 03b4 1092 0000 		sts xSchedulerRunning,__zero_reg__
2068:../../Source/tasks.c **** }
 910               		.loc 1 2068 0
 911 03b8 0C94 0000 		jmp vPortEndScheduler
 912               	.LVL81:
 913               		.cfi_endproc
 914               	.LFE11:
 916               	.global	vTaskSuspendAll
 918               	vTaskSuspendAll:
 919               	.LFB12:
2073:../../Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 920               		.loc 1 2073 0
 921               		.cfi_startproc
 922               	/* prologue: function */
 923               	/* frame size = 0 */
 924               	/* stack size = 0 */
 925               	.L__stack_usage = 0
2078:../../Source/tasks.c **** }
 926               		.loc 1 2078 0
 927 03bc 8091 0000 		lds r24,uxSchedulerSuspended
 928 03c0 8F5F      		subi r24,lo8(-(1))
 929 03c2 8093 0000 		sts uxSchedulerSuspended,r24
 930 03c6 0895      		ret
 931               		.cfi_endproc
 932               	.LFE12:
 934               	.global	xTaskGetTickCount
 936               	xTaskGetTickCount:
 937               	.LFB14:
2256:../../Source/tasks.c **** TickType_t xTicks;
 938               		.loc 1 2256 0
 939               		.cfi_startproc
 940               	/* prologue: function */
 941               	/* frame size = 0 */
 942               	/* stack size = 0 */
 943               	.L__stack_usage = 0
2260:../../Source/tasks.c **** 	{
 944               		.loc 1 2260 0
 945               	/* #APP */
 946               	 ;  2260 "../../Source/tasks.c" 1
 947 03c8 0FB6      		in __tmp_reg__, __SREG__
 948 03ca F894      		cli
 949 03cc 0F92      		push __tmp_reg__
 950               		
 951               	 ;  0 "" 2
2262:../../Source/tasks.c **** 	}
 952               		.loc 1 2262 0
 953               	/* #NOAPP */
 954 03ce 8091 0000 		lds r24,xTickCount
 955 03d2 9091 0000 		lds r25,xTickCount+1
 956               	.LVL82:
2264:../../Source/tasks.c **** 
 957               		.loc 1 2264 0
 958               	/* #APP */
 959               	 ;  2264 "../../Source/tasks.c" 1
 960 03d6 0F90      		pop __tmp_reg__
 961 03d8 0FBE      		out __SREG__, __tmp_reg__
 962               		
 963               	 ;  0 "" 2
2267:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 964               		.loc 1 2267 0
 965               	/* #NOAPP */
 966 03da 0895      		ret
 967               		.cfi_endproc
 968               	.LFE14:
 970               	.global	xTaskGetTickCountFromISR
 972               	xTaskGetTickCountFromISR:
 973               	.LFB15:
2271:../../Source/tasks.c **** TickType_t xReturn;
 974               		.loc 1 2271 0
 975               		.cfi_startproc
 976               	/* prologue: function */
 977               	/* frame size = 0 */
 978               	/* stack size = 0 */
 979               	.L__stack_usage = 0
 980               	.LVL83:
2293:../../Source/tasks.c **** 	}
 981               		.loc 1 2293 0
 982 03dc 8091 0000 		lds r24,xTickCount
 983 03e0 9091 0000 		lds r25,xTickCount+1
 984               	.LVL84:
2298:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 985               		.loc 1 2298 0
 986 03e4 0895      		ret
 987               		.cfi_endproc
 988               	.LFE15:
 990               	.global	uxTaskGetNumberOfTasks
 992               	uxTaskGetNumberOfTasks:
 993               	.LFB16:
2302:../../Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 994               		.loc 1 2302 0
 995               		.cfi_startproc
 996               	/* prologue: function */
 997               	/* frame size = 0 */
 998               	/* stack size = 0 */
 999               	.L__stack_usage = 0
2305:../../Source/tasks.c **** }
 1000               		.loc 1 2305 0
 1001 03e6 8091 0000 		lds r24,uxCurrentNumberOfTasks
2306:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1002               		.loc 1 2306 0
 1003 03ea 0895      		ret
 1004               		.cfi_endproc
 1005               	.LFE16:
 1007               	.global	pcTaskGetName
 1009               	pcTaskGetName:
 1010               	.LFB17:
2310:../../Source/tasks.c **** TCB_t *pxTCB;
 1011               		.loc 1 2310 0
 1012               		.cfi_startproc
 1013               	.LVL85:
 1014               	/* prologue: function */
 1015               	/* frame size = 0 */
 1016               	/* stack size = 0 */
 1017               	.L__stack_usage = 0
2315:../../Source/tasks.c **** 	configASSERT( pxTCB );
 1018               		.loc 1 2315 0
 1019 03ec 0097      		sbiw r24,0
 1020 03ee 01F4      		brne .L62
2315:../../Source/tasks.c **** 	configASSERT( pxTCB );
 1021               		.loc 1 2315 0 is_stmt 0 discriminator 1
 1022 03f0 8091 0000 		lds r24,pxCurrentTCB
 1023 03f4 9091 0000 		lds r25,pxCurrentTCB+1
 1024               	.LVL86:
 1025               	.L62:
2318:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1026               		.loc 1 2318 0 is_stmt 1 discriminator 4
 1027 03f8 4996      		adiw r24,25
 1028               	.LVL87:
 1029 03fa 0895      		ret
 1030               		.cfi_endproc
 1031               	.LFE17:
 1033               	.global	xTaskIncrementTick
 1035               	xTaskIncrementTick:
 1036               	.LFB18:
2637:../../Source/tasks.c **** TCB_t * pxTCB;
 1037               		.loc 1 2637 0
 1038               		.cfi_startproc
 1039 03fc CF92      		push r12
 1040               	.LCFI28:
 1041               		.cfi_def_cfa_offset 4
 1042               		.cfi_offset 12, -3
 1043 03fe DF92      		push r13
 1044               	.LCFI29:
 1045               		.cfi_def_cfa_offset 5
 1046               		.cfi_offset 13, -4
 1047 0400 EF92      		push r14
 1048               	.LCFI30:
 1049               		.cfi_def_cfa_offset 6
 1050               		.cfi_offset 14, -5
 1051 0402 FF92      		push r15
 1052               	.LCFI31:
 1053               		.cfi_def_cfa_offset 7
 1054               		.cfi_offset 15, -6
 1055 0404 0F93      		push r16
 1056               	.LCFI32:
 1057               		.cfi_def_cfa_offset 8
 1058               		.cfi_offset 16, -7
 1059 0406 1F93      		push r17
 1060               	.LCFI33:
 1061               		.cfi_def_cfa_offset 9
 1062               		.cfi_offset 17, -8
 1063 0408 CF93      		push r28
 1064               	.LCFI34:
 1065               		.cfi_def_cfa_offset 10
 1066               		.cfi_offset 28, -9
 1067 040a DF93      		push r29
 1068               	.LCFI35:
 1069               		.cfi_def_cfa_offset 11
 1070               		.cfi_offset 29, -10
 1071               	/* prologue: function */
 1072               	/* frame size = 0 */
 1073               	/* stack size = 8 */
 1074               	.L__stack_usage = 8
 1075               	.LVL88:
2646:../../Source/tasks.c **** 	{
 1076               		.loc 1 2646 0
 1077 040c 8091 0000 		lds r24,uxSchedulerSuspended
 1078 0410 8111      		cpse r24,__zero_reg__
 1079 0412 00C0      		rjmp .L64
 1080               	.LBB46:
2650:../../Source/tasks.c **** 
 1081               		.loc 1 2650 0
 1082 0414 0091 0000 		lds r16,xTickCount
 1083 0418 1091 0000 		lds r17,xTickCount+1
 1084 041c 0F5F      		subi r16,-1
 1085 041e 1F4F      		sbci r17,-1
 1086               	.LVL89:
2654:../../Source/tasks.c **** 
 1087               		.loc 1 2654 0
 1088 0420 1093 0000 		sts xTickCount+1,r17
 1089 0424 0093 0000 		sts xTickCount,r16
2656:../../Source/tasks.c **** 		{
 1090               		.loc 1 2656 0
 1091 0428 0115      		cp r16,__zero_reg__
 1092 042a 1105      		cpc r17,__zero_reg__
 1093 042c 01F4      		brne .L65
 1094               	.LBB47:
2658:../../Source/tasks.c **** 		}
 1095               		.loc 1 2658 0
 1096 042e 8091 0000 		lds r24,pxDelayedTaskList
 1097 0432 9091 0000 		lds r25,pxDelayedTaskList+1
 1098               	.LVL90:
 1099 0436 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1100 043a 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1101 043e 3093 0000 		sts pxDelayedTaskList+1,r19
 1102 0442 2093 0000 		sts pxDelayedTaskList,r18
 1103 0446 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1104 044a 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1105 044e 8091 0000 		lds r24,xNumOfOverflows
 1106               	.LVL91:
 1107 0452 8F5F      		subi r24,lo8(-(1))
 1108 0454 8093 0000 		sts xNumOfOverflows,r24
 1109               	.LVL92:
 1110 0458 0E94 0000 		call prvResetNextTaskUnblockTime
 1111               	.LVL93:
 1112               	.L65:
 1113               	.LBE47:
2669:../../Source/tasks.c **** 		{
 1114               		.loc 1 2669 0
 1115 045c 8091 0000 		lds r24,xNextTaskUnblockTime
 1116 0460 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1117 0464 C0E0      		ldi r28,0
 1118 0466 0817      		cp r16,r24
 1119 0468 1907      		cpc r17,r25
 1120 046a 00F4      		brsh .+2
 1121 046c 00C0      		rjmp .L66
2723:../../Source/tasks.c **** 
 1122               		.loc 1 2723 0
 1123 046e D9E0      		ldi r29,lo8(9)
 1124               	.LVL94:
 1125               	.L67:
2673:../../Source/tasks.c **** 				{
 1126               		.loc 1 2673 0
 1127 0470 E091 0000 		lds r30,pxDelayedTaskList
 1128 0474 F091 0000 		lds r31,pxDelayedTaskList+1
 1129 0478 8081      		ld r24,Z
 1130 047a 8111      		cpse r24,__zero_reg__
 1131 047c 00C0      		rjmp .L68
2680:../../Source/tasks.c **** 					break;
 1132               		.loc 1 2680 0
 1133 047e 8FEF      		ldi r24,lo8(-1)
 1134 0480 9FEF      		ldi r25,lo8(-1)
 1135 0482 00C0      		rjmp .L82
 1136               	.L68:
2689:../../Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1137               		.loc 1 2689 0
 1138 0484 E091 0000 		lds r30,pxDelayedTaskList
 1139 0488 F091 0000 		lds r31,pxDelayedTaskList+1
 1140 048c 0580      		ldd __tmp_reg__,Z+5
 1141 048e F681      		ldd r31,Z+6
 1142 0490 E02D      		mov r30,__tmp_reg__
 1143 0492 E680      		ldd r14,Z+6
 1144 0494 F780      		ldd r15,Z+7
 1145               	.LVL95:
2690:../../Source/tasks.c **** 
 1146               		.loc 1 2690 0
 1147 0496 D701      		movw r26,r14
 1148 0498 1296      		adiw r26,2
 1149 049a 8D91      		ld r24,X+
 1150 049c 9C91      		ld r25,X
 1151 049e 1397      		sbiw r26,2+1
 1152               	.LVL96:
2692:../../Source/tasks.c **** 					{
 1153               		.loc 1 2692 0
 1154 04a0 0817      		cp r16,r24
 1155 04a2 1907      		cpc r17,r25
 1156 04a4 00F4      		brsh .L69
 1157               	.LVL97:
 1158               	.L82:
2699:../../Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 1159               		.loc 1 2699 0
 1160 04a6 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1161 04aa 8093 0000 		sts xNextTaskUnblockTime,r24
2700:../../Source/tasks.c **** 					}
 1162               		.loc 1 2700 0
 1163 04ae 00C0      		rjmp .L66
 1164               	.LVL98:
 1165               	.L69:
2708:../../Source/tasks.c **** 
 1166               		.loc 1 2708 0
 1167 04b0 6701      		movw r12,r14
 1168 04b2 B2E0      		ldi r27,2
 1169 04b4 CB0E      		add r12,r27
 1170 04b6 D11C      		adc r13,__zero_reg__
 1171 04b8 C601      		movw r24,r12
 1172               	.LVL99:
 1173 04ba 0E94 0000 		call uxListRemove
 1174               	.LVL100:
2712:../../Source/tasks.c **** 					{
 1175               		.loc 1 2712 0
 1176 04be F701      		movw r30,r14
 1177 04c0 8489      		ldd r24,Z+20
 1178 04c2 9589      		ldd r25,Z+21
 1179 04c4 892B      		or r24,r25
 1180 04c6 01F0      		breq .L70
2714:../../Source/tasks.c **** 					}
 1181               		.loc 1 2714 0
 1182 04c8 C701      		movw r24,r14
 1183 04ca 0C96      		adiw r24,12
 1184 04cc 0E94 0000 		call uxListRemove
 1185               	.LVL101:
 1186               	.L70:
2723:../../Source/tasks.c **** 
 1187               		.loc 1 2723 0
 1188 04d0 D701      		movw r26,r14
 1189 04d2 5696      		adiw r26,22
 1190 04d4 8C91      		ld r24,X
 1191 04d6 9091 0000 		lds r25,uxTopReadyPriority
 1192 04da 9817      		cp r25,r24
 1193 04dc 00F4      		brsh .L71
2723:../../Source/tasks.c **** 
 1194               		.loc 1 2723 0 is_stmt 0 discriminator 1
 1195 04de 8093 0000 		sts uxTopReadyPriority,r24
 1196               	.L71:
2723:../../Source/tasks.c **** 
 1197               		.loc 1 2723 0 discriminator 3
 1198 04e2 D89F      		mul r29,r24
 1199 04e4 C001      		movw r24,r0
 1200 04e6 1124      		clr __zero_reg__
 1201 04e8 B601      		movw r22,r12
 1202 04ea 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1203 04ec 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1204 04ee 0E94 0000 		call vListInsertEnd
 1205               	.LVL102:
2733:../../Source/tasks.c **** 						{
 1206               		.loc 1 2733 0 is_stmt 1 discriminator 3
 1207 04f2 E091 0000 		lds r30,pxCurrentTCB
 1208 04f6 F091 0000 		lds r31,pxCurrentTCB+1
 1209 04fa D701      		movw r26,r14
 1210 04fc 5696      		adiw r26,22
 1211 04fe 9C91      		ld r25,X
 1212 0500 8689      		ldd r24,Z+22
 1213 0502 9817      		cp r25,r24
 1214 0504 00F4      		brsh .+2
 1215 0506 00C0      		rjmp .L67
2735:../../Source/tasks.c **** 						}
 1216               		.loc 1 2735 0
 1217 0508 C1E0      		ldi r28,lo8(1)
 1218               	.LVL103:
 1219 050a 00C0      		rjmp .L67
 1220               	.LVL104:
 1221               	.L66:
2752:../../Source/tasks.c **** 			{
 1222               		.loc 1 2752 0
 1223 050c E091 0000 		lds r30,pxCurrentTCB
 1224 0510 F091 0000 		lds r31,pxCurrentTCB+1
 1225 0514 E689      		ldd r30,Z+22
 1226 0516 B9E0      		ldi r27,lo8(9)
 1227 0518 EB9F      		mul r30,r27
 1228 051a F001      		movw r30,r0
 1229 051c 1124      		clr __zero_reg__
 1230 051e E050      		subi r30,lo8(-(pxReadyTasksLists))
 1231 0520 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1232 0522 8081      		ld r24,Z
 1233 0524 8230      		cpi r24,lo8(2)
 1234 0526 00F0      		brlo .L73
2754:../../Source/tasks.c **** 			}
 1235               		.loc 1 2754 0
 1236 0528 C1E0      		ldi r28,lo8(1)
 1237               	.LVL105:
 1238 052a 00C0      		rjmp .L73
 1239               	.LVL106:
 1240               	.L64:
 1241               	.LBE46:
2780:../../Source/tasks.c **** 
 1242               		.loc 1 2780 0
 1243 052c 8091 0000 		lds r24,uxPendedTicks
 1244 0530 8F5F      		subi r24,lo8(-(1))
 1245 0532 8093 0000 		sts uxPendedTicks,r24
2640:../../Source/tasks.c **** 
 1246               		.loc 1 2640 0
 1247 0536 C0E0      		ldi r28,0
 1248               	.LVL107:
 1249               	.L73:
2793:../../Source/tasks.c **** 		{
 1250               		.loc 1 2793 0
 1251 0538 8091 0000 		lds r24,xYieldPending
 1252 053c 8111      		cpse r24,__zero_reg__
2795:../../Source/tasks.c **** 		}
 1253               		.loc 1 2795 0
 1254 053e C1E0      		ldi r28,lo8(1)
 1255               	.LVL108:
 1256               	.L74:
2805:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1257               		.loc 1 2805 0
 1258 0540 8C2F      		mov r24,r28
 1259               	/* epilogue start */
 1260 0542 DF91      		pop r29
 1261 0544 CF91      		pop r28
 1262               	.LVL109:
 1263 0546 1F91      		pop r17
 1264 0548 0F91      		pop r16
 1265 054a FF90      		pop r15
 1266 054c EF90      		pop r14
 1267 054e DF90      		pop r13
 1268 0550 CF90      		pop r12
 1269 0552 0895      		ret
 1270               		.cfi_endproc
 1271               	.LFE18:
 1273               	.global	xTaskResumeAll
 1275               	xTaskResumeAll:
 1276               	.LFB13:
2146:../../Source/tasks.c **** TCB_t *pxTCB = NULL;
 1277               		.loc 1 2146 0
 1278               		.cfi_startproc
 1279 0554 EF92      		push r14
 1280               	.LCFI36:
 1281               		.cfi_def_cfa_offset 4
 1282               		.cfi_offset 14, -3
 1283 0556 FF92      		push r15
 1284               	.LCFI37:
 1285               		.cfi_def_cfa_offset 5
 1286               		.cfi_offset 15, -4
 1287 0558 0F93      		push r16
 1288               	.LCFI38:
 1289               		.cfi_def_cfa_offset 6
 1290               		.cfi_offset 16, -5
 1291 055a 1F93      		push r17
 1292               	.LCFI39:
 1293               		.cfi_def_cfa_offset 7
 1294               		.cfi_offset 17, -6
 1295 055c CF93      		push r28
 1296               	.LCFI40:
 1297               		.cfi_def_cfa_offset 8
 1298               		.cfi_offset 28, -7
 1299 055e DF93      		push r29
 1300               	.LCFI41:
 1301               		.cfi_def_cfa_offset 9
 1302               		.cfi_offset 29, -8
 1303               	/* prologue: function */
 1304               	/* frame size = 0 */
 1305               	/* stack size = 6 */
 1306               	.L__stack_usage = 6
 1307               	.LVL110:
2159:../../Source/tasks.c **** 	{
 1308               		.loc 1 2159 0
 1309               	/* #APP */
 1310               	 ;  2159 "../../Source/tasks.c" 1
 1311 0560 0FB6      		in __tmp_reg__, __SREG__
 1312 0562 F894      		cli
 1313 0564 0F92      		push __tmp_reg__
 1314               		
 1315               	 ;  0 "" 2
2161:../../Source/tasks.c **** 
 1316               		.loc 1 2161 0
 1317               	/* #NOAPP */
 1318 0566 8091 0000 		lds r24,uxSchedulerSuspended
 1319 056a 8150      		subi r24,lo8(-(-1))
 1320 056c 8093 0000 		sts uxSchedulerSuspended,r24
2163:../../Source/tasks.c **** 		{
 1321               		.loc 1 2163 0
 1322 0570 8091 0000 		lds r24,uxSchedulerSuspended
 1323 0574 8823      		tst r24
 1324 0576 01F0      		breq .L84
 1325               	.LVL111:
 1326               	.L86:
2148:../../Source/tasks.c **** 
 1327               		.loc 1 2148 0
 1328 0578 80E0      		ldi r24,0
 1329 057a 00C0      		rjmp .L85
 1330               	.LVL112:
 1331               	.L84:
2165:../../Source/tasks.c **** 			{
 1332               		.loc 1 2165 0
 1333 057c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1334 0580 8823      		tst r24
 1335 0582 01F0      		breq .L86
 1336 0584 C0E0      		ldi r28,0
 1337 0586 D0E0      		ldi r29,0
2174:../../Source/tasks.c **** 
 1338               		.loc 1 2174 0
 1339 0588 89E0      		ldi r24,lo8(9)
 1340 058a F82E      		mov r15,r24
2180:../../Source/tasks.c **** 					}
 1341               		.loc 1 2180 0
 1342 058c EE24      		clr r14
 1343 058e E394      		inc r14
 1344               	.LVL113:
 1345               	.L87:
2169:../../Source/tasks.c **** 				{
 1346               		.loc 1 2169 0
 1347 0590 8091 0000 		lds r24,xPendingReadyList
 1348 0594 8823      		tst r24
 1349 0596 01F0      		breq .L111
2171:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1350               		.loc 1 2171 0
 1351 0598 E091 0000 		lds r30,xPendingReadyList+5
 1352 059c F091 0000 		lds r31,xPendingReadyList+5+1
 1353 05a0 C681      		ldd r28,Z+6
 1354 05a2 D781      		ldd r29,Z+7
 1355               	.LVL114:
2172:../../Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1356               		.loc 1 2172 0
 1357 05a4 CE01      		movw r24,r28
 1358 05a6 0C96      		adiw r24,12
 1359 05a8 0E94 0000 		call uxListRemove
 1360               	.LVL115:
2173:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1361               		.loc 1 2173 0
 1362 05ac 8E01      		movw r16,r28
 1363 05ae 0E5F      		subi r16,-2
 1364 05b0 1F4F      		sbci r17,-1
 1365 05b2 C801      		movw r24,r16
 1366 05b4 0E94 0000 		call uxListRemove
 1367               	.LVL116:
2174:../../Source/tasks.c **** 
 1368               		.loc 1 2174 0
 1369 05b8 8E89      		ldd r24,Y+22
 1370 05ba 9091 0000 		lds r25,uxTopReadyPriority
 1371 05be 9817      		cp r25,r24
 1372 05c0 00F4      		brsh .L88
2174:../../Source/tasks.c **** 
 1373               		.loc 1 2174 0 is_stmt 0 discriminator 1
 1374 05c2 8093 0000 		sts uxTopReadyPriority,r24
 1375               	.L88:
2174:../../Source/tasks.c **** 
 1376               		.loc 1 2174 0 discriminator 3
 1377 05c6 F89E      		mul r15,r24
 1378 05c8 C001      		movw r24,r0
 1379 05ca 1124      		clr __zero_reg__
 1380 05cc B801      		movw r22,r16
 1381 05ce 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1382 05d0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1383 05d2 0E94 0000 		call vListInsertEnd
 1384               	.LVL117:
2178:../../Source/tasks.c **** 					{
 1385               		.loc 1 2178 0 is_stmt 1 discriminator 3
 1386 05d6 E091 0000 		lds r30,pxCurrentTCB
 1387 05da F091 0000 		lds r31,pxCurrentTCB+1
 1388 05de 9E89      		ldd r25,Y+22
 1389 05e0 8689      		ldd r24,Z+22
 1390 05e2 9817      		cp r25,r24
 1391 05e4 00F0      		brlo .L87
2180:../../Source/tasks.c **** 					}
 1392               		.loc 1 2180 0
 1393 05e6 E092 0000 		sts xYieldPending,r14
 1394 05ea 00C0      		rjmp .L87
 1395               	.L111:
2188:../../Source/tasks.c **** 				{
 1396               		.loc 1 2188 0
 1397 05ec CD2B      		or r28,r29
 1398 05ee 01F0      		breq .L91
2196:../../Source/tasks.c **** 				}
 1399               		.loc 1 2196 0
 1400 05f0 0E94 0000 		call prvResetNextTaskUnblockTime
 1401               	.LVL118:
 1402               	.L91:
 1403               	.LBB48:
2204:../../Source/tasks.c **** 
 1404               		.loc 1 2204 0
 1405 05f4 C091 0000 		lds r28,uxPendedTicks
 1406               	.LVL119:
2206:../../Source/tasks.c **** 					{
 1407               		.loc 1 2206 0
 1408 05f8 CC23      		tst r28
 1409 05fa 01F0      		breq .L92
2212:../../Source/tasks.c **** 							}
 1410               		.loc 1 2212 0
 1411 05fc D1E0      		ldi r29,lo8(1)
 1412               	.L94:
2210:../../Source/tasks.c **** 							{
 1413               		.loc 1 2210 0
 1414 05fe 0E94 0000 		call xTaskIncrementTick
 1415               	.LVL120:
 1416 0602 8111      		cpse r24,__zero_reg__
2212:../../Source/tasks.c **** 							}
 1417               		.loc 1 2212 0
 1418 0604 D093 0000 		sts xYieldPending,r29
 1419               	.L93:
2218:../../Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 1420               		.loc 1 2218 0
 1421 0608 C150      		subi r28,lo8(-(-1))
 1422               	.LVL121:
2219:../../Source/tasks.c **** 
 1423               		.loc 1 2219 0
 1424 060a 01F4      		brne .L94
2221:../../Source/tasks.c **** 					}
 1425               		.loc 1 2221 0
 1426 060c 1092 0000 		sts uxPendedTicks,__zero_reg__
 1427               	.L92:
 1428               	.LBE48:
2229:../../Source/tasks.c **** 				{
 1429               		.loc 1 2229 0
 1430 0610 8091 0000 		lds r24,xYieldPending
 1431 0614 8823      		tst r24
 1432 0616 01F4      		brne .+2
 1433 0618 00C0      		rjmp .L86
 1434               	.LVL122:
2236:../../Source/tasks.c **** 				}
 1435               		.loc 1 2236 0
 1436 061a 0E94 0000 		call vPortYield
 1437               	.LVL123:
2233:../../Source/tasks.c **** 					}
 1438               		.loc 1 2233 0
 1439 061e 81E0      		ldi r24,lo8(1)
 1440               	.LVL124:
 1441               	.L85:
2249:../../Source/tasks.c **** 
 1442               		.loc 1 2249 0
 1443               	/* #APP */
 1444               	 ;  2249 "../../Source/tasks.c" 1
 1445 0620 0F90      		pop __tmp_reg__
 1446 0622 0FBE      		out __SREG__, __tmp_reg__
 1447               		
 1448               	 ;  0 "" 2
 1449               	/* epilogue start */
2252:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1450               		.loc 1 2252 0
 1451               	/* #NOAPP */
 1452 0624 DF91      		pop r29
 1453 0626 CF91      		pop r28
 1454 0628 1F91      		pop r17
 1455 062a 0F91      		pop r16
 1456 062c FF90      		pop r15
 1457 062e EF90      		pop r14
 1458 0630 0895      		ret
 1459               		.cfi_endproc
 1460               	.LFE13:
 1462               	.global	vTaskDelayUntil
 1464               	vTaskDelayUntil:
 1465               	.LFB8:
1222:../../Source/tasks.c **** 	TickType_t xTimeToWake;
 1466               		.loc 1 1222 0
 1467               		.cfi_startproc
 1468               	.LVL125:
 1469 0632 0F93      		push r16
 1470               	.LCFI42:
 1471               		.cfi_def_cfa_offset 4
 1472               		.cfi_offset 16, -3
 1473 0634 1F93      		push r17
 1474               	.LCFI43:
 1475               		.cfi_def_cfa_offset 5
 1476               		.cfi_offset 17, -4
 1477 0636 CF93      		push r28
 1478               	.LCFI44:
 1479               		.cfi_def_cfa_offset 6
 1480               		.cfi_offset 28, -5
 1481 0638 DF93      		push r29
 1482               	.LCFI45:
 1483               		.cfi_def_cfa_offset 7
 1484               		.cfi_offset 29, -6
 1485               	/* prologue: function */
 1486               	/* frame size = 0 */
 1487               	/* stack size = 4 */
 1488               	.L__stack_usage = 4
 1489 063a 8C01      		movw r16,r24
 1490 063c EB01      		movw r28,r22
 1491               	.LVL126:
1230:../../Source/tasks.c **** 		{
 1492               		.loc 1 1230 0
 1493 063e 0E94 0000 		call vTaskSuspendAll
 1494               	.LVL127:
 1495               	.LBB49:
1234:../../Source/tasks.c **** 
 1496               		.loc 1 1234 0
 1497 0642 4091 0000 		lds r20,xTickCount
 1498 0646 5091 0000 		lds r21,xTickCount+1
 1499               	.LVL128:
1237:../../Source/tasks.c **** 
 1500               		.loc 1 1237 0
 1501 064a F801      		movw r30,r16
 1502 064c 2081      		ld r18,Z
 1503 064e 3181      		ldd r19,Z+1
 1504 0650 C901      		movw r24,r18
 1505 0652 8C0F      		add r24,r28
 1506 0654 9D1F      		adc r25,r29
 1507               	.LVL129:
1239:../../Source/tasks.c **** 			{
 1508               		.loc 1 1239 0
 1509 0656 4217      		cp r20,r18
 1510 0658 5307      		cpc r21,r19
 1511 065a 00F4      		brsh .L113
1246:../../Source/tasks.c **** 				{
 1512               		.loc 1 1246 0
 1513 065c 8217      		cp r24,r18
 1514 065e 9307      		cpc r25,r19
 1515 0660 00F4      		brsh .L119
 1516 0662 00C0      		rjmp .L126
 1517               	.L113:
1260:../../Source/tasks.c **** 				{
 1518               		.loc 1 1260 0
 1519 0664 8217      		cp r24,r18
 1520 0666 9307      		cpc r25,r19
 1521 0668 00F0      		brlo .L120
 1522               	.L126:
 1523               	.LBE49:
1224:../../Source/tasks.c **** 
 1524               		.loc 1 1224 0 discriminator 1
 1525 066a 21E0      		ldi r18,lo8(1)
 1526 066c 4817      		cp r20,r24
 1527 066e 5907      		cpc r21,r25
 1528 0670 00F0      		brlo .L114
 1529               	.L119:
1224:../../Source/tasks.c **** 
 1530               		.loc 1 1224 0 is_stmt 0
 1531 0672 20E0      		ldi r18,0
 1532 0674 00C0      		rjmp .L114
 1533               	.L120:
 1534               	.LBB50:
1262:../../Source/tasks.c **** 				}
 1535               		.loc 1 1262 0 is_stmt 1
 1536 0676 21E0      		ldi r18,lo8(1)
 1537               	.L114:
 1538               	.LVL130:
1271:../../Source/tasks.c **** 
 1539               		.loc 1 1271 0
 1540 0678 F801      		movw r30,r16
 1541 067a 9183      		std Z+1,r25
 1542 067c 8083      		st Z,r24
1273:../../Source/tasks.c **** 			{
 1543               		.loc 1 1273 0
 1544 067e 2223      		tst r18
 1545 0680 01F0      		breq .L117
1279:../../Source/tasks.c **** 			}
 1546               		.loc 1 1279 0
 1547 0682 841B      		sub r24,r20
 1548 0684 950B      		sbc r25,r21
 1549               	.LVL131:
 1550 0686 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
 1551               	.LVL132:
 1552               	.L117:
 1553               	.LBE50:
1286:../../Source/tasks.c **** 
 1554               		.loc 1 1286 0
 1555 068a 0E94 0000 		call xTaskResumeAll
 1556               	.LVL133:
1290:../../Source/tasks.c **** 		{
 1557               		.loc 1 1290 0
 1558 068e 8111      		cpse r24,__zero_reg__
 1559 0690 00C0      		rjmp .L112
1292:../../Source/tasks.c **** 		}
 1560               		.loc 1 1292 0
 1561 0692 0E94 0000 		call vPortYield
 1562               	.LVL134:
 1563               	.L112:
 1564               	/* epilogue start */
1298:../../Source/tasks.c **** 
 1565               		.loc 1 1298 0
 1566 0696 DF91      		pop r29
 1567 0698 CF91      		pop r28
 1568               	.LVL135:
 1569 069a 1F91      		pop r17
 1570 069c 0F91      		pop r16
 1571               	.LVL136:
 1572 069e 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE8:
 1576               	.global	vTaskDelay
 1578               	vTaskDelay:
 1579               	.LFB9:
1306:../../Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 1580               		.loc 1 1306 0
 1581               		.cfi_startproc
 1582               	.LVL137:
 1583 06a0 CF93      		push r28
 1584               	.LCFI46:
 1585               		.cfi_def_cfa_offset 4
 1586               		.cfi_offset 28, -3
 1587 06a2 DF93      		push r29
 1588               	.LCFI47:
 1589               		.cfi_def_cfa_offset 5
 1590               		.cfi_offset 29, -4
 1591               	/* prologue: function */
 1592               	/* frame size = 0 */
 1593               	/* stack size = 2 */
 1594               	.L__stack_usage = 2
 1595 06a4 EC01      		movw r28,r24
 1596               	.LVL138:
1310:../../Source/tasks.c **** 		{
 1597               		.loc 1 1310 0
 1598 06a6 892B      		or r24,r25
 1599 06a8 01F4      		brne .L128
 1600               	.LVL139:
 1601               	.L130:
1337:../../Source/tasks.c **** 		}
 1602               		.loc 1 1337 0
 1603 06aa 0E94 0000 		call vPortYield
 1604               	.LVL140:
 1605 06ae 00C0      		rjmp .L127
 1606               	.LVL141:
 1607               	.L128:
1313:../../Source/tasks.c **** 			{
 1608               		.loc 1 1313 0
 1609 06b0 0E94 0000 		call vTaskSuspendAll
 1610               	.LVL142:
1324:../../Source/tasks.c **** 			}
 1611               		.loc 1 1324 0
 1612 06b4 CE01      		movw r24,r28
 1613 06b6 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
 1614               	.LVL143:
1326:../../Source/tasks.c **** 		}
 1615               		.loc 1 1326 0
 1616 06ba 0E94 0000 		call xTaskResumeAll
 1617               	.LVL144:
1335:../../Source/tasks.c **** 		{
 1618               		.loc 1 1335 0
 1619 06be 8823      		tst r24
 1620 06c0 01F0      		breq .L130
 1621               	.LVL145:
 1622               	.L127:
 1623               	/* epilogue start */
1343:../../Source/tasks.c **** 
 1624               		.loc 1 1343 0
 1625 06c2 DF91      		pop r29
 1626 06c4 CF91      		pop r28
 1627               	.LVL146:
 1628 06c6 0895      		ret
 1629               		.cfi_endproc
 1630               	.LFE9:
 1632               	.global	vTaskSwitchContext
 1634               	vTaskSwitchContext:
 1635               	.LFB19:
2901:../../Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 1636               		.loc 1 2901 0
 1637               		.cfi_startproc
 1638               	/* prologue: function */
 1639               	/* frame size = 0 */
 1640               	/* stack size = 0 */
 1641               	.L__stack_usage = 0
2902:../../Source/tasks.c **** 	{
 1642               		.loc 1 2902 0
 1643 06c8 8091 0000 		lds r24,uxSchedulerSuspended
 1644 06cc 8823      		tst r24
 1645 06ce 01F0      		breq .L135
2906:../../Source/tasks.c **** 	}
 1646               		.loc 1 2906 0
 1647 06d0 81E0      		ldi r24,lo8(1)
 1648 06d2 8093 0000 		sts xYieldPending,r24
 1649 06d6 0895      		ret
 1650               	.L135:
2910:../../Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 1651               		.loc 1 2910 0
 1652 06d8 1092 0000 		sts xYieldPending,__zero_reg__
 1653               	.LBB51:
2952:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1654               		.loc 1 2952 0
 1655 06dc 8091 0000 		lds r24,uxTopReadyPriority
 1656               	.LVL147:
 1657 06e0 69E0      		ldi r22,lo8(9)
 1658               	.L137:
2952:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1659               		.loc 1 2952 0 is_stmt 0 discriminator 1
 1660 06e2 482F      		mov r20,r24
 1661 06e4 50E0      		ldi r21,0
 1662 06e6 649F      		mul r22,r20
 1663 06e8 9001      		movw r18,r0
 1664 06ea 659F      		mul r22,r21
 1665 06ec 300D      		add r19,r0
 1666 06ee 1124      		clr __zero_reg__
 1667 06f0 F901      		movw r30,r18
 1668 06f2 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1669 06f4 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1670 06f6 9081      		ld r25,Z
 1671 06f8 9111      		cpse r25,__zero_reg__
 1672 06fa 00C0      		rjmp .L140
 1673               	.LVL148:
2952:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1674               		.loc 1 2952 0 discriminator 3
 1675 06fc 8150      		subi r24,lo8(-(-1))
 1676               	.LVL149:
 1677 06fe 00C0      		rjmp .L137
 1678               	.LVL150:
 1679               	.L140:
 1680               	.LBB52:
2952:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1681               		.loc 1 2952 0 discriminator 4
 1682 0700 A181      		ldd r26,Z+1
 1683 0702 B281      		ldd r27,Z+2
 1684 0704 1296      		adiw r26,2
 1685 0706 0D90      		ld __tmp_reg__,X+
 1686 0708 BC91      		ld r27,X
 1687 070a A02D      		mov r26,__tmp_reg__
 1688 070c B283      		std Z+2,r27
 1689 070e A183      		std Z+1,r26
 1690 0710 2050      		subi r18,lo8(-(pxReadyTasksLists+3))
 1691 0712 3040      		sbci r19,hi8(-(pxReadyTasksLists+3))
 1692 0714 A217      		cp r26,r18
 1693 0716 B307      		cpc r27,r19
 1694 0718 01F4      		brne .L139
2952:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1695               		.loc 1 2952 0 discriminator 5
 1696 071a 1296      		adiw r26,2
 1697 071c 2D91      		ld r18,X+
 1698 071e 3C91      		ld r19,X
 1699 0720 1397      		sbiw r26,2+1
 1700 0722 3283      		std Z+2,r19
 1701 0724 2183      		std Z+1,r18
 1702               	.L139:
2952:../../Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 1703               		.loc 1 2952 0 discriminator 7
 1704 0726 99E0      		ldi r25,lo8(9)
 1705 0728 949F      		mul r25,r20
 1706 072a F001      		movw r30,r0
 1707 072c 959F      		mul r25,r21
 1708 072e F00D      		add r31,r0
 1709 0730 1124      		clr __zero_reg__
 1710 0732 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1711 0734 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1712 0736 0180      		ldd __tmp_reg__,Z+1
 1713 0738 F281      		ldd r31,Z+2
 1714 073a E02D      		mov r30,__tmp_reg__
 1715 073c 2681      		ldd r18,Z+6
 1716 073e 3781      		ldd r19,Z+7
 1717 0740 3093 0000 		sts pxCurrentTCB+1,r19
 1718 0744 2093 0000 		sts pxCurrentTCB,r18
 1719               	.LBE52:
 1720 0748 8093 0000 		sts uxTopReadyPriority,r24
 1721 074c 0895      		ret
 1722               	.LBE51:
 1723               		.cfi_endproc
 1724               	.LFE19:
 1726               	.global	vTaskPlaceOnEventList
 1728               	vTaskPlaceOnEventList:
 1729               	.LFB20:
2974:../../Source/tasks.c **** 	configASSERT( pxEventList );
 1730               		.loc 1 2974 0 is_stmt 1
 1731               		.cfi_startproc
 1732               	.LVL151:
 1733 074e CF93      		push r28
 1734               	.LCFI48:
 1735               		.cfi_def_cfa_offset 4
 1736               		.cfi_offset 28, -3
 1737 0750 DF93      		push r29
 1738               	.LCFI49:
 1739               		.cfi_def_cfa_offset 5
 1740               		.cfi_offset 29, -4
 1741               	/* prologue: function */
 1742               	/* frame size = 0 */
 1743               	/* stack size = 2 */
 1744               	.L__stack_usage = 2
 1745 0752 EB01      		movw r28,r22
2984:../../Source/tasks.c **** 
 1746               		.loc 1 2984 0
 1747 0754 6091 0000 		lds r22,pxCurrentTCB
 1748 0758 7091 0000 		lds r23,pxCurrentTCB+1
 1749               	.LVL152:
 1750 075c 645F      		subi r22,-12
 1751 075e 7F4F      		sbci r23,-1
 1752 0760 0E94 0000 		call vListInsert
 1753               	.LVL153:
2986:../../Source/tasks.c **** }
 1754               		.loc 1 2986 0
 1755 0764 CE01      		movw r24,r28
 1756               	/* epilogue start */
2987:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1757               		.loc 1 2987 0
 1758 0766 DF91      		pop r29
 1759 0768 CF91      		pop r28
 1760               	.LVL154:
2986:../../Source/tasks.c **** }
 1761               		.loc 1 2986 0
 1762 076a 0C94 0000 		jmp prvAddCurrentTaskToDelayedList.isra.2
 1763               	.LVL155:
 1764               		.cfi_endproc
 1765               	.LFE20:
 1767               	.global	vTaskPlaceOnUnorderedEventList
 1769               	vTaskPlaceOnUnorderedEventList:
 1770               	.LFB21:
2991:../../Source/tasks.c **** 	configASSERT( pxEventList );
 1771               		.loc 1 2991 0
 1772               		.cfi_startproc
 1773               	.LVL156:
 1774 076e CF93      		push r28
 1775               	.LCFI50:
 1776               		.cfi_def_cfa_offset 4
 1777               		.cfi_offset 28, -3
 1778 0770 DF93      		push r29
 1779               	.LCFI51:
 1780               		.cfi_def_cfa_offset 5
 1781               		.cfi_offset 29, -4
 1782               	/* prologue: function */
 1783               	/* frame size = 0 */
 1784               	/* stack size = 2 */
 1785               	.L__stack_usage = 2
 1786 0772 EA01      		movw r28,r20
3001:../../Source/tasks.c **** 
 1787               		.loc 1 3001 0
 1788 0774 E091 0000 		lds r30,pxCurrentTCB
 1789 0778 F091 0000 		lds r31,pxCurrentTCB+1
 1790 077c 7068      		ori r23,128
 1791               	.LVL157:
 1792 077e 7587      		std Z+13,r23
 1793 0780 6487      		std Z+12,r22
3008:../../Source/tasks.c **** 
 1794               		.loc 1 3008 0
 1795 0782 6091 0000 		lds r22,pxCurrentTCB
 1796 0786 7091 0000 		lds r23,pxCurrentTCB+1
 1797 078a 645F      		subi r22,-12
 1798 078c 7F4F      		sbci r23,-1
 1799 078e 0E94 0000 		call vListInsertEnd
 1800               	.LVL158:
3010:../../Source/tasks.c **** }
 1801               		.loc 1 3010 0
 1802 0792 CE01      		movw r24,r28
 1803               	/* epilogue start */
3011:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1804               		.loc 1 3011 0
 1805 0794 DF91      		pop r29
 1806 0796 CF91      		pop r28
 1807               	.LVL159:
3010:../../Source/tasks.c **** }
 1808               		.loc 1 3010 0
 1809 0798 0C94 0000 		jmp prvAddCurrentTaskToDelayedList.isra.2
 1810               	.LVL160:
 1811               		.cfi_endproc
 1812               	.LFE21:
 1814               	.global	xTaskRemoveFromEventList
 1816               	xTaskRemoveFromEventList:
 1817               	.LFB22:
3048:../../Source/tasks.c **** TCB_t *pxUnblockedTCB;
 1818               		.loc 1 3048 0
 1819               		.cfi_startproc
 1820               	.LVL161:
 1821 079c 0F93      		push r16
 1822               	.LCFI52:
 1823               		.cfi_def_cfa_offset 4
 1824               		.cfi_offset 16, -3
 1825 079e 1F93      		push r17
 1826               	.LCFI53:
 1827               		.cfi_def_cfa_offset 5
 1828               		.cfi_offset 17, -4
 1829 07a0 CF93      		push r28
 1830               	.LCFI54:
 1831               		.cfi_def_cfa_offset 6
 1832               		.cfi_offset 28, -5
 1833 07a2 DF93      		push r29
 1834               	.LCFI55:
 1835               		.cfi_def_cfa_offset 7
 1836               		.cfi_offset 29, -6
 1837               	/* prologue: function */
 1838               	/* frame size = 0 */
 1839               	/* stack size = 4 */
 1840               	.L__stack_usage = 4
3065:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 1841               		.loc 1 3065 0
 1842 07a4 DC01      		movw r26,r24
 1843 07a6 1596      		adiw r26,5
 1844 07a8 ED91      		ld r30,X+
 1845 07aa FC91      		ld r31,X
 1846 07ac 1697      		sbiw r26,5+1
 1847 07ae C681      		ldd r28,Z+6
 1848 07b0 D781      		ldd r29,Z+7
 1849               	.LVL162:
3067:../../Source/tasks.c **** 
 1850               		.loc 1 3067 0
 1851 07b2 8E01      		movw r16,r28
 1852 07b4 045F      		subi r16,-12
 1853 07b6 1F4F      		sbci r17,-1
 1854 07b8 C801      		movw r24,r16
 1855               	.LVL163:
 1856 07ba 0E94 0000 		call uxListRemove
 1857               	.LVL164:
3069:../../Source/tasks.c **** 	{
 1858               		.loc 1 3069 0
 1859 07be 8091 0000 		lds r24,uxSchedulerSuspended
 1860 07c2 8111      		cpse r24,__zero_reg__
 1861 07c4 00C0      		rjmp .L144
3071:../../Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 1862               		.loc 1 3071 0
 1863 07c6 0A50      		subi r16,10
 1864 07c8 1109      		sbc r17,__zero_reg__
 1865 07ca C801      		movw r24,r16
 1866 07cc 0E94 0000 		call uxListRemove
 1867               	.LVL165:
3072:../../Source/tasks.c **** 	}
 1868               		.loc 1 3072 0
 1869 07d0 8E89      		ldd r24,Y+22
 1870 07d2 9091 0000 		lds r25,uxTopReadyPriority
 1871 07d6 9817      		cp r25,r24
 1872 07d8 00F4      		brsh .L145
3072:../../Source/tasks.c **** 	}
 1873               		.loc 1 3072 0 is_stmt 0 discriminator 1
 1874 07da 8093 0000 		sts uxTopReadyPriority,r24
 1875               	.L145:
3072:../../Source/tasks.c **** 	}
 1876               		.loc 1 3072 0 discriminator 3
 1877 07de B9E0      		ldi r27,lo8(9)
 1878 07e0 8B9F      		mul r24,r27
 1879 07e2 C001      		movw r24,r0
 1880 07e4 1124      		clr __zero_reg__
 1881 07e6 B801      		movw r22,r16
 1882 07e8 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1883 07ea 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1884 07ec 00C0      		rjmp .L149
 1885               	.L144:
3078:../../Source/tasks.c **** 	}
 1886               		.loc 1 3078 0 is_stmt 1
 1887 07ee B801      		movw r22,r16
 1888 07f0 80E0      		ldi r24,lo8(xPendingReadyList)
 1889 07f2 90E0      		ldi r25,hi8(xPendingReadyList)
 1890               	.L149:
 1891 07f4 0E94 0000 		call vListInsertEnd
 1892               	.LVL166:
3081:../../Source/tasks.c **** 	{
 1893               		.loc 1 3081 0
 1894 07f8 E091 0000 		lds r30,pxCurrentTCB
 1895 07fc F091 0000 		lds r31,pxCurrentTCB+1
 1896 0800 9E89      		ldd r25,Y+22
 1897 0802 8689      		ldd r24,Z+22
 1898 0804 8917      		cp r24,r25
 1899 0806 00F4      		brsh .L148
 1900               	.LVL167:
3090:../../Source/tasks.c **** 	}
 1901               		.loc 1 3090 0
 1902 0808 81E0      		ldi r24,lo8(1)
 1903 080a 8093 0000 		sts xYieldPending,r24
 1904 080e 00C0      		rjmp .L147
 1905               	.LVL168:
 1906               	.L148:
3094:../../Source/tasks.c **** 	}
 1907               		.loc 1 3094 0
 1908 0810 80E0      		ldi r24,0
 1909               	.L147:
 1910               	.LVL169:
 1911               	/* epilogue start */
3112:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1912               		.loc 1 3112 0
 1913 0812 DF91      		pop r29
 1914 0814 CF91      		pop r28
 1915               	.LVL170:
 1916 0816 1F91      		pop r17
 1917 0818 0F91      		pop r16
 1918 081a 0895      		ret
 1919               		.cfi_endproc
 1920               	.LFE22:
 1922               	.global	vTaskRemoveFromUnorderedEventList
 1924               	vTaskRemoveFromUnorderedEventList:
 1925               	.LFB23:
3116:../../Source/tasks.c **** TCB_t *pxUnblockedTCB;
 1926               		.loc 1 3116 0
 1927               		.cfi_startproc
 1928               	.LVL171:
 1929 081c 0F93      		push r16
 1930               	.LCFI56:
 1931               		.cfi_def_cfa_offset 4
 1932               		.cfi_offset 16, -3
 1933 081e 1F93      		push r17
 1934               	.LCFI57:
 1935               		.cfi_def_cfa_offset 5
 1936               		.cfi_offset 17, -4
 1937 0820 CF93      		push r28
 1938               	.LCFI58:
 1939               		.cfi_def_cfa_offset 6
 1940               		.cfi_offset 28, -5
 1941 0822 DF93      		push r29
 1942               	.LCFI59:
 1943               		.cfi_def_cfa_offset 7
 1944               		.cfi_offset 29, -6
 1945               	/* prologue: function */
 1946               	/* frame size = 0 */
 1947               	/* stack size = 4 */
 1948               	.L__stack_usage = 4
3124:../../Source/tasks.c **** 
 1949               		.loc 1 3124 0
 1950 0824 7068      		ori r23,128
 1951               	.LVL172:
 1952 0826 FC01      		movw r30,r24
 1953 0828 7183      		std Z+1,r23
 1954 082a 6083      		st Z,r22
3128:../../Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 1955               		.loc 1 3128 0
 1956 082c C681      		ldd r28,Z+6
 1957 082e D781      		ldd r29,Z+7
 1958               	.LVL173:
3130:../../Source/tasks.c **** 
 1959               		.loc 1 3130 0
 1960 0830 0E94 0000 		call uxListRemove
 1961               	.LVL174:
3135:../../Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 1962               		.loc 1 3135 0
 1963 0834 8E01      		movw r16,r28
 1964 0836 0E5F      		subi r16,-2
 1965 0838 1F4F      		sbci r17,-1
 1966 083a C801      		movw r24,r16
 1967 083c 0E94 0000 		call uxListRemove
 1968               	.LVL175:
3136:../../Source/tasks.c **** 
 1969               		.loc 1 3136 0
 1970 0840 8E89      		ldd r24,Y+22
 1971 0842 9091 0000 		lds r25,uxTopReadyPriority
 1972 0846 9817      		cp r25,r24
 1973 0848 00F4      		brsh .L151
3136:../../Source/tasks.c **** 
 1974               		.loc 1 3136 0 is_stmt 0 discriminator 1
 1975 084a 8093 0000 		sts uxTopReadyPriority,r24
 1976               	.L151:
3136:../../Source/tasks.c **** 
 1977               		.loc 1 3136 0 discriminator 3
 1978 084e F9E0      		ldi r31,lo8(9)
 1979 0850 8F9F      		mul r24,r31
 1980 0852 C001      		movw r24,r0
 1981 0854 1124      		clr __zero_reg__
 1982 0856 B801      		movw r22,r16
 1983 0858 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1984 085a 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1985 085c 0E94 0000 		call vListInsertEnd
 1986               	.LVL176:
3138:../../Source/tasks.c **** 	{
 1987               		.loc 1 3138 0 is_stmt 1 discriminator 3
 1988 0860 E091 0000 		lds r30,pxCurrentTCB
 1989 0864 F091 0000 		lds r31,pxCurrentTCB+1
 1990 0868 9E89      		ldd r25,Y+22
 1991 086a 8689      		ldd r24,Z+22
 1992 086c 8917      		cp r24,r25
 1993 086e 00F4      		brsh .L150
3144:../../Source/tasks.c **** 	}
 1994               		.loc 1 3144 0
 1995 0870 81E0      		ldi r24,lo8(1)
 1996 0872 8093 0000 		sts xYieldPending,r24
 1997               	.L150:
 1998               	/* epilogue start */
3146:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 1999               		.loc 1 3146 0
 2000 0876 DF91      		pop r29
 2001 0878 CF91      		pop r28
 2002               	.LVL177:
 2003 087a 1F91      		pop r17
 2004 087c 0F91      		pop r16
 2005               	.LVL178:
 2006 087e 0895      		ret
 2007               		.cfi_endproc
 2008               	.LFE23:
 2010               	.global	vTaskSetTimeOutState
 2012               	vTaskSetTimeOutState:
 2013               	.LFB24:
3150:../../Source/tasks.c **** 	configASSERT( pxTimeOut );
 2014               		.loc 1 3150 0
 2015               		.cfi_startproc
 2016               	.LVL179:
 2017               	/* prologue: function */
 2018               	/* frame size = 0 */
 2019               	/* stack size = 0 */
 2020               	.L__stack_usage = 0
3152:../../Source/tasks.c **** 	{
 2021               		.loc 1 3152 0
 2022               	/* #APP */
 2023               	 ;  3152 "../../Source/tasks.c" 1
 2024 0880 0FB6      		in __tmp_reg__, __SREG__
 2025 0882 F894      		cli
 2026 0884 0F92      		push __tmp_reg__
 2027               		
 2028               	 ;  0 "" 2
3154:../../Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 2029               		.loc 1 3154 0
 2030               	/* #NOAPP */
 2031 0886 2091 0000 		lds r18,xNumOfOverflows
 2032 088a FC01      		movw r30,r24
 2033 088c 2083      		st Z,r18
3155:../../Source/tasks.c **** 	}
 2034               		.loc 1 3155 0
 2035 088e 2091 0000 		lds r18,xTickCount
 2036 0892 3091 0000 		lds r19,xTickCount+1
 2037 0896 3283      		std Z+2,r19
 2038 0898 2183      		std Z+1,r18
3157:../../Source/tasks.c **** }
 2039               		.loc 1 3157 0
 2040               	/* #APP */
 2041               	 ;  3157 "../../Source/tasks.c" 1
 2042 089a 0F90      		pop __tmp_reg__
 2043 089c 0FBE      		out __SREG__, __tmp_reg__
 2044               		
 2045               	 ;  0 "" 2
 2046               	/* #NOAPP */
 2047 089e 0895      		ret
 2048               		.cfi_endproc
 2049               	.LFE24:
 2051               	.global	vTaskInternalSetTimeOutState
 2053               	vTaskInternalSetTimeOutState:
 2054               	.LFB25:
3162:../../Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 2055               		.loc 1 3162 0
 2056               		.cfi_startproc
 2057               	.LVL180:
 2058               	/* prologue: function */
 2059               	/* frame size = 0 */
 2060               	/* stack size = 0 */
 2061               	.L__stack_usage = 0
3164:../../Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2062               		.loc 1 3164 0
 2063 08a0 2091 0000 		lds r18,xNumOfOverflows
 2064 08a4 FC01      		movw r30,r24
 2065 08a6 2083      		st Z,r18
3165:../../Source/tasks.c **** }
 2066               		.loc 1 3165 0
 2067 08a8 2091 0000 		lds r18,xTickCount
 2068 08ac 3091 0000 		lds r19,xTickCount+1
 2069 08b0 3283      		std Z+2,r19
 2070 08b2 2183      		std Z+1,r18
 2071 08b4 0895      		ret
 2072               		.cfi_endproc
 2073               	.LFE25:
 2075               	.global	xTaskCheckForTimeOut
 2077               	xTaskCheckForTimeOut:
 2078               	.LFB26:
3170:../../Source/tasks.c **** BaseType_t xReturn;
 2079               		.loc 1 3170 0
 2080               		.cfi_startproc
 2081               	.LVL181:
 2082               	/* prologue: function */
 2083               	/* frame size = 0 */
 2084               	/* stack size = 0 */
 2085               	.L__stack_usage = 0
3176:../../Source/tasks.c **** 	{
 2086               		.loc 1 3176 0
 2087               	/* #APP */
 2088               	 ;  3176 "../../Source/tasks.c" 1
 2089 08b6 0FB6      		in __tmp_reg__, __SREG__
 2090 08b8 F894      		cli
 2091 08ba 0F92      		push __tmp_reg__
 2092               		
 2093               	 ;  0 "" 2
 2094               	/* #NOAPP */
 2095               	.LBB53:
3179:../../Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2096               		.loc 1 3179 0
 2097 08bc 2091 0000 		lds r18,xTickCount
 2098 08c0 3091 0000 		lds r19,xTickCount+1
 2099               	.LVL182:
3180:../../Source/tasks.c **** 
 2100               		.loc 1 3180 0
 2101 08c4 DC01      		movw r26,r24
 2102 08c6 1196      		adiw r26,1
 2103 08c8 4D91      		ld r20,X+
 2104 08ca 5C91      		ld r21,X
 2105 08cc 1297      		sbiw r26,1+1
 2106               	.LVL183:
3204:../../Source/tasks.c **** 		{
 2107               		.loc 1 3204 0
 2108 08ce E091 0000 		lds r30,xNumOfOverflows
 2109 08d2 FC91      		ld r31,X
 2110 08d4 FE17      		cp r31,r30
 2111 08d6 01F0      		breq .L156
3204:../../Source/tasks.c **** 		{
 2112               		.loc 1 3204 0 is_stmt 0 discriminator 1
 2113 08d8 2417      		cp r18,r20
 2114 08da 3507      		cpc r19,r21
 2115 08dc 00F4      		brsh .L159
 2116               	.L156:
3180:../../Source/tasks.c **** 
 2117               		.loc 1 3180 0 is_stmt 1
 2118 08de 241B      		sub r18,r20
 2119 08e0 350B      		sbc r19,r21
 2120               	.LVL184:
3213:../../Source/tasks.c **** 		{
 2121               		.loc 1 3213 0
 2122 08e2 FB01      		movw r30,r22
 2123 08e4 4081      		ld r20,Z
 2124 08e6 5181      		ldd r21,Z+1
 2125 08e8 2417      		cp r18,r20
 2126 08ea 3507      		cpc r19,r21
 2127 08ec 00F4      		brsh .L158
3216:../../Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 2128               		.loc 1 3216 0
 2129 08ee 421B      		sub r20,r18
 2130 08f0 530B      		sbc r21,r19
 2131 08f2 5183      		std Z+1,r21
 2132 08f4 4083      		st Z,r20
3217:../../Source/tasks.c **** 			xReturn = pdFALSE;
 2133               		.loc 1 3217 0
 2134 08f6 0E94 0000 		call vTaskInternalSetTimeOutState
 2135               	.LVL185:
3218:../../Source/tasks.c **** 		}
 2136               		.loc 1 3218 0
 2137 08fa 80E0      		ldi r24,0
 2138 08fc 00C0      		rjmp .L157
 2139               	.LVL186:
 2140               	.L158:
3222:../../Source/tasks.c **** 			xReturn = pdTRUE;
 2141               		.loc 1 3222 0
 2142 08fe 1182      		std Z+1,__zero_reg__
 2143 0900 1082      		st Z,__zero_reg__
 2144               	.LVL187:
 2145               	.L159:
3211:../../Source/tasks.c **** 		}
 2146               		.loc 1 3211 0
 2147 0902 81E0      		ldi r24,lo8(1)
 2148               	.LVL188:
 2149               	.L157:
 2150               	.LBE53:
3226:../../Source/tasks.c **** 
 2151               		.loc 1 3226 0
 2152               	/* #APP */
 2153               	 ;  3226 "../../Source/tasks.c" 1
 2154 0904 0F90      		pop __tmp_reg__
 2155 0906 0FBE      		out __SREG__, __tmp_reg__
 2156               		
 2157               	 ;  0 "" 2
3229:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 2158               		.loc 1 3229 0
 2159               	/* #NOAPP */
 2160 0908 0895      		ret
 2161               		.cfi_endproc
 2162               	.LFE26:
 2164               	.global	vTaskMissedYield
 2166               	vTaskMissedYield:
 2167               	.LFB27:
3233:../../Source/tasks.c **** 	xYieldPending = pdTRUE;
 2168               		.loc 1 3233 0
 2169               		.cfi_startproc
 2170               	/* prologue: function */
 2171               	/* frame size = 0 */
 2172               	/* stack size = 0 */
 2173               	.L__stack_usage = 0
3234:../../Source/tasks.c **** }
 2174               		.loc 1 3234 0
 2175 090a 81E0      		ldi r24,lo8(1)
 2176 090c 8093 0000 		sts xYieldPending,r24
 2177 0910 0895      		ret
 2178               		.cfi_endproc
 2179               	.LFE27:
 2181               	.global	uxTaskResetEventItemValue
 2183               	uxTaskResetEventItemValue:
 2184               	.LFB33:
4447:../../Source/tasks.c **** TickType_t uxReturn;
 2185               		.loc 1 4447 0
 2186               		.cfi_startproc
 2187               	/* prologue: function */
 2188               	/* frame size = 0 */
 2189               	/* stack size = 0 */
 2190               	.L__stack_usage = 0
4450:../../Source/tasks.c **** 
 2191               		.loc 1 4450 0
 2192 0912 E091 0000 		lds r30,pxCurrentTCB
 2193 0916 F091 0000 		lds r31,pxCurrentTCB+1
 2194 091a 8485      		ldd r24,Z+12
 2195 091c 9585      		ldd r25,Z+13
 2196               	.LVL189:
4454:../../Source/tasks.c **** 
 2197               		.loc 1 4454 0
 2198 091e E091 0000 		lds r30,pxCurrentTCB
 2199 0922 F091 0000 		lds r31,pxCurrentTCB+1
 2200 0926 A091 0000 		lds r26,pxCurrentTCB
 2201 092a B091 0000 		lds r27,pxCurrentTCB+1
 2202 092e 5696      		adiw r26,22
 2203 0930 4C91      		ld r20,X
 2204 0932 24E0      		ldi r18,lo8(4)
 2205 0934 30E0      		ldi r19,0
 2206 0936 241B      		sub r18,r20
 2207 0938 3109      		sbc r19,__zero_reg__
 2208 093a 3587      		std Z+13,r19
 2209 093c 2487      		std Z+12,r18
4457:../../Source/tasks.c **** /*-----------------------------------------------------------*/
 2210               		.loc 1 4457 0
 2211 093e 0895      		ret
 2212               		.cfi_endproc
 2213               	.LFE33:
 2215               	.global	ulTaskNotifyTake
 2217               	ulTaskNotifyTake:
 2218               	.LFB34:
4480:../../Source/tasks.c **** 	uint32_t ulReturn;
 2219               		.loc 1 4480 0
 2220               		.cfi_startproc
 2221               	.LVL190:
 2222 0940 0F93      		push r16
 2223               	.LCFI60:
 2224               		.cfi_def_cfa_offset 4
 2225               		.cfi_offset 16, -3
 2226 0942 1F93      		push r17
 2227               	.LCFI61:
 2228               		.cfi_def_cfa_offset 5
 2229               		.cfi_offset 17, -4
 2230               	/* prologue: function */
 2231               	/* frame size = 0 */
 2232               	/* stack size = 2 */
 2233               	.L__stack_usage = 2
 2234 0944 182F      		mov r17,r24
 2235 0946 CB01      		movw r24,r22
 2236               	.LVL191:
4483:../../Source/tasks.c **** 		{
 2237               		.loc 1 4483 0
 2238               	/* #APP */
 2239               	 ;  4483 "../../Source/tasks.c" 1
 2240 0948 0FB6      		in __tmp_reg__, __SREG__
 2241 094a F894      		cli
 2242 094c 0F92      		push __tmp_reg__
 2243               		
 2244               	 ;  0 "" 2
4486:../../Source/tasks.c **** 			{
 2245               		.loc 1 4486 0
 2246               	/* #NOAPP */
 2247 094e E091 0000 		lds r30,pxCurrentTCB
 2248 0952 F091 0000 		lds r31,pxCurrentTCB+1
 2249 0956 41A1      		ldd r20,Z+33
 2250 0958 52A1      		ldd r21,Z+34
 2251 095a 63A1      		ldd r22,Z+35
 2252 095c 74A1      		ldd r23,Z+36
 2253 095e 452B      		or r20,r21
 2254 0960 462B      		or r20,r22
 2255 0962 472B      		or r20,r23
 2256 0964 01F4      		brne .L164
4489:../../Source/tasks.c **** 
 2257               		.loc 1 4489 0
 2258 0966 E091 0000 		lds r30,pxCurrentTCB
 2259 096a F091 0000 		lds r31,pxCurrentTCB+1
 2260 096e 21E0      		ldi r18,lo8(1)
 2261 0970 25A3      		std Z+37,r18
4491:../../Source/tasks.c **** 				{
 2262               		.loc 1 4491 0
 2263 0972 0097      		sbiw r24,0
 2264 0974 01F0      		breq .L164
4493:../../Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 2265               		.loc 1 4493 0
 2266 0976 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
 2267               	.LVL192:
4500:../../Source/tasks.c **** 				}
 2268               		.loc 1 4500 0
 2269 097a 0E94 0000 		call vPortYield
 2270               	.LVL193:
 2271               	.L164:
4512:../../Source/tasks.c **** 
 2272               		.loc 1 4512 0
 2273               	/* #APP */
 2274               	 ;  4512 "../../Source/tasks.c" 1
 2275 097e 0F90      		pop __tmp_reg__
 2276 0980 0FBE      		out __SREG__, __tmp_reg__
 2277               		
 2278               	 ;  0 "" 2
4514:../../Source/tasks.c **** 		{
 2279               		.loc 1 4514 0
 2280               	 ;  4514 "../../Source/tasks.c" 1
 2281 0982 0FB6      		in __tmp_reg__, __SREG__
 2282 0984 F894      		cli
 2283 0986 0F92      		push __tmp_reg__
 2284               		
 2285               	 ;  0 "" 2
4517:../../Source/tasks.c **** 
 2286               		.loc 1 4517 0
 2287               	/* #NOAPP */
 2288 0988 E091 0000 		lds r30,pxCurrentTCB
 2289 098c F091 0000 		lds r31,pxCurrentTCB+1
 2290 0990 61A1      		ldd r22,Z+33
 2291 0992 72A1      		ldd r23,Z+34
 2292 0994 83A1      		ldd r24,Z+35
 2293 0996 94A1      		ldd r25,Z+36
 2294               	.LVL194:
4519:../../Source/tasks.c **** 			{
 2295               		.loc 1 4519 0
 2296 0998 6115      		cp r22,__zero_reg__
 2297 099a 7105      		cpc r23,__zero_reg__
 2298 099c 8105      		cpc r24,__zero_reg__
 2299 099e 9105      		cpc r25,__zero_reg__
 2300 09a0 01F0      		breq .L166
4523:../../Source/tasks.c **** 				}
 2301               		.loc 1 4523 0
 2302 09a2 E091 0000 		lds r30,pxCurrentTCB
 2303 09a6 F091 0000 		lds r31,pxCurrentTCB+1
4521:../../Source/tasks.c **** 				{
 2304               		.loc 1 4521 0
 2305 09aa 1123      		tst r17
 2306 09ac 01F0      		breq .L167
4523:../../Source/tasks.c **** 				}
 2307               		.loc 1 4523 0
 2308 09ae 11A2      		std Z+33,__zero_reg__
 2309 09b0 12A2      		std Z+34,__zero_reg__
 2310 09b2 13A2      		std Z+35,__zero_reg__
 2311 09b4 14A2      		std Z+36,__zero_reg__
 2312 09b6 00C0      		rjmp .L166
 2313               	.L167:
4527:../../Source/tasks.c **** 				}
 2314               		.loc 1 4527 0
 2315 09b8 8B01      		movw r16,r22
 2316 09ba 9C01      		movw r18,r24
 2317 09bc 0150      		subi r16,1
 2318 09be 1109      		sbc r17,__zero_reg__
 2319 09c0 2109      		sbc r18,__zero_reg__
 2320 09c2 3109      		sbc r19,__zero_reg__
 2321 09c4 01A3      		std Z+33,r16
 2322 09c6 12A3      		std Z+34,r17
 2323 09c8 23A3      		std Z+35,r18
 2324 09ca 34A3      		std Z+36,r19
 2325               	.L166:
4535:../../Source/tasks.c **** 		}
 2326               		.loc 1 4535 0
 2327 09cc E091 0000 		lds r30,pxCurrentTCB
 2328 09d0 F091 0000 		lds r31,pxCurrentTCB+1
 2329 09d4 15A2      		std Z+37,__zero_reg__
4537:../../Source/tasks.c **** 
 2330               		.loc 1 4537 0
 2331               	/* #APP */
 2332               	 ;  4537 "../../Source/tasks.c" 1
 2333 09d6 0F90      		pop __tmp_reg__
 2334 09d8 0FBE      		out __SREG__, __tmp_reg__
 2335               		
 2336               	 ;  0 "" 2
 2337               	/* epilogue start */
4540:../../Source/tasks.c **** 
 2338               		.loc 1 4540 0
 2339               	/* #NOAPP */
 2340 09da 1F91      		pop r17
 2341               	.LVL195:
 2342 09dc 0F91      		pop r16
 2343 09de 0895      		ret
 2344               		.cfi_endproc
 2345               	.LFE34:
 2347               	.global	xTaskNotifyWait
 2349               	xTaskNotifyWait:
 2350               	.LFB35:
4548:../../Source/tasks.c **** 	BaseType_t xReturn;
 2351               		.loc 1 4548 0
 2352               		.cfi_startproc
 2353               	.LVL196:
 2354 09e0 4F92      		push r4
 2355               	.LCFI62:
 2356               		.cfi_def_cfa_offset 4
 2357               		.cfi_offset 4, -3
 2358 09e2 5F92      		push r5
 2359               	.LCFI63:
 2360               		.cfi_def_cfa_offset 5
 2361               		.cfi_offset 5, -4
 2362 09e4 6F92      		push r6
 2363               	.LCFI64:
 2364               		.cfi_def_cfa_offset 6
 2365               		.cfi_offset 6, -5
 2366 09e6 7F92      		push r7
 2367               	.LCFI65:
 2368               		.cfi_def_cfa_offset 7
 2369               		.cfi_offset 7, -6
 2370 09e8 8F92      		push r8
 2371               	.LCFI66:
 2372               		.cfi_def_cfa_offset 8
 2373               		.cfi_offset 8, -7
 2374 09ea 9F92      		push r9
 2375               	.LCFI67:
 2376               		.cfi_def_cfa_offset 9
 2377               		.cfi_offset 9, -8
 2378 09ec AF92      		push r10
 2379               	.LCFI68:
 2380               		.cfi_def_cfa_offset 10
 2381               		.cfi_offset 10, -9
 2382 09ee BF92      		push r11
 2383               	.LCFI69:
 2384               		.cfi_def_cfa_offset 11
 2385               		.cfi_offset 11, -10
 2386 09f0 EF92      		push r14
 2387               	.LCFI70:
 2388               		.cfi_def_cfa_offset 12
 2389               		.cfi_offset 14, -11
 2390 09f2 FF92      		push r15
 2391               	.LCFI71:
 2392               		.cfi_def_cfa_offset 13
 2393               		.cfi_offset 15, -12
 2394 09f4 0F93      		push r16
 2395               	.LCFI72:
 2396               		.cfi_def_cfa_offset 14
 2397               		.cfi_offset 16, -13
 2398 09f6 1F93      		push r17
 2399               	.LCFI73:
 2400               		.cfi_def_cfa_offset 15
 2401               		.cfi_offset 17, -14
 2402               	/* prologue: function */
 2403               	/* frame size = 0 */
 2404               	/* stack size = 12 */
 2405               	.L__stack_usage = 12
 2406 09f8 4901      		movw r8,r18
 2407 09fa 5A01      		movw r10,r20
4551:../../Source/tasks.c **** 		{
 2408               		.loc 1 4551 0
 2409               	/* #APP */
 2410               	 ;  4551 "../../Source/tasks.c" 1
 2411 09fc 0FB6      		in __tmp_reg__, __SREG__
 2412 09fe F894      		cli
 2413 0a00 0F92      		push __tmp_reg__
 2414               		
 2415               	 ;  0 "" 2
4554:../../Source/tasks.c **** 			{
 2416               		.loc 1 4554 0
 2417               	/* #NOAPP */
 2418 0a02 E091 0000 		lds r30,pxCurrentTCB
 2419 0a06 F091 0000 		lds r31,pxCurrentTCB+1
 2420 0a0a 25A1      		ldd r18,Z+37
 2421               	.LVL197:
 2422 0a0c 2230      		cpi r18,lo8(2)
 2423 0a0e 01F0      		breq .L176
4559:../../Source/tasks.c **** 
 2424               		.loc 1 4559 0
 2425 0a10 E091 0000 		lds r30,pxCurrentTCB
 2426 0a14 F091 0000 		lds r31,pxCurrentTCB+1
 2427 0a18 21A1      		ldd r18,Z+33
 2428 0a1a 32A1      		ldd r19,Z+34
 2429 0a1c 43A1      		ldd r20,Z+35
 2430 0a1e 54A1      		ldd r21,Z+36
 2431 0a20 2B01      		movw r4,r22
 2432 0a22 3C01      		movw r6,r24
 2433 0a24 4094      		com r4
 2434 0a26 5094      		com r5
 2435 0a28 6094      		com r6
 2436 0a2a 7094      		com r7
 2437 0a2c D301      		movw r26,r6
 2438 0a2e C201      		movw r24,r4
 2439 0a30 8223      		and r24,r18
 2440 0a32 9323      		and r25,r19
 2441 0a34 A423      		and r26,r20
 2442 0a36 B523      		and r27,r21
 2443 0a38 81A3      		std Z+33,r24
 2444 0a3a 92A3      		std Z+34,r25
 2445 0a3c A3A3      		std Z+35,r26
 2446 0a3e B4A3      		std Z+36,r27
4562:../../Source/tasks.c **** 
 2447               		.loc 1 4562 0
 2448 0a40 E091 0000 		lds r30,pxCurrentTCB
 2449 0a44 F091 0000 		lds r31,pxCurrentTCB+1
 2450 0a48 81E0      		ldi r24,lo8(1)
 2451 0a4a 85A3      		std Z+37,r24
4564:../../Source/tasks.c **** 				{
 2452               		.loc 1 4564 0
 2453 0a4c E114      		cp r14,__zero_reg__
 2454 0a4e F104      		cpc r15,__zero_reg__
 2455 0a50 01F0      		breq .L176
4566:../../Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 2456               		.loc 1 4566 0
 2457 0a52 C701      		movw r24,r14
 2458 0a54 0E94 0000 		call prvAddCurrentTaskToDelayedList.isra.2
 2459               	.LVL198:
4573:../../Source/tasks.c **** 				}
 2460               		.loc 1 4573 0
 2461 0a58 0E94 0000 		call vPortYield
 2462               	.LVL199:
 2463               	.L176:
4585:../../Source/tasks.c **** 
 2464               		.loc 1 4585 0
 2465               	/* #APP */
 2466               	 ;  4585 "../../Source/tasks.c" 1
 2467 0a5c 0F90      		pop __tmp_reg__
 2468 0a5e 0FBE      		out __SREG__, __tmp_reg__
 2469               		
 2470               	 ;  0 "" 2
4587:../../Source/tasks.c **** 		{
 2471               		.loc 1 4587 0
 2472               	 ;  4587 "../../Source/tasks.c" 1
 2473 0a60 0FB6      		in __tmp_reg__, __SREG__
 2474 0a62 F894      		cli
 2475 0a64 0F92      		push __tmp_reg__
 2476               		
 2477               	 ;  0 "" 2
4591:../../Source/tasks.c **** 			{
 2478               		.loc 1 4591 0
 2479               	/* #NOAPP */
 2480 0a66 0115      		cp r16,__zero_reg__
 2481 0a68 1105      		cpc r17,__zero_reg__
 2482 0a6a 01F0      		breq .L178
4595:../../Source/tasks.c **** 			}
 2483               		.loc 1 4595 0
 2484 0a6c E091 0000 		lds r30,pxCurrentTCB
 2485 0a70 F091 0000 		lds r31,pxCurrentTCB+1
 2486 0a74 81A1      		ldd r24,Z+33
 2487 0a76 92A1      		ldd r25,Z+34
 2488 0a78 A3A1      		ldd r26,Z+35
 2489 0a7a B4A1      		ldd r27,Z+36
 2490 0a7c F801      		movw r30,r16
 2491 0a7e 8083      		st Z,r24
 2492 0a80 9183      		std Z+1,r25
 2493 0a82 A283      		std Z+2,r26
 2494 0a84 B383      		std Z+3,r27
 2495               	.L178:
4602:../../Source/tasks.c **** 			{
 2496               		.loc 1 4602 0
 2497 0a86 E091 0000 		lds r30,pxCurrentTCB
 2498 0a8a F091 0000 		lds r31,pxCurrentTCB+1
 2499 0a8e 85A1      		ldd r24,Z+37
 2500 0a90 8230      		cpi r24,lo8(2)
 2501 0a92 01F4      		brne .L180
4611:../../Source/tasks.c **** 				xReturn = pdTRUE;
 2502               		.loc 1 4611 0
 2503 0a94 E091 0000 		lds r30,pxCurrentTCB
 2504 0a98 F091 0000 		lds r31,pxCurrentTCB+1
 2505 0a9c 41A1      		ldd r20,Z+33
 2506 0a9e 52A1      		ldd r21,Z+34
 2507 0aa0 63A1      		ldd r22,Z+35
 2508 0aa2 74A1      		ldd r23,Z+36
 2509 0aa4 D501      		movw r26,r10
 2510 0aa6 C401      		movw r24,r8
 2511 0aa8 8095      		com r24
 2512 0aaa 9095      		com r25
 2513 0aac A095      		com r26
 2514 0aae B095      		com r27
 2515 0ab0 8423      		and r24,r20
 2516 0ab2 9523      		and r25,r21
 2517 0ab4 A623      		and r26,r22
 2518 0ab6 B723      		and r27,r23
 2519 0ab8 81A3      		std Z+33,r24
 2520 0aba 92A3      		std Z+34,r25
 2521 0abc A3A3      		std Z+35,r26
 2522 0abe B4A3      		std Z+36,r27
 2523               	.LVL200:
4612:../../Source/tasks.c **** 			}
 2524               		.loc 1 4612 0
 2525 0ac0 81E0      		ldi r24,lo8(1)
 2526 0ac2 00C0      		rjmp .L179
 2527               	.LVL201:
 2528               	.L180:
4605:../../Source/tasks.c **** 			}
 2529               		.loc 1 4605 0
 2530 0ac4 80E0      		ldi r24,0
 2531               	.L179:
 2532               	.LVL202:
4615:../../Source/tasks.c **** 		}
 2533               		.loc 1 4615 0
 2534 0ac6 E091 0000 		lds r30,pxCurrentTCB
 2535 0aca F091 0000 		lds r31,pxCurrentTCB+1
 2536 0ace 15A2      		std Z+37,__zero_reg__
4617:../../Source/tasks.c **** 
 2537               		.loc 1 4617 0
 2538               	/* #APP */
 2539               	 ;  4617 "../../Source/tasks.c" 1
 2540 0ad0 0F90      		pop __tmp_reg__
 2541 0ad2 0FBE      		out __SREG__, __tmp_reg__
 2542               		
 2543               	 ;  0 "" 2
 2544               	/* epilogue start */
4620:../../Source/tasks.c **** 
 2545               		.loc 1 4620 0
 2546               	/* #NOAPP */
 2547 0ad4 1F91      		pop r17
 2548 0ad6 0F91      		pop r16
 2549               	.LVL203:
 2550 0ad8 FF90      		pop r15
 2551 0ada EF90      		pop r14
 2552               	.LVL204:
 2553 0adc BF90      		pop r11
 2554 0ade AF90      		pop r10
 2555 0ae0 9F90      		pop r9
 2556 0ae2 8F90      		pop r8
 2557               	.LVL205:
 2558 0ae4 7F90      		pop r7
 2559 0ae6 6F90      		pop r6
 2560 0ae8 5F90      		pop r5
 2561 0aea 4F90      		pop r4
 2562 0aec 0895      		ret
 2563               		.cfi_endproc
 2564               	.LFE35:
 2566               	.global	xTaskGenericNotify
 2568               	xTaskGenericNotify:
 2569               	.LFB36:
4628:../../Source/tasks.c **** 	TCB_t * pxTCB;
 2570               		.loc 1 4628 0
 2571               		.cfi_startproc
 2572               	.LVL206:
 2573 0aee 0F93      		push r16
 2574               	.LCFI74:
 2575               		.cfi_def_cfa_offset 4
 2576               		.cfi_offset 16, -3
 2577 0af0 1F93      		push r17
 2578               	.LCFI75:
 2579               		.cfi_def_cfa_offset 5
 2580               		.cfi_offset 17, -4
 2581 0af2 CF93      		push r28
 2582               	.LCFI76:
 2583               		.cfi_def_cfa_offset 6
 2584               		.cfi_offset 28, -5
 2585 0af4 DF93      		push r29
 2586               	.LCFI77:
 2587               		.cfi_def_cfa_offset 7
 2588               		.cfi_offset 29, -6
 2589               	/* prologue: function */
 2590               	/* frame size = 0 */
 2591               	/* stack size = 4 */
 2592               	.L__stack_usage = 4
 2593 0af6 FC01      		movw r30,r24
 2594               	.LVL207:
4636:../../Source/tasks.c **** 		{
 2595               		.loc 1 4636 0
 2596               	/* #APP */
 2597               	 ;  4636 "../../Source/tasks.c" 1
 2598 0af8 0FB6      		in __tmp_reg__, __SREG__
 2599 0afa F894      		cli
 2600 0afc 0F92      		push __tmp_reg__
 2601               		
 2602               	 ;  0 "" 2
4638:../../Source/tasks.c **** 			{
 2603               		.loc 1 4638 0
 2604               	/* #NOAPP */
 2605 0afe 0115      		cp r16,__zero_reg__
 2606 0b00 1105      		cpc r17,__zero_reg__
 2607 0b02 01F0      		breq .L188
4640:../../Source/tasks.c **** 			}
 2608               		.loc 1 4640 0
 2609 0b04 81A1      		ldd r24,Z+33
 2610 0b06 92A1      		ldd r25,Z+34
 2611 0b08 A3A1      		ldd r26,Z+35
 2612 0b0a B4A1      		ldd r27,Z+36
 2613               	.LVL208:
 2614 0b0c E801      		movw r28,r16
 2615 0b0e 8883      		st Y,r24
 2616 0b10 9983      		std Y+1,r25
 2617 0b12 AA83      		std Y+2,r26
 2618 0b14 BB83      		std Y+3,r27
 2619               	.L188:
4643:../../Source/tasks.c **** 
 2620               		.loc 1 4643 0
 2621 0b16 35A1      		ldd r19,Z+37
 2622               	.LVL209:
4645:../../Source/tasks.c **** 
 2623               		.loc 1 4645 0
 2624 0b18 82E0      		ldi r24,lo8(2)
 2625 0b1a 85A3      		std Z+37,r24
4647:../../Source/tasks.c **** 			{
 2626               		.loc 1 4647 0
 2627 0b1c 2230      		cpi r18,lo8(2)
 2628 0b1e 01F0      		breq .L190
 2629 0b20 00F4      		brsh .L191
 2630 0b22 2130      		cpi r18,lo8(1)
 2631 0b24 01F4      		brne .L189
4650:../../Source/tasks.c **** 					break;
 2632               		.loc 1 4650 0
 2633 0b26 81A1      		ldd r24,Z+33
 2634 0b28 92A1      		ldd r25,Z+34
 2635 0b2a A3A1      		ldd r26,Z+35
 2636 0b2c B4A1      		ldd r27,Z+36
 2637 0b2e 482B      		or r20,r24
 2638 0b30 592B      		or r21,r25
 2639 0b32 6A2B      		or r22,r26
 2640 0b34 7B2B      		or r23,r27
 2641               	.LVL210:
 2642 0b36 00C0      		rjmp .L203
 2643               	.LVL211:
 2644               	.L191:
4647:../../Source/tasks.c **** 			{
 2645               		.loc 1 4647 0
 2646 0b38 2330      		cpi r18,lo8(3)
 2647 0b3a 01F0      		breq .L203
 2648 0b3c 2430      		cpi r18,lo8(4)
 2649 0b3e 01F0      		breq .L194
 2650 0b40 00C0      		rjmp .L189
 2651               	.L190:
4654:../../Source/tasks.c **** 					break;
 2652               		.loc 1 4654 0
 2653 0b42 81A1      		ldd r24,Z+33
 2654 0b44 92A1      		ldd r25,Z+34
 2655 0b46 A3A1      		ldd r26,Z+35
 2656 0b48 B4A1      		ldd r27,Z+36
 2657 0b4a 0196      		adiw r24,1
 2658 0b4c A11D      		adc r26,__zero_reg__
 2659 0b4e B11D      		adc r27,__zero_reg__
 2660 0b50 81A3      		std Z+33,r24
 2661 0b52 92A3      		std Z+34,r25
 2662 0b54 A3A3      		std Z+35,r26
 2663 0b56 B4A3      		std Z+36,r27
4655:../../Source/tasks.c **** 
 2664               		.loc 1 4655 0
 2665 0b58 00C0      		rjmp .L189
 2666               	.L194:
4662:../../Source/tasks.c **** 					{
 2667               		.loc 1 4662 0
 2668 0b5a 3230      		cpi r19,lo8(2)
 2669 0b5c 01F0      		breq .L199
 2670               	.LVL212:
 2671               	.L203:
4664:../../Source/tasks.c **** 					}
 2672               		.loc 1 4664 0
 2673 0b5e 41A3      		std Z+33,r20
 2674 0b60 52A3      		std Z+34,r21
 2675 0b62 63A3      		std Z+35,r22
 2676 0b64 74A3      		std Z+36,r23
 2677               	.L189:
4691:../../Source/tasks.c **** 			{
 2678               		.loc 1 4691 0
 2679 0b66 3130      		cpi r19,lo8(1)
 2680 0b68 01F4      		brne .L204
 2681 0b6a EF01      		movw r28,r30
4693:../../Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 2682               		.loc 1 4693 0
 2683 0b6c 8F01      		movw r16,r30
 2684               	.LVL213:
 2685 0b6e 0E5F      		subi r16,-2
 2686 0b70 1F4F      		sbci r17,-1
 2687 0b72 C801      		movw r24,r16
 2688 0b74 0E94 0000 		call uxListRemove
 2689               	.LVL214:
4694:../../Source/tasks.c **** 
 2690               		.loc 1 4694 0
 2691 0b78 8E89      		ldd r24,Y+22
 2692 0b7a 9091 0000 		lds r25,uxTopReadyPriority
 2693 0b7e 9817      		cp r25,r24
 2694 0b80 00F4      		brsh .L197
4694:../../Source/tasks.c **** 
 2695               		.loc 1 4694 0 is_stmt 0 discriminator 1
 2696 0b82 8093 0000 		sts uxTopReadyPriority,r24
 2697               	.L197:
4694:../../Source/tasks.c **** 
 2698               		.loc 1 4694 0 discriminator 3
 2699 0b86 29E0      		ldi r18,lo8(9)
 2700 0b88 829F      		mul r24,r18
 2701 0b8a C001      		movw r24,r0
 2702 0b8c 1124      		clr __zero_reg__
 2703 0b8e B801      		movw r22,r16
 2704 0b90 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2705 0b92 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2706 0b94 0E94 0000 		call vListInsertEnd
 2707               	.LVL215:
4715:../../Source/tasks.c **** 				{
 2708               		.loc 1 4715 0 is_stmt 1 discriminator 3
 2709 0b98 E091 0000 		lds r30,pxCurrentTCB
 2710 0b9c F091 0000 		lds r31,pxCurrentTCB+1
 2711 0ba0 9E89      		ldd r25,Y+22
 2712 0ba2 8689      		ldd r24,Z+22
 2713 0ba4 8917      		cp r24,r25
 2714 0ba6 00F4      		brsh .L204
4719:../../Source/tasks.c **** 				}
 2715               		.loc 1 4719 0
 2716 0ba8 0E94 0000 		call vPortYield
 2717               	.LVL216:
 2718               	.L204:
 2719 0bac 81E0      		ldi r24,lo8(1)
 2720 0bae 00C0      		rjmp .L195
 2721               	.LVL217:
 2722               	.L199:
4669:../../Source/tasks.c **** 					}
 2723               		.loc 1 4669 0
 2724 0bb0 80E0      		ldi r24,0
 2725               	.LVL218:
 2726               	.L195:
4731:../../Source/tasks.c **** 
 2727               		.loc 1 4731 0
 2728               	/* #APP */
 2729               	 ;  4731 "../../Source/tasks.c" 1
 2730 0bb2 0F90      		pop __tmp_reg__
 2731 0bb4 0FBE      		out __SREG__, __tmp_reg__
 2732               		
 2733               	 ;  0 "" 2
 2734               	/* epilogue start */
4734:../../Source/tasks.c **** 
 2735               		.loc 1 4734 0
 2736               	/* #NOAPP */
 2737 0bb6 DF91      		pop r29
 2738 0bb8 CF91      		pop r28
 2739 0bba 1F91      		pop r17
 2740 0bbc 0F91      		pop r16
 2741 0bbe 0895      		ret
 2742               		.cfi_endproc
 2743               	.LFE36:
 2745               	.global	xTaskGenericNotifyFromISR
 2747               	xTaskGenericNotifyFromISR:
 2748               	.LFB37:
4742:../../Source/tasks.c **** 	TCB_t * pxTCB;
 2749               		.loc 1 4742 0
 2750               		.cfi_startproc
 2751               	.LVL219:
 2752 0bc0 EF92      		push r14
 2753               	.LCFI78:
 2754               		.cfi_def_cfa_offset 4
 2755               		.cfi_offset 14, -3
 2756 0bc2 FF92      		push r15
 2757               	.LCFI79:
 2758               		.cfi_def_cfa_offset 5
 2759               		.cfi_offset 15, -4
 2760 0bc4 0F93      		push r16
 2761               	.LCFI80:
 2762               		.cfi_def_cfa_offset 6
 2763               		.cfi_offset 16, -5
 2764 0bc6 1F93      		push r17
 2765               	.LCFI81:
 2766               		.cfi_def_cfa_offset 7
 2767               		.cfi_offset 17, -6
 2768 0bc8 CF93      		push r28
 2769               	.LCFI82:
 2770               		.cfi_def_cfa_offset 8
 2771               		.cfi_offset 28, -7
 2772 0bca DF93      		push r29
 2773               	.LCFI83:
 2774               		.cfi_def_cfa_offset 9
 2775               		.cfi_offset 29, -8
 2776               	/* prologue: function */
 2777               	/* frame size = 0 */
 2778               	/* stack size = 6 */
 2779               	.L__stack_usage = 6
 2780 0bcc FC01      		movw r30,r24
 2781               	.LVL220:
4772:../../Source/tasks.c **** 			{
 2782               		.loc 1 4772 0
 2783 0bce 0115      		cp r16,__zero_reg__
 2784 0bd0 1105      		cpc r17,__zero_reg__
 2785 0bd2 01F0      		breq .L206
4774:../../Source/tasks.c **** 			}
 2786               		.loc 1 4774 0
 2787 0bd4 81A1      		ldd r24,Z+33
 2788 0bd6 92A1      		ldd r25,Z+34
 2789 0bd8 A3A1      		ldd r26,Z+35
 2790 0bda B4A1      		ldd r27,Z+36
 2791               	.LVL221:
 2792 0bdc E801      		movw r28,r16
 2793 0bde 8883      		st Y,r24
 2794 0be0 9983      		std Y+1,r25
 2795 0be2 AA83      		std Y+2,r26
 2796 0be4 BB83      		std Y+3,r27
 2797               	.L206:
4777:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 2798               		.loc 1 4777 0
 2799 0be6 35A1      		ldd r19,Z+37
 2800               	.LVL222:
4778:../../Source/tasks.c **** 
 2801               		.loc 1 4778 0
 2802 0be8 82E0      		ldi r24,lo8(2)
 2803 0bea 85A3      		std Z+37,r24
4780:../../Source/tasks.c **** 			{
 2804               		.loc 1 4780 0
 2805 0bec 2230      		cpi r18,lo8(2)
 2806 0bee 01F0      		breq .L208
 2807 0bf0 00F4      		brsh .L209
 2808 0bf2 2130      		cpi r18,lo8(1)
 2809 0bf4 01F4      		brne .L207
4783:../../Source/tasks.c **** 					break;
 2810               		.loc 1 4783 0
 2811 0bf6 81A1      		ldd r24,Z+33
 2812 0bf8 92A1      		ldd r25,Z+34
 2813 0bfa A3A1      		ldd r26,Z+35
 2814 0bfc B4A1      		ldd r27,Z+36
 2815 0bfe 482B      		or r20,r24
 2816 0c00 592B      		or r21,r25
 2817 0c02 6A2B      		or r22,r26
 2818 0c04 7B2B      		or r23,r27
 2819               	.LVL223:
 2820 0c06 00C0      		rjmp .L227
 2821               	.LVL224:
 2822               	.L209:
4780:../../Source/tasks.c **** 			{
 2823               		.loc 1 4780 0
 2824 0c08 2330      		cpi r18,lo8(3)
 2825 0c0a 01F0      		breq .L227
 2826 0c0c 2430      		cpi r18,lo8(4)
 2827 0c0e 01F0      		breq .L212
 2828 0c10 00C0      		rjmp .L207
 2829               	.L208:
4787:../../Source/tasks.c **** 					break;
 2830               		.loc 1 4787 0
 2831 0c12 81A1      		ldd r24,Z+33
 2832 0c14 92A1      		ldd r25,Z+34
 2833 0c16 A3A1      		ldd r26,Z+35
 2834 0c18 B4A1      		ldd r27,Z+36
 2835 0c1a 0196      		adiw r24,1
 2836 0c1c A11D      		adc r26,__zero_reg__
 2837 0c1e B11D      		adc r27,__zero_reg__
 2838 0c20 81A3      		std Z+33,r24
 2839 0c22 92A3      		std Z+34,r25
 2840 0c24 A3A3      		std Z+35,r26
 2841 0c26 B4A3      		std Z+36,r27
4788:../../Source/tasks.c **** 
 2842               		.loc 1 4788 0
 2843 0c28 00C0      		rjmp .L207
 2844               	.L212:
4795:../../Source/tasks.c **** 					{
 2845               		.loc 1 4795 0
 2846 0c2a 3230      		cpi r19,lo8(2)
 2847 0c2c 01F0      		breq .L220
 2848               	.LVL225:
 2849               	.L227:
4797:../../Source/tasks.c **** 					}
 2850               		.loc 1 4797 0
 2851 0c2e 41A3      		std Z+33,r20
 2852 0c30 52A3      		std Z+34,r21
 2853 0c32 63A3      		std Z+35,r22
 2854 0c34 74A3      		std Z+36,r23
 2855               	.L207:
4823:../../Source/tasks.c **** 			{
 2856               		.loc 1 4823 0
 2857 0c36 3130      		cpi r19,lo8(1)
 2858 0c38 01F0      		breq .L214
 2859               	.LVL226:
 2860               	.L218:
4742:../../Source/tasks.c **** 	TCB_t * pxTCB;
 2861               		.loc 1 4742 0
 2862 0c3a 81E0      		ldi r24,lo8(1)
 2863 0c3c 00C0      		rjmp .L213
 2864               	.LVL227:
 2865               	.L214:
 2866 0c3e EF01      		movw r28,r30
4828:../../Source/tasks.c **** 				{
 2867               		.loc 1 4828 0
 2868 0c40 8091 0000 		lds r24,uxSchedulerSuspended
 2869 0c44 8111      		cpse r24,__zero_reg__
 2870 0c46 00C0      		rjmp .L215
 2871               	.LVL228:
4830:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2872               		.loc 1 4830 0
 2873 0c48 8F01      		movw r16,r30
 2874               	.LVL229:
 2875 0c4a 0E5F      		subi r16,-2
 2876 0c4c 1F4F      		sbci r17,-1
 2877 0c4e C801      		movw r24,r16
 2878 0c50 0E94 0000 		call uxListRemove
 2879               	.LVL230:
4831:../../Source/tasks.c **** 				}
 2880               		.loc 1 4831 0
 2881 0c54 8E89      		ldd r24,Y+22
 2882 0c56 9091 0000 		lds r25,uxTopReadyPriority
 2883 0c5a 9817      		cp r25,r24
 2884 0c5c 00F4      		brsh .L216
4831:../../Source/tasks.c **** 				}
 2885               		.loc 1 4831 0 is_stmt 0 discriminator 1
 2886 0c5e 8093 0000 		sts uxTopReadyPriority,r24
 2887               	.L216:
4831:../../Source/tasks.c **** 				}
 2888               		.loc 1 4831 0 discriminator 3
 2889 0c62 E9E0      		ldi r30,lo8(9)
 2890 0c64 8E9F      		mul r24,r30
 2891 0c66 C001      		movw r24,r0
 2892 0c68 1124      		clr __zero_reg__
 2893 0c6a B801      		movw r22,r16
 2894 0c6c 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2895 0c6e 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2896 0c70 00C0      		rjmp .L228
 2897               	.LVL231:
 2898               	.L215:
4837:../../Source/tasks.c **** 				}
 2899               		.loc 1 4837 0 is_stmt 1
 2900 0c72 BF01      		movw r22,r30
 2901 0c74 645F      		subi r22,-12
 2902 0c76 7F4F      		sbci r23,-1
 2903 0c78 80E0      		ldi r24,lo8(xPendingReadyList)
 2904 0c7a 90E0      		ldi r25,hi8(xPendingReadyList)
 2905               	.LVL232:
 2906               	.L228:
 2907 0c7c 0E94 0000 		call vListInsertEnd
 2908               	.LVL233:
4840:../../Source/tasks.c **** 				{
 2909               		.loc 1 4840 0
 2910 0c80 E091 0000 		lds r30,pxCurrentTCB
 2911 0c84 F091 0000 		lds r31,pxCurrentTCB+1
 2912 0c88 9E89      		ldd r25,Y+22
 2913 0c8a 8689      		ldd r24,Z+22
 2914 0c8c 8917      		cp r24,r25
 2915 0c8e 00F4      		brsh .L218
4844:../../Source/tasks.c **** 					{
 2916               		.loc 1 4844 0
 2917 0c90 E114      		cp r14,__zero_reg__
 2918 0c92 F104      		cpc r15,__zero_reg__
 2919 0c94 01F0      		breq .L219
4846:../../Source/tasks.c **** 					}
 2920               		.loc 1 4846 0
 2921 0c96 81E0      		ldi r24,lo8(1)
 2922 0c98 E701      		movw r28,r14
 2923               	.LVL234:
 2924 0c9a 8883      		st Y,r24
 2925               	.L219:
4852:../../Source/tasks.c **** 				}
 2926               		.loc 1 4852 0
 2927 0c9c 81E0      		ldi r24,lo8(1)
 2928 0c9e 8093 0000 		sts xYieldPending,r24
 2929 0ca2 00C0      		rjmp .L213
 2930               	.LVL235:
 2931               	.L220:
4802:../../Source/tasks.c **** 					}
 2932               		.loc 1 4802 0
 2933 0ca4 80E0      		ldi r24,0
 2934               	.LVL236:
 2935               	.L213:
 2936               	/* epilogue start */
4863:../../Source/tasks.c **** 
 2937               		.loc 1 4863 0
 2938 0ca6 DF91      		pop r29
 2939 0ca8 CF91      		pop r28
 2940 0caa 1F91      		pop r17
 2941 0cac 0F91      		pop r16
 2942 0cae FF90      		pop r15
 2943 0cb0 EF90      		pop r14
 2944               	.LVL237:
 2945 0cb2 0895      		ret
 2946               		.cfi_endproc
 2947               	.LFE37:
 2949               	.global	vTaskNotifyGiveFromISR
 2951               	vTaskNotifyGiveFromISR:
 2952               	.LFB38:
4871:../../Source/tasks.c **** 	TCB_t * pxTCB;
 2953               		.loc 1 4871 0
 2954               		.cfi_startproc
 2955               	.LVL238:
 2956 0cb4 EF92      		push r14
 2957               	.LCFI84:
 2958               		.cfi_def_cfa_offset 4
 2959               		.cfi_offset 14, -3
 2960 0cb6 FF92      		push r15
 2961               	.LCFI85:
 2962               		.cfi_def_cfa_offset 5
 2963               		.cfi_offset 15, -4
 2964 0cb8 0F93      		push r16
 2965               	.LCFI86:
 2966               		.cfi_def_cfa_offset 6
 2967               		.cfi_offset 16, -5
 2968 0cba 1F93      		push r17
 2969               	.LCFI87:
 2970               		.cfi_def_cfa_offset 7
 2971               		.cfi_offset 17, -6
 2972 0cbc CF93      		push r28
 2973               	.LCFI88:
 2974               		.cfi_def_cfa_offset 8
 2975               		.cfi_offset 28, -7
 2976 0cbe DF93      		push r29
 2977               	.LCFI89:
 2978               		.cfi_def_cfa_offset 9
 2979               		.cfi_offset 29, -8
 2980               	/* prologue: function */
 2981               	/* frame size = 0 */
 2982               	/* stack size = 6 */
 2983               	.L__stack_usage = 6
 2984 0cc0 FC01      		movw r30,r24
 2985               	.LVL239:
4900:../../Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 2986               		.loc 1 4900 0
 2987 0cc2 25A1      		ldd r18,Z+37
 2988               	.LVL240:
4901:../../Source/tasks.c **** 
 2989               		.loc 1 4901 0
 2990 0cc4 82E0      		ldi r24,lo8(2)
 2991               	.LVL241:
 2992 0cc6 85A3      		std Z+37,r24
4905:../../Source/tasks.c **** 
 2993               		.loc 1 4905 0
 2994 0cc8 81A1      		ldd r24,Z+33
 2995 0cca 92A1      		ldd r25,Z+34
 2996 0ccc A3A1      		ldd r26,Z+35
 2997 0cce B4A1      		ldd r27,Z+36
 2998 0cd0 0196      		adiw r24,1
 2999 0cd2 A11D      		adc r26,__zero_reg__
 3000 0cd4 B11D      		adc r27,__zero_reg__
 3001 0cd6 81A3      		std Z+33,r24
 3002 0cd8 92A3      		std Z+34,r25
 3003 0cda A3A3      		std Z+35,r26
 3004 0cdc B4A3      		std Z+36,r27
4911:../../Source/tasks.c **** 			{
 3005               		.loc 1 4911 0
 3006 0cde 2130      		cpi r18,lo8(1)
 3007 0ce0 01F4      		brne .L229
 3008 0ce2 8B01      		movw r16,r22
 3009 0ce4 EF01      		movw r28,r30
4916:../../Source/tasks.c **** 				{
 3010               		.loc 1 4916 0
 3011 0ce6 8091 0000 		lds r24,uxSchedulerSuspended
 3012 0cea 8111      		cpse r24,__zero_reg__
 3013 0cec 00C0      		rjmp .L232
4918:../../Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3014               		.loc 1 4918 0
 3015 0cee 7F01      		movw r14,r30
 3016 0cf0 22E0      		ldi r18,2
 3017 0cf2 E20E      		add r14,r18
 3018 0cf4 F11C      		adc r15,__zero_reg__
 3019               	.LVL242:
 3020 0cf6 C701      		movw r24,r14
 3021 0cf8 0E94 0000 		call uxListRemove
 3022               	.LVL243:
4919:../../Source/tasks.c **** 				}
 3023               		.loc 1 4919 0
 3024 0cfc 8E89      		ldd r24,Y+22
 3025 0cfe 9091 0000 		lds r25,uxTopReadyPriority
 3026 0d02 9817      		cp r25,r24
 3027 0d04 00F4      		brsh .L233
4919:../../Source/tasks.c **** 				}
 3028               		.loc 1 4919 0 is_stmt 0 discriminator 1
 3029 0d06 8093 0000 		sts uxTopReadyPriority,r24
 3030               	.L233:
4919:../../Source/tasks.c **** 				}
 3031               		.loc 1 4919 0 discriminator 3
 3032 0d0a E9E0      		ldi r30,lo8(9)
 3033 0d0c 8E9F      		mul r24,r30
 3034 0d0e C001      		movw r24,r0
 3035 0d10 1124      		clr __zero_reg__
 3036 0d12 B701      		movw r22,r14
 3037 0d14 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3038 0d16 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3039 0d18 00C0      		rjmp .L240
 3040               	.LVL244:
 3041               	.L232:
4925:../../Source/tasks.c **** 				}
 3042               		.loc 1 4925 0 is_stmt 1
 3043 0d1a BF01      		movw r22,r30
 3044 0d1c 645F      		subi r22,-12
 3045 0d1e 7F4F      		sbci r23,-1
 3046 0d20 80E0      		ldi r24,lo8(xPendingReadyList)
 3047 0d22 90E0      		ldi r25,hi8(xPendingReadyList)
 3048               	.LVL245:
 3049               	.L240:
 3050 0d24 0E94 0000 		call vListInsertEnd
 3051               	.LVL246:
4928:../../Source/tasks.c **** 				{
 3052               		.loc 1 4928 0
 3053 0d28 E091 0000 		lds r30,pxCurrentTCB
 3054 0d2c F091 0000 		lds r31,pxCurrentTCB+1
 3055 0d30 9E89      		ldd r25,Y+22
 3056 0d32 8689      		ldd r24,Z+22
 3057 0d34 8917      		cp r24,r25
 3058 0d36 00F4      		brsh .L229
4932:../../Source/tasks.c **** 					{
 3059               		.loc 1 4932 0
 3060 0d38 0115      		cp r16,__zero_reg__
 3061 0d3a 1105      		cpc r17,__zero_reg__
 3062 0d3c 01F0      		breq .L236
4934:../../Source/tasks.c **** 					}
 3063               		.loc 1 4934 0
 3064 0d3e 81E0      		ldi r24,lo8(1)
 3065 0d40 F801      		movw r30,r16
 3066 0d42 8083      		st Z,r24
 3067               	.L236:
4940:../../Source/tasks.c **** 				}
 3068               		.loc 1 4940 0
 3069 0d44 81E0      		ldi r24,lo8(1)
 3070 0d46 8093 0000 		sts xYieldPending,r24
 3071               	.LVL247:
 3072               	.L229:
 3073               	/* epilogue start */
4949:../../Source/tasks.c **** 
 3074               		.loc 1 4949 0
 3075 0d4a DF91      		pop r29
 3076 0d4c CF91      		pop r28
 3077 0d4e 1F91      		pop r17
 3078 0d50 0F91      		pop r16
 3079 0d52 FF90      		pop r15
 3080 0d54 EF90      		pop r14
 3081 0d56 0895      		ret
 3082               		.cfi_endproc
 3083               	.LFE38:
 3085               	.global	xTaskNotifyStateClear
 3087               	xTaskNotifyStateClear:
 3088               	.LFB39:
4958:../../Source/tasks.c **** 	TCB_t *pxTCB;
 3089               		.loc 1 4958 0
 3090               		.cfi_startproc
 3091               	.LVL248:
 3092               	/* prologue: function */
 3093               	/* frame size = 0 */
 3094               	/* stack size = 0 */
 3095               	.L__stack_usage = 0
4964:../../Source/tasks.c **** 
 3096               		.loc 1 4964 0
 3097 0d58 0097      		sbiw r24,0
 3098 0d5a 01F4      		brne .L242
4964:../../Source/tasks.c **** 
 3099               		.loc 1 4964 0 is_stmt 0 discriminator 1
 3100 0d5c 8091 0000 		lds r24,pxCurrentTCB
 3101 0d60 9091 0000 		lds r25,pxCurrentTCB+1
 3102               	.LVL249:
 3103               	.L242:
4966:../../Source/tasks.c **** 		{
 3104               		.loc 1 4966 0 is_stmt 1 discriminator 4
 3105               	/* #APP */
 3106               	 ;  4966 "../../Source/tasks.c" 1
 3107 0d64 0FB6      		in __tmp_reg__, __SREG__
 3108 0d66 F894      		cli
 3109 0d68 0F92      		push __tmp_reg__
 3110               		
 3111               	 ;  0 "" 2
4968:../../Source/tasks.c **** 			{
 3112               		.loc 1 4968 0 discriminator 4
 3113               	/* #NOAPP */
 3114 0d6a FC01      		movw r30,r24
 3115 0d6c 25A1      		ldd r18,Z+37
 3116 0d6e 2230      		cpi r18,lo8(2)
 3117 0d70 01F4      		brne .L244
4970:../../Source/tasks.c **** 				xReturn = pdPASS;
 3118               		.loc 1 4970 0
 3119 0d72 15A2      		std Z+37,__zero_reg__
 3120               	.LVL250:
4971:../../Source/tasks.c **** 			}
 3121               		.loc 1 4971 0
 3122 0d74 81E0      		ldi r24,lo8(1)
 3123               	.LVL251:
 3124 0d76 00C0      		rjmp .L243
 3125               	.LVL252:
 3126               	.L244:
4975:../../Source/tasks.c **** 			}
 3127               		.loc 1 4975 0
 3128 0d78 80E0      		ldi r24,0
 3129               	.LVL253:
 3130               	.L243:
4978:../../Source/tasks.c **** 
 3131               		.loc 1 4978 0
 3132               	/* #APP */
 3133               	 ;  4978 "../../Source/tasks.c" 1
 3134 0d7a 0F90      		pop __tmp_reg__
 3135 0d7c 0FBE      		out __SREG__, __tmp_reg__
 3136               		
 3137               	 ;  0 "" 2
4981:../../Source/tasks.c **** 
 3138               		.loc 1 4981 0
 3139               	/* #NOAPP */
 3140 0d7e 0895      		ret
 3141               		.cfi_endproc
 3142               	.LFE39:
 3144               		.local	uxSchedulerSuspended
 3145               		.comm	uxSchedulerSuspended,1,1
 3146               		.local	xIdleTaskHandle
 3147               		.comm	xIdleTaskHandle,2,1
 3148               		.local	xNextTaskUnblockTime
 3149               		.comm	xNextTaskUnblockTime,2,1
 3150               		.local	uxTaskNumber
 3151               		.comm	uxTaskNumber,1,1
 3152               		.local	xNumOfOverflows
 3153               		.comm	xNumOfOverflows,1,1
 3154               		.local	xYieldPending
 3155               		.comm	xYieldPending,1,1
 3156               		.local	uxPendedTicks
 3157               		.comm	uxPendedTicks,1,1
 3158               		.local	xSchedulerRunning
 3159               		.comm	xSchedulerRunning,1,1
 3160               		.local	uxTopReadyPriority
 3161               		.comm	uxTopReadyPriority,1,1
 3162               		.local	xTickCount
 3163               		.comm	xTickCount,2,1
 3164               		.local	uxCurrentNumberOfTasks
 3165               		.comm	uxCurrentNumberOfTasks,1,1
 3166               		.local	uxDeletedTasksWaitingCleanUp
 3167               		.comm	uxDeletedTasksWaitingCleanUp,1,1
 3168               		.local	xTasksWaitingTermination
 3169               		.comm	xTasksWaitingTermination,9,1
 3170               		.local	xPendingReadyList
 3171               		.comm	xPendingReadyList,9,1
 3172               		.local	pxOverflowDelayedTaskList
 3173               		.comm	pxOverflowDelayedTaskList,2,1
 3174               		.local	pxDelayedTaskList
 3175               		.comm	pxDelayedTaskList,2,1
 3176               		.local	xDelayedTaskList2
 3177               		.comm	xDelayedTaskList2,9,1
 3178               		.local	xDelayedTaskList1
 3179               		.comm	xDelayedTaskList1,9,1
 3180               		.local	pxReadyTasksLists
 3181               		.comm	pxReadyTasksLists,36,1
 3182               	.global	pxCurrentTCB
 3183               		.section .bss
 3186               	pxCurrentTCB:
 3187 0000 0000      		.zero	2
 3188               		.text
 3189               	.Letext0:
 3190               		.file 2 "/home/link/avr8-gnu-toolchain/lib/gcc/avr/5.4.0/include/stddef.h"
 3191               		.file 3 "/home/link/avr8-gnu-toolchain/avr/include/stdint.h"
 3192               		.file 4 "../../Source/include/projdefs.h"
 3193               		.file 5 "../../Source/include/../portable/GCC/ATMega323/portmacro.h"
 3194               		.file 6 "../../Source/include/list.h"
 3195               		.file 7 "../../Source/include/task.h"
 3196               		.file 8 "../../Source/include/portable.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccPTRbzF.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPTRbzF.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPTRbzF.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPTRbzF.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccPTRbzF.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPTRbzF.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPTRbzF.s:12     .text:0000000000000000 prvResetNextTaskUnblockTime
     /tmp/ccPTRbzF.s:3173   .bss:0000000000000025 pxDelayedTaskList
     /tmp/ccPTRbzF.s:3147   .bss:0000000000000005 xNextTaskUnblockTime
     /tmp/ccPTRbzF.s:60     .text:0000000000000036 prvAddCurrentTaskToDelayedList.isra.2
     /tmp/ccPTRbzF.s:3161   .bss:000000000000000d xTickCount
     /tmp/ccPTRbzF.s:3186   .bss:0000000000000000 pxCurrentTCB
     /tmp/ccPTRbzF.s:3171   .bss:0000000000000023 pxOverflowDelayedTaskList
     /tmp/ccPTRbzF.s:175    .lowtext:0000000000000000 prvIdleTask
     /tmp/ccPTRbzF.s:3165   .bss:0000000000000010 uxDeletedTasksWaitingCleanUp
     /tmp/ccPTRbzF.s:3167   .bss:0000000000000011 xTasksWaitingTermination
     /tmp/ccPTRbzF.s:3163   .bss:000000000000000f uxCurrentNumberOfTasks
     /tmp/ccPTRbzF.s:3179   .bss:0000000000000039 pxReadyTasksLists
     /tmp/ccPTRbzF.s:267    .text:00000000000000bc xTaskCreate
     /tmp/ccPTRbzF.s:3177   .bss:0000000000000030 xDelayedTaskList1
     /tmp/ccPTRbzF.s:3175   .bss:0000000000000027 xDelayedTaskList2
     /tmp/ccPTRbzF.s:3169   .bss:000000000000001a xPendingReadyList
     /tmp/ccPTRbzF.s:3157   .bss:000000000000000b xSchedulerRunning
     /tmp/ccPTRbzF.s:3149   .bss:0000000000000007 uxTaskNumber
     /tmp/ccPTRbzF.s:3159   .bss:000000000000000c uxTopReadyPriority
     /tmp/ccPTRbzF.s:674    .text:00000000000002b4 vTaskDelete
     /tmp/ccPTRbzF.s:819    .text:000000000000035e vTaskStartScheduler
     /tmp/ccPTRbzF.s:3145   .bss:0000000000000003 xIdleTaskHandle
     /tmp/ccPTRbzF.s:894    .text:00000000000003b2 vTaskEndScheduler
     /tmp/ccPTRbzF.s:918    .text:00000000000003bc vTaskSuspendAll
                             .bss:0000000000000002 uxSchedulerSuspended
     /tmp/ccPTRbzF.s:936    .text:00000000000003c8 xTaskGetTickCount
     /tmp/ccPTRbzF.s:972    .text:00000000000003dc xTaskGetTickCountFromISR
     /tmp/ccPTRbzF.s:992    .text:00000000000003e6 uxTaskGetNumberOfTasks
     /tmp/ccPTRbzF.s:1009   .text:00000000000003ec pcTaskGetName
     /tmp/ccPTRbzF.s:1035   .text:00000000000003fc xTaskIncrementTick
     /tmp/ccPTRbzF.s:3151   .bss:0000000000000008 xNumOfOverflows
     /tmp/ccPTRbzF.s:3155   .bss:000000000000000a uxPendedTicks
     /tmp/ccPTRbzF.s:3153   .bss:0000000000000009 xYieldPending
     /tmp/ccPTRbzF.s:1275   .text:0000000000000554 xTaskResumeAll
     /tmp/ccPTRbzF.s:1464   .text:0000000000000632 vTaskDelayUntil
     /tmp/ccPTRbzF.s:1578   .text:00000000000006a0 vTaskDelay
     /tmp/ccPTRbzF.s:1634   .text:00000000000006c8 vTaskSwitchContext
     /tmp/ccPTRbzF.s:1728   .text:000000000000074e vTaskPlaceOnEventList
     /tmp/ccPTRbzF.s:1769   .text:000000000000076e vTaskPlaceOnUnorderedEventList
     /tmp/ccPTRbzF.s:1816   .text:000000000000079c xTaskRemoveFromEventList
     /tmp/ccPTRbzF.s:1924   .text:000000000000081c vTaskRemoveFromUnorderedEventList
     /tmp/ccPTRbzF.s:2012   .text:0000000000000880 vTaskSetTimeOutState
     /tmp/ccPTRbzF.s:2053   .text:00000000000008a0 vTaskInternalSetTimeOutState
     /tmp/ccPTRbzF.s:2077   .text:00000000000008b6 xTaskCheckForTimeOut
     /tmp/ccPTRbzF.s:2166   .text:000000000000090a vTaskMissedYield
     /tmp/ccPTRbzF.s:2183   .text:0000000000000912 uxTaskResetEventItemValue
     /tmp/ccPTRbzF.s:2217   .text:0000000000000940 ulTaskNotifyTake
     /tmp/ccPTRbzF.s:2349   .text:00000000000009e0 xTaskNotifyWait
     /tmp/ccPTRbzF.s:2568   .text:0000000000000aee xTaskGenericNotify
     /tmp/ccPTRbzF.s:2747   .text:0000000000000bc0 xTaskGenericNotifyFromISR
     /tmp/ccPTRbzF.s:2951   .text:0000000000000cb4 vTaskNotifyGiveFromISR
     /tmp/ccPTRbzF.s:3087   .text:0000000000000d58 xTaskNotifyStateClear

UNDEFINED SYMBOLS
uxListRemove
vListInsert
vPortFree
vPortYield
vApplicationIdleHook
pvPortMalloc
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vListInsertEnd
xPortStartScheduler
vPortEndScheduler
__do_copy_data
__do_clear_bss
